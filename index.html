<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Grid System with Save/Load</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            height: 100vh;
            width: 100vw;
            display: flex;
            color: #333;
            cursor: default;
            transition: background 0.5s;
        }
        
        body.arrow-mode .block {
            cursor: crosshair;
        }

        .container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .grid {
            position: absolute;
            min-width: 200vw;
            min-height: 200vh;
            left: 0;
            top: 0;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            background-position: center center;
            transform-origin: center;
            will-change: transform;
            transition: background-image 0.5s;
        }
        
        #arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        #arrow-svg line {
            pointer-events: all; /* Make lines clickable */
            cursor: pointer;
            transition: stroke 0.3s, stroke-width 0.3s;
        }

        #arrow-svg line.selected {
            stroke: #e74c3c !important; /* Use important to override inline styles */
            stroke-width: 5px;
        }

        .block {
            position: absolute;
            width: 200px;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid transparent;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 15px;
            cursor: move;
            overflow: hidden;
            transition: all 0.3s;
            user-select: none;
            z-index: 10;
            resize: both;
        }

        .block.selected {
            border-color: #3498db;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
        }

        .block-content {
            outline: none;
            padding: 5px;
            line-height: 1.4;
            width: 100%;
            min-height: 30px;
            overflow-wrap: break-word;
            transition: color 0.3s, font-size 0.3s;
        }

        .block-edit {
            display: none; width: 100%; height: auto; min-height: 80px;
            border: 2px solid #3498db; border-radius: 5px; padding: 10px;
            font-family: inherit; line-height: 1.4; resize: none; overflow: hidden;
        }

        .coordinates {
            position: fixed; bottom: 90px; right: 20px;
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px;
            border-radius: 20px; font-size: 0.9rem; z-index: 1000; cursor: pointer;
        }
        .coordinates input {
            width: 60px; background: #333; color: white; border: 1px solid #555;
            border-radius: 5px; padding: 2px 5px; text-align: center;
        }

        .instructions {
            position: fixed; bottom: 90px; left: 20px;
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px;
            border-radius: 20px; font-size: 0.9rem; z-index: 1000; opacity: 0.8;
        }

        .control-panel {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9); padding: 10px 15px;
            border-radius: 50px; display: flex; gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2); z-index: 1000;
        }

        .control-btn {
            background: #2c5364; color: white; border: none; padding: 10px 18px;
            border-radius: 30px; cursor: pointer; font-weight: 600;
            transition: all 0.3s; display: flex; align-items: center; gap: 8px;
            font-size: 14px;
        }
        .control-btn.active { background: #e74c3c; }
        .control-btn:hover { background: #3498db; transform: translateY(-2px); }
        .btn-icon { font-size: 16px; }

        /* --- Customize Panel --- */
        #customize-panel {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 2000;
            font-size: 14px;
        }
        .panel-header {
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header h3 { font-weight: 600; }
        .panel-close-btn {
            background: none; border: none; color: white; font-size: 20px;
            cursor: pointer; opacity: 0.7; transition: opacity 0.2s;
        }
        .panel-close-btn:hover { opacity: 1; }
        .panel-content { padding: 15px; }
        .control-group { margin-bottom: 15px; }
        .control-group h4 {
            font-size: 12px; text-transform: uppercase;
            color: #aaa; margin-bottom: 8px; border-bottom: 1px solid #555; padding-bottom: 5px;
        }
        .control-group label {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
        }
        .control-group input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 24px; height: 24px; background-color: transparent;
            border: none; cursor: pointer; padding: 0;
        }
        .control-group input[type="color"]::-webkit-color-swatch {
            border-radius: 50%; border: 1px solid #666;
        }
        .control-group input[type="range"], .control-group input[type="number"] {
            width: 120px;
        }
        .hidden { display: none !important; }
        
        /* Shortcut hint styling */
        .shortcut-hint {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0.9;
            max-width: 300px;
        }
        .shortcut-hint kbd {
            background: #555;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="grid" id="grid">
            <svg id="arrow-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#3498db" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div class="coordinates" id="coordinates">Nothing selected</div>
    <div class="instructions" id="instructions">Hold Shift + Drag to pan</div>
    
    <div class="shortcut-hint" id="shortcut-hint" style="display: none;">
        Press <kbd>H</kbd> to show/hide shortcuts<br>Press <kbd>SHIFT D</kbd> to add a block<br>Hold <kbd>Ctrl</kbd> to toggle arrow mode<br>Press <kbd>B</kbd> to toggle customize menu<br>Press <kbd>Ctrl S</kbd> to save<br>Press <kbd>Ctrl L</kbd> to load</div>
    </div>

    <div class="control-panel">
        <button class="control-btn" id="add-block-btn"><span class="btn-icon">+</span><span>Add block</span></button>
        <button class="control-btn" id="toggle-arrow-mode-btn"><span class="btn-icon">â†’</span><span>Arrow</span></button>
        <button class="control-btn" id="toggle-customize-btn"><span class="btn-icon">ðŸŽ¨</span><span>Customize</span></button>
        <button class="control-btn" id="save-btn"><span class="btn-icon">ðŸ’¾</span><span>Save</span></button>
        <button class="control-btn" id="load-btn"><span class="btn-icon">ðŸ“‚</span><span>Load</span></button>
    </div>

    <div id="customize-panel">
        <div class="panel-header"><h3>Customize</h3><button class="panel-close-btn">&times;</button></div>
        <div class="panel-content">
            <div id="block-controls" class="control-group hidden"><h4>Block</h4><label><span>Background</span><input type="color" id="block-bg-color"></label><label><span>Border</span><input type="color" id="block-border-color"></label></div>
            <div id="text-controls" class="control-group hidden"><h4>Text</h4><label><span>Color</span><input type="color" id="text-color"></label><label><span>Size (px)</span><input type="number" id="text-size" min="8" max="48" step="1"></label></div>
            <div id="arrow-controls" class="control-group hidden"><h4>Arrow</h4><label><span>Color</span><input type="color" id="arrow-color"></label><label><span>Width (px)</span><input type="range" id="arrow-width" min="1" max="10" step="1"></label></div>
            <div id="grid-controls" class="control-group"><h4>Grid</h4><label><span>Background</span><input type="color" id="grid-bg-color"></label><label><span>Line Color</span><input type="color" id="grid-line-color"></label></div>
        </div>
    </div>
    
    <input type="file" id="file-loader" accept=".json" style="display: none;">

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- Element References ---
        const grid = document.getElementById('grid');
        const svgCanvas = document.getElementById('arrow-svg');
        const coordsDisplay = document.getElementById('coordinates');
        const instructions = document.getElementById('instructions');
        const addBlockBtn = document.getElementById('add-block-btn');
        const toggleArrowModeBtn = document.getElementById('toggle-arrow-mode-btn');
        const toggleCustomizeBtn = document.getElementById('toggle-customize-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileLoader = document.getElementById('file-loader');
        const customizePanel = document.getElementById('customize-panel');
        const shortcutHint = document.getElementById('shortcut-hint');

        // --- State Variables ---
        let isDragging = false, isPanning = false, isEditing = false, isArrowMode = false, isDrawingArrow = false;
        let currentBlock = null, selectedBlock = null, selectedArrow = null, arrowStartBlock = null;
        let startX, startY, initialBlockX, initialBlockY;
        let gridX = 0, gridY = 0, blockCounter = 1;
        let tempArrow = null;
        let ctrlPressed = false;

        // Show shortcut hint briefly on load
        shortcutHint.style.display = 'block';
        setTimeout(() => {
            shortcutHint.style.display = 'none';
        }, 30000);

        // --- Initial Setup ---
        createBlock({ x: 100, y: 100, content: "Welcome! Use the buttons below to save or load your work." });
        createBlock({ x: 450, y: 250, content: "All colors and connections will be saved." });

        // --- Event Listeners ---
        addBlockBtn.addEventListener('click', addNewBlock);
        toggleArrowModeBtn.addEventListener('click', toggleArrowMode);
        saveBtn.addEventListener('click', saveState);
        loadBtn.addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', loadState);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        grid.addEventListener('click', handleGridClick);
        svgCanvas.addEventListener('click', handleArrowClick);
        coordsDisplay.addEventListener('dblclick', editCoordinates);

        // Customize panel toggle
        toggleCustomizeBtn.addEventListener('click', () => {
            if (customizePanel.style.display === 'block') {
                customizePanel.style.display = 'none';
            } else {
                customizePanel.style.display = 'block';
                updateCustomizePanel();
            }
        });

        // --- Selection Logic ---
        function selectBlock(block) {
            deselectAll();
            selectedBlock = block;
            selectedBlock.classList.add('selected');
            updateCoordinates();
            updateCustomizePanel();
        }

        function selectArrow(arrow) {
            deselectAll();
            selectedArrow = arrow;
            selectedArrow.classList.add('selected');
            coordsDisplay.textContent = "Arrow selected";
            updateCustomizePanel();
        }

        function deselectAll() {
            if (selectedBlock) selectedBlock.classList.remove('selected');
            if (selectedArrow) selectedArrow.classList.remove('selected');
            selectedBlock = null;
            selectedArrow = null;
            coordsDisplay.textContent = "Nothing selected";
            updateCustomizePanel();
        }

        // --- Block & Arrow Management ---
        function createBlock(config) {
            const block = document.createElement('div');
            block.id = config.id || `block-${blockCounter++}`;
            block.className = 'block';
            block.style.left = `${config.x}px`;
            block.style.top = `${config.y}px`;
            if (config.width) block.style.width = `${config.width}px`;
            if (config.height) block.style.height = `${config.height}px`;
            if (config.bgColor) block.style.backgroundColor = config.bgColor;
            if (config.borderColor) block.style.borderColor = config.borderColor;
            
            const contentEl = document.createElement('div');
            contentEl.className = 'block-content';
            contentEl.textContent = config.content;
            if (config.textColor) contentEl.style.color = config.textColor;
            if (config.textSize) contentEl.style.fontSize = `${config.textSize}px`;
            
            block.innerHTML = `<textarea class="block-edit"></textarea>`;
            block.prepend(contentEl);
            grid.appendChild(block);

            block.addEventListener('mousedown', (e) => handleBlockMouseDown(e, block));
            contentEl.addEventListener('dblclick', () => startEditing(block));
            const editTextarea = block.querySelector('.block-edit');
            editTextarea.addEventListener('keydown', (e) => handleTextEditKeyDown(e, block));
            editTextarea.addEventListener('blur', () => finishEditing(block));
            editTextarea.addEventListener('input', e => { e.target.style.height = 'auto'; e.target.style.height = `${e.target.scrollHeight}px`; });
            
// ...existing code...
            new ResizeObserver(() => updateArrowsForBlock(block)).observe(block);
            return block;
        }

        function addNewBlock() {
            const blocks = Array.from(document.querySelectorAll('.block'));
            let x, y;
            const margin = 40;
            const blockWidth = 200; // Default width
            const blockHeight = 100; // Default height
            const gridRect = grid.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (blocks.length > 0) {
                const lastBlock = blocks[blocks.length - 1];
                const lastX = parseInt(lastBlock.style.left);
                const lastY = parseInt(lastBlock.style.top);
                const lastW = lastBlock.offsetWidth;

                // Potential position to the right of the last block
                const potentialX = lastX + lastW + margin;
                const potentialY = lastY;

                // Absolute screen position of the potential new block
                const absoluteX = gridRect.left + potentialX;
                const absoluteY = gridRect.top + potentialY;

                // Check if this position is within the visible viewport
                if (
                    absoluteX >= 0 &&
                    absoluteY >= 0 &&
                    absoluteX + blockWidth <= viewportWidth &&
                    absoluteY + blockHeight <= viewportHeight
                ) {
                    // If it fits, use this position
                    x = potentialX;
                    y = potentialY;
                } else {
                    // Otherwise, place it in the center of the viewport, relative to the grid
                    x = Math.max(0, Math.round((viewportWidth - blockWidth) / 2 - gridRect.left));
                    y = Math.max(0, Math.round((viewportHeight - blockHeight) / 2 - gridRect.top));
                }
            } else {
                // If it's the first block, place it in the center of the viewport
                x = Math.max(0, Math.round((viewportWidth - blockWidth) / 2 - gridRect.left));
                y = Math.max(0, Math.round((viewportHeight - blockHeight) / 2 - gridRect.top));
            }

            selectBlock(createBlock({ x, y, content: "New block." }));
        }

        // --- Event Handlers ---
        function handleBlockMouseDown(e, block) {
            if (isEditing) return;
            if (isArrowMode || ctrlPressed) startArrow(e, block);
            else { selectBlock(block); startDragging(e, block); }
        }

        function handleMouseMove(e) {
            if (isPanning && e.shiftKey) panGrid(e);
            else if (isDragging && currentBlock) dragBlock(e);
            else if (isDrawingArrow) drawArrow(e);
        }

        function handleMouseUp(e) {
            if (isDrawingArrow) endArrow(e);
            if (isDragging) stopDragging();
        }

        function handleGridClick(e) {
            if (e.target === grid) deselectAll();
        }
        
        function handleArrowClick(e) {
            if (e.target.tagName === 'line') { e.stopPropagation(); selectArrow(e.target); }
        }

        function handleKeyDown(e) {
            // Handle Ctrl key for arrow mode
            if (e.key === 'Control' && !isEditing) {
                ctrlPressed = true;
                if (!isArrowMode) {
                    isArrowMode = true;
                    document.body.classList.add('arrow-mode');
                    instructions.textContent = "Click & drag between blocks";
                    toggleArrowModeBtn.classList.add('active');
                }
            }
            
            if (e.key === 'Shift' && !isEditing) { 
                isPanning = true; 
                instructions.textContent = "Dragging to pan..."; 
            }
            
            if (e.key === 'Delete' && !isEditing) {
                if (selectedBlock) {
                    const blockId = selectedBlock.id;
                    svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(a => a.remove());
                    selectedBlock.remove(); 
                    deselectAll();
                } else if (selectedArrow) { 
                    selectedArrow.remove(); 
                    deselectAll(); 
                }
            }
            
            // New shortcuts
            if (e.key === 'b' || e.key === 'B') {
                e.preventDefault();
                if (customizePanel.style.display === 'block') {
                    customizePanel.style.display = 'none';
                } else {
                    customizePanel.style.display = 'block';
                    updateCustomizePanel();
                }
            }
            
            if (e.shiftKey && (e.key === 'd' || e.key === 'D')) {
                e.preventDefault();
                addNewBlock();
            }
            
            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                saveState();
            }
            
            if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
                e.preventDefault();
                fileLoader.click();
            }
            
            // Show shortcut help
            if (e.key === 'h' || e.key === 'H') {
                e.preventDefault();
                shortcutHint.style.display = shortcutHint.style.display === 'none' ? 'block' : 'none';
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'Control') {
                ctrlPressed = false;
                if (isArrowMode) {
                    isArrowMode = false;
                    document.body.classList.remove('arrow-mode');
                    instructions.textContent = "Hold Shift + Drag to pan";
                    toggleArrowModeBtn.classList.remove('active');
                }
            }
            
            if (e.key === 'Shift') { 
                isPanning = false; 
                instructions.textContent = "Hold Shift + Drag to pan"; 
            }
        }

        // --- Dragging, Panning, and Arrow Drawing ---
        function startDragging(e, block) {
            currentBlock = block; 
            isDragging = true;
            startX = e.clientX; 
            startY = e.clientY;
            initialBlockX = parseInt(currentBlock.style.left); 
            initialBlockY = parseInt(currentBlock.style.top);
        }

        function dragBlock(e) {
            const deltaX = e.clientX - startX; 
            const deltaY = e.clientY - startY;
            currentBlock.style.left = `${Math.max(0, initialBlockX + deltaX)}px`;
            currentBlock.style.top = `${Math.max(0, initialBlockY + deltaY)}px`;
            updateCoordinates(); 
            updateArrowsForBlock(currentBlock);
        }

        function stopDragging() { 
            isDragging = false; 
            currentBlock = null; 
        }
        
        function panGrid(e) {
            gridX = Math.min(0, gridX + e.movementX); 
            gridY = Math.min(0, gridY + e.movementY);
            grid.style.transform = `translate(${gridX}px, ${gridY}px)`;
        }

        function toggleArrowMode() {
            isArrowMode = !isArrowMode;
            ctrlPressed = isArrowMode;
            document.body.classList.toggle('arrow-mode', isArrowMode);
            toggleArrowModeBtn.classList.toggle('active', isArrowMode);
            instructions.textContent = isArrowMode ? "Click & drag between blocks" : "Hold Shift + Drag to pan";
        }

        function startArrow(e, block) {
            isDrawingArrow = true; 
            arrowStartBlock = block;
            const startPoint = getBlockCenter(block);
            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempArrow.setAttribute('x1', startPoint.x); 
            tempArrow.setAttribute('y1', startPoint.y);
            tempArrow.setAttribute('stroke', '#3498db'); 
            tempArrow.setAttribute('stroke-width', '3');
            tempArrow.setAttribute('marker-end', 'url(#arrowhead)');
            svgCanvas.appendChild(tempArrow);
        }

        function drawArrow(e) {
            if (!tempArrow) return;
            const gridRect = grid.getBoundingClientRect();
            tempArrow.setAttribute('x2', e.clientX - gridRect.left);
            tempArrow.setAttribute('y2', e.clientY - gridRect.top);
        }

        function endArrow(e) {
            const endBlock = e.target.closest('.block');
            if (endBlock && endBlock !== arrowStartBlock) {
                tempArrow.setAttribute('data-start-block', arrowStartBlock.id);
                tempArrow.setAttribute('data-end-block', endBlock.id);
                updateSingleArrow(tempArrow);
            } else { 
                tempArrow.remove(); 
            }
            isDrawingArrow = false; 
            arrowStartBlock = null; 
            tempArrow = null;
        }

        // --- Arrow and Coordinate Updates ---
        function updateSingleArrow(arrowEl) {
            const startBlock = document.getElementById(arrowEl.dataset.startBlock);
            const endBlock = document.getElementById(arrowEl.dataset.endBlock);
            if (!startBlock || !endBlock) return;
            const startPoint = getClosestConnectionPoint(startBlock, endBlock);
            const endPoint = getClosestConnectionPoint(endBlock, startBlock);
            arrowEl.setAttribute('x1', startPoint.x); 
            arrowEl.setAttribute('y1', startPoint.y);
            arrowEl.setAttribute('x2', endPoint.x); 
            arrowEl.setAttribute('y2', endPoint.y);

            // Update arrowhead color to match arrow color
            const color = arrowEl.getAttribute('stroke') || '#3498db';
            // Find the marker polygon and set its fill
            const marker = document.getElementById('arrowhead');
            if (marker) {
                const polygon = marker.querySelector('polygon');
                if (polygon) polygon.setAttribute('fill', color);
            }
        }

        function updateArrowsForBlock(block) {
            const blockId = block.id;
            svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(updateSingleArrow);
        }

        function updateCoordinates() {
            if (selectedBlock) {
                const x = parseInt(selectedBlock.style.left); 
                const y = parseInt(selectedBlock.style.top);
                coordsDisplay.innerHTML = `X: ${x}, Y: ${y}`;
            }
        }
        
        function editCoordinates() {
            if (!selectedBlock || isEditing) return;
            const x = parseInt(selectedBlock.style.left); 
            const y = parseInt(selectedBlock.style.top);
            coordsDisplay.innerHTML = `X: <input type="number" value="${x}" id="coord-x"> Y: <input type="number" value="${y}" id="coord-y">`;
            const inputX = document.getElementById('coord-x'); 
            const inputY = document.getElementById('coord-y');
            inputX.focus(); 
            inputX.select();
            const apply = () => {
                selectedBlock.style.left = `${parseInt(inputX.value) || 0}px`;
                selectedBlock.style.top = `${parseInt(inputY.value) || 0}px`;
                updateArrowsForBlock(selectedBlock); 
                updateCoordinates();
            };
            [inputX, inputY].forEach(input => {
                input.addEventListener('blur', apply);
                input.addEventListener('keydown', e => e.key === 'Enter' && apply());
            });
        }

        // --- Customization Panel ---
        const customizeInputs = {
            block: document.getElementById('block-controls'), 
            text: document.getElementById('text-controls'), 
            arrow: document.getElementById('arrow-controls'),
            blockBg: document.getElementById('block-bg-color'), 
            blockBorder: document.getElementById('block-border-color'),
            textColor: document.getElementById('text-color'), 
            textSize: document.getElementById('text-size'),
            arrowColor: document.getElementById('arrow-color'), 
            arrowWidth: document.getElementById('arrow-width'),
            gridBg: document.getElementById('grid-bg-color'), 
            gridLines: document.getElementById('grid-line-color'),
        };
        
        customizePanel.querySelector('.panel-close-btn').addEventListener('click', () => customizePanel.style.display = 'none');
        
        function updateCustomizePanel() {
            customizeInputs.block.classList.toggle('hidden', !selectedBlock);
            customizeInputs.text.classList.toggle('hidden', !selectedBlock);
            customizeInputs.arrow.classList.toggle('hidden', !selectedArrow);
            if (selectedBlock) {
                const computed = getComputedStyle(selectedBlock); 
                const content = getComputedStyle(selectedBlock.querySelector('.block-content'));
                customizeInputs.blockBg.value = rgbToHex(computed.backgroundColor); 
                customizeInputs.blockBorder.value = rgbToHex(computed.borderColor);
                customizeInputs.textColor.value = rgbToHex(content.color); 
                customizeInputs.textSize.value = parseInt(content.fontSize);
            }
            if (selectedArrow) {
                customizeInputs.arrowColor.value = rgbToHex(selectedArrow.getAttribute('stroke') || '#000000');
                customizeInputs.arrowWidth.value = selectedArrow.getAttribute('stroke-width');
            }
        }
        
        customizeInputs.blockBg.addEventListener('input', e => { if (selectedBlock) selectedBlock.style.backgroundColor = e.target.value; });
        customizeInputs.blockBorder.addEventListener('input', e => { if (selectedBlock) selectedBlock.style.borderColor = e.target.value; });
        customizeInputs.textColor.addEventListener('input', e => { if (selectedBlock) selectedBlock.querySelector('.block-content').style.color = e.target.value; });
        customizeInputs.textSize.addEventListener('input', e => { if (selectedBlock) selectedBlock.querySelector('.block-content').style.fontSize = `${e.target.value}px`; });
        customizeInputs.arrowColor.addEventListener('input', e => { 
            if (selectedArrow) {
                selectedArrow.setAttribute('stroke', e.target.value);
                updateSingleArrow(selectedArrow); // Ensure arrowhead color updates
            }
        });
        customizeInputs.arrowWidth.addEventListener('input', e => { if (selectedArrow) selectedArrow.setAttribute('stroke-width', e.target.value); });
        customizeInputs.gridBg.addEventListener('input', e => { document.body.style.background = e.target.value; });
        customizeInputs.gridLines.addEventListener('input', e => {
            const color = hexToRgba(e.target.value, 0.1);
            grid.style.backgroundImage = `linear-gradient(${color} 1px, transparent 1px), linear-gradient(90deg, ${color} 1px, transparent 1px)`;
        });
        
        // --- Save & Load Logic ---
        function saveState() {
            const state = { blocks: [], arrows: [], styles: {} };
            
            // Save block data
            document.querySelectorAll('.block').forEach(block => {
                const contentEl = block.querySelector('.block-content');
                state.blocks.push({
                    id: block.id,
                    x: parseInt(block.style.left), 
                    y: parseInt(block.style.top),
                    width: block.offsetWidth, 
                    height: block.offsetHeight,
                    content: contentEl.textContent,
                    bgColor: block.style.backgroundColor, 
                    borderColor: block.style.borderColor,
                    textColor: contentEl.style.color, 
                    textSize: parseInt(contentEl.style.fontSize)
                });
            });

            // Save arrow data
            svgCanvas.querySelectorAll('line').forEach(arrow => {
                state.arrows.push({
                    start: arrow.dataset.startBlock, 
                    end: arrow.dataset.endBlock,
                    color: arrow.getAttribute('stroke'), 
                    width: arrow.getAttribute('stroke-width')
                });
            });

            // Save global styles
            state.styles.gridBg = document.body.style.background;
            state.styles.gridLines = grid.style.backgroundImage;

            // Trigger download
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "grid-schema.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function loadState(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const state = JSON.parse(e.target.result);
                    
                    // Clear current state
                    document.querySelectorAll('.block').forEach(b => b.remove());
                    svgCanvas.querySelectorAll('line').forEach(a => a.remove());
                    deselectAll();

                    // Load global styles
                    document.body.style.background = state.styles.gridBg;
                    grid.style.backgroundImage = state.styles.gridLines;

                    // Load blocks
                    let maxId = 0;
                    state.blocks.forEach(blockData => {
                        createBlock(blockData);
                        const idNum = parseInt(blockData.id.split('-')[1]);
                        if (idNum > maxId) maxId = idNum;
                    });
                    blockCounter = maxId + 1; // Prevent ID conflicts

                    // Load arrows
                    state.arrows.forEach(arrowData => {
                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        arrow.dataset.startBlock = arrowData.start;
                        arrow.dataset.endBlock = arrowData.end;
                        arrow.setAttribute('stroke', arrowData.color);
                        arrow.setAttribute('stroke-width', arrowData.width);
                        arrow.setAttribute('marker-end', 'url(#arrowhead)');
                        svgCanvas.appendChild(arrow);
                        updateSingleArrow(arrow);
                    });
                } catch (error) {
                    console.error("Error parsing JSON file:", error);
                    alert("Failed to load file. It may be corrupted or not a valid schema.");
                }
            };
            reader.readAsText(file);
            fileLoader.value = ''; // Reset input for next load
        }

        // --- Utility & Helper Functions ---
        function getBlockCenter(block) {
            const x = parseInt(block.style.left); 
            const y = parseInt(block.style.top);
            return { x: x + block.offsetWidth / 2, y: y + block.offsetHeight / 2 };
        }

        function getClosestConnectionPoint(from, to) {
            const fromRect = { 
                x: parseInt(from.style.left), 
                y: parseInt(from.style.top), 
                w: from.offsetWidth, 
                h: from.offsetHeight 
            };
            const toCenter = getBlockCenter(to);
            const points = [
                { x: fromRect.x + fromRect.w / 2, y: fromRect.y }, 
                { x: fromRect.x + fromRect.w / 2, y: fromRect.y + fromRect.h },
                { x: fromRect.x, y: fromRect.y + fromRect.h / 2 }, 
                { x: fromRect.x + fromRect.w, y: fromRect.y + fromRect.h / 2 }
            ];
            return points.reduce((closest, p) => 
                (Math.hypot(p.x - toCenter.x, p.y - toCenter.y) < closest.dist ? 
                    { point: p, dist: Math.hypot(p.x - toCenter.x, p.y - toCenter.y) } : 
                    closest), 
                { dist: Infinity }
            ).point;
        }

        function rgbToHex(rgb) {
            if (!rgb || !rgb.startsWith('rgb')) return '#ffffff';
            let [r, g, b] = rgb.match(/\d+/g).map(Number);
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0')}`;
        }
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16), 
                  g = parseInt(hex.slice(3, 5), 16), 
                  b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Draggable Panel ---
        let panelDrag = { active: false, x: 0, y: 0 };
        customizePanel.querySelector('.panel-header').addEventListener('mousedown', e => {
            panelDrag.active = true; 
            panelDrag.x = e.clientX - customizePanel.offsetLeft; 
            panelDrag.y = e.clientY - customizePanel.offsetTop;
        });
        document.addEventListener('mousemove', e => {
            if (panelDrag.active) {
                customizePanel.style.left = `${e.clientX - panelDrag.x}px`;
                customizePanel.style.top = `${e.clientY - panelDrag.y}px`;
            }
        });
        document.addEventListener('mouseup', () => panelDrag.active = false);
        
        // --- Text Editing ---
        function startEditing(block) {
            isEditing = true;
            const content = block.querySelector('.block-content'), 
                  textarea = block.querySelector('.block-edit');
            textarea.value = content.textContent; 
            content.style.display = 'none'; 
            textarea.style.display = 'block'; 
            textarea.focus();
            textarea.style.height = 'auto';
            textarea.style.height = `${textarea.scrollHeight}px`;
        }
        
        function finishEditing(block) {
            isEditing = false;
            const content = block.querySelector('.block-content'), 
                  textarea = block.querySelector('.block-edit');
            content.textContent = textarea.value; 
            textarea.style.display = 'none'; 
            content.style.display = 'block';
        }
        
        function handleTextEditKeyDown(e, block) {
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                finishEditing(block); 
            }
            else if (e.key === 'Escape') { 
                finishEditing(block); 
            }
        }
    });
    </script>
</body>
</html>
