<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas - MentMap</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            height: 100vh;
            width: 100vw;
            display: flex;
            color: #333;
            cursor: default;
            transition: background 0.5s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        body.arrow-mode .block {
            cursor: crosshair;
        }

        .container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .grid {
            position: absolute;
            width: 500vw;
            height: 500vh;
            left: 0;
            top: 0;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 30px 30px;
            background-position: top left;
            transform-origin: top left;
            will-change: transform;
            transition: background-image 0.5s;
        }
        
        #arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        #arrow-svg .arrow-group {
            pointer-events: all;
            cursor: pointer;
        }

        #arrow-svg .arrow-hitbox {
            stroke: transparent;
            stroke-width: 15;
        }

        #arrow-svg .arrow-group.selected .arrow-line {
            stroke: #e74c3c !important;
            stroke-width: 5px;
        }

        .block {
            position: absolute;
            width: 200px;
            height: auto;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid transparent;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 15px;
            cursor: grab;
            overflow: visible;
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s;
            user-select: none;
            z-index: 10;
            resize: none;
            display: flex;
            flex-direction: column;
        }

        .block.selected {
            border-color: #3498db;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
        }
        
        .block.pre-selected {
            outline: 2px dashed rgba(52, 152, 219, 0.5);
        }

        .block-content {
            outline: none;
            padding: 5px;
            line-height: 1.4;
            width: 100%;
            min-height: 30px;
            overflow-wrap: break-word;
            transition: color 0.3s, font-size 0.3s;
            flex-grow: 1;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: text;
        }

        .block-content[contenteditable="true"] {
            border: 1px dashed #3498db;
            padding: 4px;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .block-content iframe,
        .block-content img,
        .block-content video {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 5px;
            cursor: default;
        }

        .block.dragging iframe,
        .block.dragging video {
            pointer-events: none;
        }
        
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--handle-color, rgba(128, 128, 128, 0.5));
            display: var(--handle-display, block);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 20;
            opacity: 0.6;
            transition: opacity 0.2s, background-color 0.2s;
        }
        .block:hover .resize-handle {
            opacity: 1;
            background-color: var(--handle-color, #3498db);
        }

        .handle-n { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-ne { top: -5px; right: -5px; cursor: nesw-resize; }
        .handle-e { top: 50%; right: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .handle-se { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .handle-s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .handle-w { top: 50%; left: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .handle-nw { top: -5px; left: -5px; cursor: nwse-resize; }
        
        .coordinates {
            position: fixed; 
            bottom: 20px; 
            left: 20px;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            color: white; 
            padding: 10px 15px;
            border-radius: 10px; 
            font-size: 0.9rem; 
            z-index: 2001; 
            cursor: pointer;
            min-width: 200px;
            text-align: left;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: opacity 0.3s, transform 0.3s;
        }
        .coordinates.hidden {
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
        }
        .coordinates input {
            width: 70px; 
            background: #333; 
            color: white; 
            border: 1px solid #555;
            border-radius: 5px; 
            padding: 2px 5px; 
            text-align: center;
            margin: 0 2px;
        }

        .shortcut-hint {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0.9;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .shortcut-hint kbd {
            background: #555;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
        }

        #context-menu {
            display: none;
            position: fixed;
            z-index: 3000;
            background: rgba(50, 50, 50, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 5px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        }
        #context-menu ul { list-style: none; padding: 0; margin: 0; }
        #context-menu li { padding: 8px 15px; color: white; cursor: pointer; border-radius: 5px; font-size: 14px; }
        #context-menu li:hover { background: #3498db; }

        .marquee-box {
            position: fixed;
            border: 1px dashed #3498db;
            background: rgba(52, 152, 219, 0.2);
            pointer-events: none;
            z-index: 9999;
        }

        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            z-index: 10000;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
            pointer-events: none;
        }
        .toast-notification.show { opacity: 1; bottom: 100px; }

        input, textarea, select {
            user-select: auto;
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
        }

        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100vh;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            box-shadow: -5px 0 25px rgba(0,0,0,0.5);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
        }
        .sidebar.hidden {
            transform: translateX(100%);
        }

        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid #555;
        }
        .sidebar-section:last-child {
            border-bottom: none;
        }
        .sidebar-section h4 {
            font-size: 12px;
            text-transform: uppercase;
            color: #aaa;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #555;
        }

        .page-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .page-btn {
            background: #555;
            color: white;
            border: 1px solid #777;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
        }
        .page-btn:hover {
            background-color: #3498db;
            transform: scale(1.1);
        }
        .page-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            background-color: #555;
        }
        #page-display {
            font-weight: 600;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 15px;
            min-width: 80px;
            text-align: center;
            margin: 5px 0;
        }

        .actions-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-btn {
            width: 100%;
            background: #555;
            color: white;
            border: 1px solid #666;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
        }
        .control-btn.active { background: #e74c3c; }
        .control-btn:hover { background: #3498db; }
        .control-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }


        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .color-picker-wrapper {
            width: 24px;
            height: 24px;
        }
        .control-group input[type="range"], .control-group input[type="number"], .control-group select, .control-group input[type="text"], .control-group input[type="checkbox"] {
            width: 120px;
            background: #444; color: white; border: 1px solid #666; border-radius: 4px; padding: 3px;
        }
        .control-group input[type="checkbox"] { width: auto; }
        .text-format-buttons { display: flex; gap: 10px; }
        .format-btn {
            flex: 1; background: #555; border: 1px solid #666;
            color: white; padding: 5px; border-radius: 4px; cursor: pointer;
            transition: background-color 0.2s;
        }
        .format-btn:hover { background: #666; }
        .format-btn.active { background-color: #3498db; }
        .hidden { display: none !important; }

        /* Custom Color Picker Theme */
        .pickr .pcr-button {
            height: 24px;
            width: 24px;
            border-radius: 50%;
        }
         .pickr .pcr-button::before {
            border-radius: 50%;
        }
        .pcr-app {
            z-index: 3000;
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="grid" id="grid">
            <svg id="arrow-svg">
                <defs></defs>
            </svg>
        </div>
    </div>

    <div class="coordinates" id="coordinates">Nothing selected</div>

    <div class="shortcut-hint" id="shortcut-hint" style="display: none;">
        Pressione <kbd>H</kbd> para mostrar/esconder os atalhos<br><hr style="border-color: #555; margin: 5px 0;">
        <b>Navegação e Visualização:</b><br>
        Segure <kbd>Shift</kbd> ou <kbd>Clique Meio</kbd> para mover o mapa<br>
        Use o <kbd>Scroll</kbd> para dar zoom<br>
        <kbd>←</kbd> / <kbd>→</kbd> para mudar de slide<br>
        <kbd>G</kbd> Esconder/Mostrar Painel Lateral<br>
        <kbd>N</kbd> Esconder/Mostrar Coordenadas<br>
        <hr style="border-color: #555; margin: 5px 0;">
        <b>Ações e Atalhos:</b><br>
        <kbd>Shift</kbd> + <kbd>A</kbd> Adicionar conteúdo<br>
        <kbd>Shift</kbd> + <kbd>D</kbd> Duplicar/Adicionar<br>
        <kbd>Shift</kbd> + <kbd>+</kbd> Adicionar Slide<br>
        <kbd>Shift</kbd> + <kbd>-</kbd> Deletar Slide<br>
        <kbd>B</kbd> Paleta de Cores Inteligente<br>
        <kbd>Delete</kbd> Apagar itens<br>
        <kbd>Ctrl</kbd> + <kbd>Z</kbd> Desfazer<br>
        <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> Refazer<br>
        <kbd>Ctrl</kbd> + <kbd>S</kbd> para salvar<br>
        <kbd>Ctrl</kbd> + <kbd>L</kbd> para carregar
    </div>

    <div class="sidebar">
        <div class="sidebar-section">
            <h4>Slides</h4>
            <div class="page-controls">
                <button class="page-btn" id="prev-page-btn" title="Previous Page (←)">▲</button>
                <span id="page-display">Page 1 / 1</span>
                <button class="page-btn" id="next-page-btn" title="Next Page (→)">▼</button>
                <button class="page-btn" id="add-page-btn" title="Add New Page (Shift +)">+</button>
                <button class="page-btn" id="delete-page-btn" title="Delete Current Page (Shift -)">🗑️</button>
            </div>
        </div>
        <div class="sidebar-section">
            <h4>Actions</h4>
            <div class="actions-grid">
                <button class="control-btn" id="add-content-btn"><span class="btn-icon">+</span><span>Adicionar conteúdo</span></button>
                <button class="control-btn" id="toggle-arrow-mode-btn"><span class="btn-icon">→</span><span>Seta</span></button>
                <button class="control-btn" id="save-btn"><span class="btn-icon">💾</span><span>Salvar</span></button>
                <button class="control-btn" id="load-btn"><span class="btn-icon">📂</span><span>Carregar</span></button>
            </div>
        </div>
        <div class="sidebar-section">
            <h4>Customize</h4>
            <div id="customize-content">
                <div id="block-controls" class="control-group hidden"><h5>Block</h5><label><span>Background</span><div class="color-picker-wrapper" id="block-bg-color"></div></label><label><span>Border</span><div class="color-picker-wrapper" id="block-border-color"></div></label></div>
                <div id="handle-controls" class="control-group hidden"><h5>Handles</h5><label><span>Color</span><div class="color-picker-wrapper" id="handle-color"></div></label><label><span>Visible</span><input type="checkbox" id="handle-visible" checked></label></div>
                <div id="text-controls" class="control-group hidden">
                    <h5>Text</h5>
                    <div class="text-format-buttons">
                        <button id="bold-btn" class="format-btn"><b>B</b></button>
                        <button id="italic-btn" class="format-btn"><i>I</i></button>
                        <button id="underline-btn" class="format-btn"><u>U</u></button>
                    </div>
                    <label><span>Color</span><div class="color-picker-wrapper" id="text-color"></div></label><label><span>Size (px)</span><select id="text-size"></select></label><label><span>Font</span><select id="text-font"><option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">Default</option><option value="Arial, sans-serif">Arial</option><option value="Georgia, serif">Georgia</option><option value="Courier New, monospace">Courier New</option><option value="Verdana, sans-serif">Verdana</option><option value="Times New Roman, serif">Times New Roman</option></select></label>
                </div>
                <div id="link-controls" class="control-group hidden">
                    <h5>Embed Link</h5>
                    <label><span>URL</span><input type="text" id="link-src"></label>
                </div>
                <div id="arrow-controls" class="control-group hidden">
                    <h5>Arrow</h5>
                    <label><span>Color</span><div class="color-picker-wrapper" id="arrow-color"></div></label><label><span>Width (px)</span><input type="range" id="arrow-width" min="1" max="10" step="1"></label><label><span>Head Size</span><input type="range" id="arrow-head-size" min="5" max="25" step="1" value="10"></label>
                </div>
                <div id="grid-controls" class="control-group"><h5>Grid</h5><label><span>Background</span><div class="color-picker-wrapper" id="grid-bg-color"></div></label><label><span>Line Color</span><div class="color-picker-wrapper" id="grid-line-color"></div></label></div>
            </div>
        </div>
    </div>

    <div id="context-menu">
        <ul>
            <li data-action="add-text">Add Text Block</li>
            <li data-action="add-image">Insert Image/Video File</li>
            <li data-action="add-link">Insert Video from Link</li>
            <li data-action="add-desmos">Insert Desmos from Link</li>
            <li data-action="add-doc-file">Insert Document File (.docx)</li>
            <li data-action="add-doc-link">Insert Google Doc/PDF Link</li>
            <li data-action="import-presentation">Import Presentation (PDF/PPTX)</li>
        </ul>
    </div>
    
    <input type="file" id="file-loader" accept=".json" style="display: none;">

<script src="https://unpkg.com/mammoth@1.5.1/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

    document.addEventListener('DOMContentLoaded', function() {
        const container = document.getElementById('container');
        const grid = document.getElementById('grid');
        const svgCanvas = document.getElementById('arrow-svg');
        const svgDefs = svgCanvas.querySelector('defs');
        const coordsDisplay = document.getElementById('coordinates');
        const addContentBtn = document.getElementById('add-content-btn');
        const toggleArrowModeBtn = document.getElementById('toggle-arrow-mode-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileLoader = document.getElementById('file-loader');
        const shortcutHint = document.getElementById('shortcut-hint');
        const contextMenu = document.getElementById('context-menu');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const addPageBtn = document.getElementById('add-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const pageDisplay = document.getElementById('page-display');
        const sidebar = document.querySelector('.sidebar');
    
        let isDragging = false, isPanning = false, isEditing = false, isArrowMode = false, isDrawingArrow = false;
        let isResizing = false;
        let isMarqueeSelecting = false;
        let resizeDirection = '';
        let resizeInitialRect = null; 
        let currentBlock = null, arrowStartBlock = null;
        let selection = []; 
        let lastSelectedItem = null; 
        let startX, startY, mouseMoved = false, lastMouseX = 0, lastMouseY = 0;
        let dragInitialPositions = [];
        let contextMenuX, contextMenuY;
        let gridX = 0, gridY = 0, blockCounter = 1;
        let scale = 1;
        let tempArrow = null;
        let ctrlPressed = false;
        let lastBlockCreationAction = () => addNewBlock('html', 'New block.');
        let savedSelectionRange = null; 
        let activeEditingElement = null; 
        let marqueeBox = null, marqueeStartX = 0, marqueeStartY = 0;
        
        let pages = [];
        let currentPageIndex = 0;

        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY_STATES = 32;
        let activePicker = null;
        let currentlyVisiblePicker = null;

        shortcutHint.style.display = 'block';
        setTimeout(() => {
            shortcutHint.style.display = 'none';
        }, 30000);

        function initialize() {
            populateFontSizeSelector();
            const initialPage = {
                blocks: [
                    { x: 540, y: 300, htmlContent: "MentMap: Faça seus materiais para apresentação e mapas mentais.", id: 'block-0' },
                    { x: 1140, y: 300, htmlContent: "É extremamente fácil fazê-los", id: 'block-1' }
                ],
                arrows: [],
                viewport: { gridX: 0, gridY: 0, scale: 1 },
                styles: { 
                    gridBg: '#000000',
                    gridLines: 'linear-gradient(rgba(255, 255, 255, 0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.2) 1px, transparent 1px)'
                }
            };
            blockCounter = 2;
            pages = [initialPage];
            currentPageIndex = 0;
            loadPage(0, true);
            initializeColorPickers();
            recordState(); 
        }
        
        function populateFontSizeSelector() {
            const fontSizes = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 30, 36, 48, 64, 72];
            const sizeSelect = document.getElementById('text-size');
            sizeSelect.innerHTML = '';
            fontSizes.forEach(size => {
                const option = document.createElement('option');
                option.value = size;
                option.textContent = size;
                sizeSelect.appendChild(option);
            });
        }

        // --- Main Event Listeners ---
        addContentBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            contextMenuX = null;
            contextMenuY = null;
            const rect = addContentBtn.getBoundingClientRect();
            contextMenu.style.left = `${rect.left - contextMenu.offsetWidth}px`;
            contextMenu.style.top = `${rect.top}px`;
            contextMenu.style.display = 'block';
        });
        toggleArrowModeBtn.addEventListener('click', toggleArrowMode);
        saveBtn.addEventListener('click', saveAllPages);
        loadBtn.addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', (e) => { loadAllPages(e); });
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('keydown', handleKeyDown, true);
        document.addEventListener('keyup', handleKeyUp);
        document.addEventListener('mousedown', handleGlobalMouseDown, true);
        container.addEventListener('mousedown', handleGridMouseDown);
        container.addEventListener('contextmenu', handleGridContextMenu);
        container.addEventListener('wheel', handleZoom, { passive: false });
        container.addEventListener('mousemove', (e) => {
            if (!isDragging && !isResizing && !isPanning) {
                updateCoordinates(e);
            }
        });
        document.addEventListener('click', () => contextMenu.style.display = 'none');
        contextMenu.addEventListener('click', handleContextMenuClick);
        svgCanvas.addEventListener('click', handleArrowClick);
        coordsDisplay.addEventListener('click', editCoordinates);

        prevPageBtn.addEventListener('click', goToPrevPage);
        nextPageBtn.addEventListener('click', goToNextPage);
        addPageBtn.addEventListener('click', addNewPage);
        deletePageBtn.addEventListener('click', deleteCurrentPage);


        document.addEventListener('selectionchange', () => {
            if (isEditing && activeEditingElement) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    if (activeEditingElement.contains(range.commonAncestorContainer)) {
                        savedSelectionRange = range.cloneRange();
                        updateTextControlsOnSelectionChange();
                    }
                }
            }
        });
        
        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        function screenToGridCoords(screenX, screenY) {
            const gridRect = grid.getBoundingClientRect();
            return {
                x: (screenX - gridRect.left) / scale,
                y: (screenY - gridRect.top) / scale,
            };
        }
        
        function updateGridTransform() {
            grid.style.transform = `translate(${gridX}px, ${gridY}px) scale(${scale})`;
        }

        function updateSelection(item, shiftKey) {
            if (!shiftKey) {
                deselectAll();
            }
            const index = selection.indexOf(item);
            if (index > -1) {
                if (shiftKey) {
                    item.classList.remove('selected');
                    selection.splice(index, 1);
                    if (lastSelectedItem === item) {
                        lastSelectedItem = selection.length > 0 ? selection[selection.length - 1] : null;
                    }
                }
            } else {
                item.classList.add('selected');
                selection.push(item);
                lastSelectedItem = item;
            }
            updateUIState();
        }

        function deselectAll() {
            selection.forEach(item => item.classList.remove('selected'));
            selection = [];
            lastSelectedItem = null;
            updateUIState();
        }

        function updateUIState() {
            const selectedBlockIds = new Set(selection.filter(item => item.classList.contains('block')).map(block => block.id));
            if (selectedBlockIds.size >= 2) {
                svgCanvas.querySelectorAll('.arrow-group').forEach(arrow => {
                    const startId = arrow.dataset.startBlock;
                    const endId = arrow.dataset.endBlock;
                    if (selectedBlockIds.has(startId) && selectedBlockIds.has(endId)) {
                        if (!selection.includes(arrow)) {
                            selection.push(arrow);
                            arrow.classList.add('selected');
                        }
                    }
                });
            }
            updateCoordinates();
            updateCustomizePanel();
        }

        function createBlock(config) {
            const block = document.createElement('div');
            block.id = config.id || `block-${blockCounter++}`;
            block.className = 'block';
            block.style.left = `${config.x}px`;
            block.style.top = `${config.y}px`;
            block.style.width = config.width || '200px';
            if (config.height) { 
                block.style.height = config.height;
            }
            if (config.bgColor) block.style.backgroundColor = config.bgColor;
            if (config.borderColor) block.style.borderColor = config.borderColor;

            if (config.handleColor) block.style.setProperty('--handle-color', config.handleColor);
            if (config.handleDisplay) block.style.setProperty('--handle-display', config.handleDisplay);

            const contentEl = document.createElement('div');
            contentEl.className = 'block-content';
            contentEl.innerHTML = config.htmlContent || config.content || '';
            block.appendChild(contentEl);

            const handles = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `resize-handle handle-${handle}`;
                block.appendChild(handleEl);
            });
            
            grid.appendChild(block);

            block.addEventListener('mousedown', (e) => handleBlockMouseDown(e, block));
            block.addEventListener('dblclick', (e) => handleBlockDblClick(e, block));
            
            contentEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing(block);
                }
            });

            contentEl.addEventListener('keyup', updateTextControlsOnSelectionChange);
            contentEl.addEventListener('mouseup', updateTextControlsOnSelectionChange);
            
            new ResizeObserver(() => updateArrowsForBlock(block)).observe(block);
            return block;
        }

        function addNewBlock(contentType = 'html', contentData = 'New block.', options = {}) {
            let coords;
            if(contextMenuX && contextMenuY) {
                coords = screenToGridCoords(contextMenuX, contextMenuY);
            } else {
                coords = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);
            }

            let config = { x: coords.x, y: coords.y, htmlContent: contentData };
            Object.assign(config, options);

            const newBlock = createBlock(config);
            updateSelection(newBlock, false);
            
            const isEmbed = contentData.includes('<iframe') || contentData.includes('<video') || contentData.includes('<img');
            if (contentType === 'html' && !isEmbed) {
                startEditing(newBlock);
                const contentEl = newBlock.querySelector('.block-content');
                const range = document.createRange();
                range.selectNodeContents(contentEl);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            recordState();
        }

        function handleBlockDblClick(e, block) {
            if (e.target.closest('a, button, input, iframe, video')) {
                return;
            }
            startEditing(block, e);
        }

        function handleBlockMouseDown(e, block) {
            e.stopPropagation();
            startX = e.clientX;
            startY = e.clientY;
            mouseMoved = false;

            const contentEl = block.querySelector('.block-content');
            if (isEditing && contentEl.contains(e.target)) {
                return;
            }
            
            const handle = e.target.closest('.resize-handle');
            if (handle) {
                isResizing = true;
                resizeDirection = handle.className.match(/handle-([a-z]{1,2})/)[1];
                currentBlock = block;
                
                resizeInitialRect = {
                    width: block.offsetWidth,
                    height: block.offsetHeight,
                    left: block.offsetLeft,
                    top: block.offsetTop,
                };
                
                document.body.style.cursor = getComputedStyle(handle).cursor;
                return;
            }

            if (isArrowMode || ctrlPressed) {
                isDrawingArrow = true;
                arrowStartBlock = block;
                startArrow(e, block);
                return;
            }
            
            currentBlock = block;

            if (e.shiftKey) {
                updateSelection(block, true);
            } else if (!selection.includes(block)) {
                updateSelection(block, false);
            }
        }

        function handleMouseMove(e) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            if (!mouseMoved && (isDrawingArrow || currentBlock)) {
                const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                if (dist > 3) mouseMoved = true;
            }

            if (currentBlock && !isDragging && !isResizing && !isPanning && !isDrawingArrow && mouseMoved) {
                isDragging = true;
                document.body.style.cursor = 'grabbing';
                dragInitialPositions = selection.filter(item => item.classList.contains('block')).map(item => ({
                    el: item,
                    x: item.offsetLeft,
                    y: item.offsetTop
                }));
                dragInitialPositions.forEach(pos => {
                    pos.el.style.transition = 'none';
                    pos.el.classList.add('dragging');
                });
            }

            if (isResizing) resizeBlock(e);
            else if (isDragging) dragBlock(e);
            else if (isPanning) panGrid(e);
            else if (isDrawingArrow) drawArrow(e);
            else if (isMarqueeSelecting) updateMarquee(e);
        }

        function handleMouseUp(e) {
            const wasDraggingOrResizing = isDragging || isResizing;

            if (isDrawingArrow) endArrow(e);
            
            if (isDragging) {
                document.body.style.cursor = 'default';
                dragInitialPositions.forEach(pos => {
                    pos.el.style.transition = '';
                    pos.el.classList.remove('dragging');
                });
                dragInitialPositions = [];
            }

            if (isResizing) {
                document.body.style.cursor = 'default';
                resizeInitialRect = null;
            }
            if (isPanning) {
                document.body.style.cursor = 'default';
            }
            
            if (isMarqueeSelecting) {
                finalizeMarqueeSelection();
                isMarqueeSelecting = false;
                if(marqueeBox) marqueeBox.remove();
                marqueeBox = null;
            }

            isDragging = false;
            isResizing = false;
            isPanning = false;
            isDrawingArrow = false;
            arrowStartBlock = null;
            currentBlock = null;

            if(wasDraggingOrResizing) {
                recordState();
            }
        }

        function handleGlobalMouseDown(e) {
            if (activePicker) {
                const pickerApp = activePicker.getRoot().app;
                const isClickOnPickerButton = activePicker.getRoot().button.contains(e.target);
                
                if (!pickerApp.contains(e.target) && !isClickOnPickerButton) {
                    activePicker.hide();
                }
            }
            if (isEditing && activeEditingElement) {
                const currentBlock = activeEditingElement.closest('.block');
                if (!currentBlock.contains(e.target) && !e.target.closest('.sidebar') && !e.target.closest('.pcr-app')) {
                    finishEditing(currentBlock);
                }
            }
        }

        function handleGridMouseDown(e) {
            const isGridElement = e.target === grid || e.target === svgCanvas || e.target === container;
            if (isGridElement) {
                if (e.shiftKey || e.button === 1) {
                    isPanning = true;
                    document.body.style.cursor = 'grabbing';
                    e.preventDefault(); 
                } else if (e.button === 0) {
                    deselectAll();
                    isMarqueeSelecting = true;
                    marqueeBox = document.createElement('div');
                    marqueeBox.className = 'marquee-box';
                    document.body.appendChild(marqueeBox);
                    marqueeStartX = e.clientX;
                    marqueeStartY = e.clientY;
                    marqueeBox.style.left = `${e.clientX}px`;
                    marqueeBox.style.top = `${e.clientY}px`;
                }
            }
        }

        function handleGridContextMenu(e) {
            e.preventDefault();
            contextMenuX = e.clientX;
            contextMenuY = e.clientY;
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.style.display = 'block';
        }

        function handleContextMenuClick(e) {
            const action = e.target.dataset.action;
            if (!action) return;
            
            const actionMap = {
                'add-text': () => { 
                    lastBlockCreationAction = () => addNewBlock('html', 'New text block.');
                    lastBlockCreationAction();
                },
                'add-image': () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*,video/*';
                    lastBlockCreationAction = () => fileInput.click();
                    fileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = res => {
                                const dataUrl = res.target.result;
                                if (file.type.startsWith('image/')) {
                                    const img = new Image();
                                    img.onload = () => {
                                        const aspectRatio = img.height / img.width;
                                        const maxWidth = 800;
                                        const newWidth = Math.min(img.width, maxWidth);
                                        const newHeight = newWidth * aspectRatio;
                                        const html = `<img src="${dataUrl}" alt="User content">`;
                                        addNewBlock('html', html, { width: `${newWidth}px`, height: `${newHeight}px` });
                                    };
                                    img.src = dataUrl;
                                } else if (file.type.startsWith('video/')) {
                                    const video = document.createElement('video');
                                    video.onloadedmetadata = () => {
                                        const aspectRatio = video.videoHeight / video.videoWidth;
                                        const maxWidth = 800;
                                        const newWidth = Math.min(video.videoWidth, maxWidth);
                                        const newHeight = newWidth * aspectRatio;
                                        const html = `<video src="${dataUrl}" controls></video>`;
                                        addNewBlock('html', html, { width: `${newWidth}px`, height: `${newHeight}px` });
                                    };
                                    video.src = dataUrl;
                                }
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    lastBlockCreationAction();
                },
                'add-link': () => {
                    const createLinkBlock = () => {
                        const url = prompt('Enter YouTube, Vimeo, or Google Drive video URL:');
                        if (url) {
                            let embedUrl;
                            if (url.includes('youtube.com/watch?v=')) embedUrl = `https://www.youtube.com/embed/${new URL(url).searchParams.get('v')}`;
                            else if (url.includes('youtu.be/')) embedUrl = `https://www.youtube.com/embed/${new URL(url).pathname.slice(1)}`;
                            else if (url.includes('vimeo.com/')) embedUrl = `https://player.vimeo.com/video/${new URL(url).pathname.slice(1)}`;
                            else if (url.includes('drive.google.com/file/d/')) {
                                const match = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
                                if (match && match[1]) embedUrl = `https://drive.google.com/file/d/${match[1]}/preview`;
                            }
                            if (embedUrl) addNewBlock('html', `<iframe src="${embedUrl}" allow="autoplay; fullscreen"></iframe>`, { width: '560px', height: '315px' });
                            else showToast('Invalid or unsupported video URL.');
                        }
                    };
                    lastBlockCreationAction = createLinkBlock;
                    lastBlockCreationAction();
                },
                'add-desmos': () => {
                    const createDesmosBlock = () => {
                        const desmosUrl = prompt('Enter the Desmos graph URL:');
                        if (desmosUrl && desmosUrl.includes('desmos.com/calculator')) addNewBlock('html', `<iframe src="${desmosUrl}"></iframe>`, { width: '600px', height: '400px' });
                        else if (desmosUrl) showToast('Invalid Desmos URL.');
                    };
                    lastBlockCreationAction = createDesmosBlock;
                    lastBlockCreationAction();
                },
                'add-doc-file': () => {
                    const docFileInput = document.createElement('input');
                    docFileInput.type = 'file';
                    docFileInput.accept = '.docx';
                    lastBlockCreationAction = () => docFileInput.click();
                    docFileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file && window.mammoth) {
                            const reader = new FileReader();
                            reader.onload = res => {
                                mammoth.convertToHtml({ arrayBuffer: res.target.result })
                                    .then(result => {
                                        const docHtml = `<div style="padding: 20px; font-family: serif; line-height: 1.6; background: white; height: 100%; overflow-y: auto;">${result.value}</div>`;
                                        addNewBlock('html', docHtml, { width: '800px', height: '600px' });
                                    })
                                    .catch(err => {
                                        console.error("Error converting docx:", err);
                                        showToast("Could not convert the DOCX file.");
                                    });
                            };
                            reader.readAsArrayBuffer(file);
                        }
                    };
                    lastBlockCreationAction();
                },
                'add-doc-link': () => {
                    const createDocLinkBlock = () => {
                        const docUrl = prompt('Enter Google Doc or PDF share URL:');
                        if (docUrl) {
                            let embedUrl;
                            const match = docUrl.match(/docs\.google\.com\/document\/d\/([a-zA-Z0-9_-]+)/);
                            if (match && match[1]) {
                                embedUrl = `https://docs.google.com/document/d/${match[1]}/edit?embedded=true`;
                            } else if (docUrl.toLowerCase().endsWith('.pdf')) {
                                embedUrl = docUrl;
                            }

                            if (embedUrl) {
                                const iframeHtml = `<iframe src="${embedUrl}" style="width:100%; height:100%; border:none;"></iframe>`;
                                addNewBlock('html', iframeHtml, { width: '800px', height: '600px' });
                            } else {
                                showToast('Invalid Google Doc or PDF URL.');
                            }
                        }
                    };
                    lastBlockCreationAction = createDocLinkBlock;
                    lastBlockCreationAction();
                },
                'import-presentation': () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.pdf,.pptx';
                    fileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file) {
                            if (file.name.toLowerCase().endsWith('.pdf')) {
                                importPdf(file);
                            } else if (file.name.toLowerCase().endsWith('.pptx')) {
                                showToast('PPTX import is not yet implemented.', 3000);
                            }
                        }
                    };
                    fileInput.click();
                }
            };

            if(actionMap[action]) actionMap[action]();
            contextMenu.style.display = 'none';
        }
        
        function handleArrowClick(e) {
            const group = e.target.closest('.arrow-group');
            if (group) {
                e.stopPropagation();
                updateSelection(group, e.shiftKey);
            }
        }

        function handleKeyDown(e) {
            if (isEditing && e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
                return; 
            }
            if (isEditing) return;
            
            if (e.ctrlKey && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                redo();
            }

            if (e.key === 'ArrowRight' || e.key === 'PageDown') {
                e.preventDefault();
                goToNextPage();
            }
            if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                e.preventDefault();
                goToPrevPage();
            }

            if (e.key === 'Control') {
                ctrlPressed = true;
                if (!isArrowMode) {
                    document.body.classList.add('arrow-mode');
                }
            }
            if (e.key === 'Delete') {
                selection.forEach(item => {
                    if (item.classList.contains('block')) {
                        const blockId = item.id;
                        svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(a => {
                            const arrowLine = a.querySelector('.arrow-line');
                            if (arrowLine) {
                                const endMarkerUrl = arrowLine.getAttribute('marker-end');
                                if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();
                                const startMarkerUrl = arrowLine.getAttribute('marker-start');
                                if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();
                            }
                            a.remove();
                        });
                        item.remove();
                    } else if (item.classList.contains('arrow-group')) {
                        const arrowLine = item.querySelector('.arrow-line');
                        if (arrowLine) {
                            const endMarkerUrl = arrowLine.getAttribute('marker-end');
                            if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();
                            const startMarkerUrl = arrowLine.getAttribute('marker-start');
                            if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();
                        }
                        item.remove();
                    }
                });
                deselectAll();
                recordState();
            }
            if (e.key === 'b' || e.key === 'B') {
                e.preventDefault();
                showSmartColorPicker();
            }
            if(e.key === 'g' || e.key === 'G') {
                e.preventDefault();
                sidebar.classList.toggle('hidden');
            }
            if(e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                coordsDisplay.classList.toggle('hidden');
            }
            if (e.shiftKey && e.key === '+') {
                e.preventDefault();
                addNewPage();
            }
            if(e.shiftKey && e.key === '-') {
                e.preventDefault();
                deleteCurrentPage();
            }
            if (e.shiftKey && (e.key === 'd' || e.key === 'D')) {
                e.preventDefault();
                if (selection.length > 0) duplicateSelection();
                else lastBlockCreationAction();
            }
            if (e.shiftKey && (e.key === 'a' || e.key === 'A')) {
                e.preventDefault();
                contextMenuX = lastMouseX;
                contextMenuY = lastMouseY;
                contextMenu.style.left = `${lastMouseX}px`;
                contextMenu.style.top = `${lastMouseY}px`;
                contextMenu.style.display = 'block';
            }
            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); saveAllPages(); }
            if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) { e.preventDefault(); fileLoader.click(); }
            if (e.key === 'h' || e.key === 'H') { e.preventDefault(); shortcutHint.style.display = shortcutHint.style.display === 'none' ? 'block' : 'none'; }
        }

        function handleKeyUp(e) {
            if (e.key === 'Control') {
                ctrlPressed = false;
                if (!toggleArrowModeBtn.classList.contains('active')) {
                     document.body.classList.remove('arrow-mode');
                }
            }
        }

        function handleEditorBlur() {
            const selection = window.getSelection();
            if (isEditing && selection.rangeCount > 0 && activeEditingElement.contains(selection.getRangeAt(0).commonAncestorContainer)) {
                savedSelectionRange = selection.getRangeAt(0).cloneRange();
            }
        }
        
        function restoreEditorSelection() {
            if (!isEditing || !savedSelectionRange) return;
            activeEditingElement.focus();
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(savedSelectionRange);
        }
        
        function saveEditorSelection() {
            if (!isEditing) return;
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                 savedSelectionRange = selection.getRangeAt(0).cloneRange();
            }
        }

        function startEditing(block, e) {
            if (e && e.target.closest('a, button, input')) return;
            const contentEl = block.querySelector('.block-content');
            if (contentEl && !contentEl.querySelector('iframe')) {
                sidebar.classList.remove('hidden');
                isEditing = true;
                block.classList.add('is-editing');
                activeEditingElement = contentEl;
                contentEl.contentEditable = true;
                contentEl.focus();
                contentEl.addEventListener('blur', handleEditorBlur);
                updateCustomizePanel();
                updateTextControlsOnSelectionChange();
            }
        }

        function finishEditing(block) {
            const contentEl = block.querySelector('.block-content');
            if (contentEl && contentEl.isContentEditable) {
                isEditing = false;
                block.classList.remove('is-editing');
                contentEl.removeEventListener('blur', handleEditorBlur);
                activeEditingElement = null;
                savedSelectionRange = null;
                contentEl.contentEditable = false;
                updateArrowsForBlock(block);
                recordState();
            }
        }
        
        function resizeBlock(e) {
            if (!isResizing || !currentBlock || !resizeInitialRect) return;

            const dx = (e.clientX - startX) / scale;
            const dy = (e.clientY - startY) / scale;
            
            let newWidth = resizeInitialRect.width;
            let newHeight = resizeInitialRect.height;
            let newLeft = resizeInitialRect.left;
            let newTop = resizeInitialRect.top;

            if (resizeDirection.includes('e')) newWidth = resizeInitialRect.width + dx;
            if (resizeDirection.includes('w')) {
                newWidth = resizeInitialRect.width - dx;
                newLeft = resizeInitialRect.left + dx;
            }
            if (resizeDirection.includes('s')) newHeight = resizeInitialRect.height + dy;
            if (resizeDirection.includes('n')) {
                newHeight = resizeInitialRect.height - dy;
                newTop = resizeInitialRect.top + dy;
            }

            const minSize = 50;
            if (newWidth >= minSize) {
                currentBlock.style.width = `${newWidth}px`;
                currentBlock.style.left = `${newLeft}px`;
            }
            if (newHeight >= minSize) {
                currentBlock.style.height = `${newHeight}px`;
                currentBlock.style.top = `${newTop}px`;
            }
            
            updateArrowsForBlock(currentBlock);
        }

        function dragBlock(e) {
            const dx = (e.clientX - startX) / scale;
            const dy = (e.clientY - startY) / scale;
            const gridSize = 30;

            dragInitialPositions.forEach(pos => {
                const newX = pos.x + dx;
                const newY = pos.y + dy;
                pos.el.style.left = `${Math.max(0, Math.round(newX / gridSize) * gridSize)}px`;
                pos.el.style.top = `${Math.max(0, Math.round(newY / gridSize) * gridSize)}px`;
                updateArrowsForBlock(pos.el);
            });
            
            const expansionBuffer = 100;
            const expansionAmount = 500;
            let maxRight = 0;
            let maxBottom = 0;
            
            selection.forEach(item => {
                if(item.classList.contains('block')) {
                    const rect = item.getBoundingClientRect();
                    if(rect.right > maxRight) maxRight = rect.right;
                    if(rect.bottom > maxBottom) maxBottom = rect.bottom;
                }
            });

            if (maxRight > window.innerWidth - expansionBuffer) grid.style.width = `${grid.offsetWidth + expansionAmount}px`;
            if (maxBottom > window.innerHeight - expansionBuffer) grid.style.height = `${grid.offsetHeight + expansionAmount}px`;

            updateCoordinates();
        }
        
        function panGrid(e) {
            gridX = Math.min(0, gridX + e.movementX);
            gridY = Math.min(0, gridY + e.movementY);
            updateGridTransform();
        }

        function handleZoom(e) {
            e.preventDefault();
            const scaleAmount = 0.05;
            let mousePoint = screenToGridCoords(e.clientX, e.clientY);
            
            if (gridX === 0) mousePoint.x = 0;
            if (gridY === 0) mousePoint.y = 0;
            
            const oldScale = scale;
            if (e.deltaY < 0) scale += scaleAmount;
            else scale -= scaleAmount;
            
            scale = Math.max(0.1, Math.min(scale, 3));

            gridX += mousePoint.x * (oldScale - scale);
            gridY += mousePoint.y * (oldScale - scale);
            
            gridX = Math.min(0, gridX);
            gridY = Math.min(0, gridY);

            updateGridTransform();
            updateCoordinates(e);
        }

        function toggleArrowMode() {
            isArrowMode = !isArrowMode;
            document.body.classList.toggle('arrow-mode', isArrowMode);
            toggleArrowModeBtn.classList.toggle('active', isArrowMode);
        }

        function startArrow(e, block) {
            const startPoint = getBlockCenter(block);
            const tempGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempArrow.setAttribute('x1', startPoint.x); 
            tempArrow.setAttribute('y1', startPoint.y);
            tempArrow.setAttribute('x2', startPoint.x); 
            tempArrow.setAttribute('y2', startPoint.y);
            tempArrow.setAttribute('stroke', '#3498db'); 
            tempArrow.setAttribute('stroke-width', '3');

            const marker = createOrUpdateMarker('temp-arrowhead', '#3498db', 10);
            marker.setAttribute('orient', 'auto');
            tempArrow.setAttribute('marker-end', 'url(#temp-arrowhead)');

            tempGroup.appendChild(tempArrow);
            svgCanvas.appendChild(tempGroup);
        }

        function drawArrow(e) {
            if (!tempArrow) return;
            const coords = screenToGridCoords(e.clientX, e.clientY);
            tempArrow.setAttribute('x2', coords.x);
            tempArrow.setAttribute('y2', coords.y);
        }

        function endArrow(e) {
            const tempGroup = tempArrow.parentElement;
            if (!mouseMoved) {
                tempGroup?.remove();
                document.getElementById('temp-arrowhead')?.remove();
                tempArrow = null;
                return;
            }

            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const endBlock = elementUnderCursor ? elementUnderCursor.closest('.block') : null;

            const reverseArrow = endBlock ? svgCanvas.querySelector(`.arrow-group[data-start-block="${endBlock.id}"][data-end-block="${arrowStartBlock.id}"]`) : null;

            if (reverseArrow) {
                const reverseLine = reverseArrow.querySelector('.arrow-line');
                const color = reverseLine.getAttribute('stroke');
                const headSize = parseFloat(reverseArrow.dataset.headSize) || 10;
                
                const startMarkerId = `arrowhead-start-${endBlock.id}-${arrowStartBlock.id}`;
                const marker = createOrUpdateMarker(startMarkerId, color, headSize);
                marker.setAttribute('orient', 'auto-start-reverse');
                
                reverseLine.setAttribute('marker-start', `url(#${startMarkerId})`);
                reverseArrow.dataset.bidirectional = 'true';
                
                tempGroup?.remove();
                recordState();

            } else if (endBlock && endBlock !== arrowStartBlock) {
                const arrowExists = svgCanvas.querySelector(`.arrow-group[data-start-block="${arrowStartBlock.id}"][data-end-block="${endBlock.id}"]`);
                if (arrowExists) {
                    tempGroup?.remove();
                } else {
                    const arrowLine = tempArrow;
                    const color = arrowLine.getAttribute('stroke');
                    const headSize = 10;
                    
                    const markerId = `arrowhead-end-${arrowStartBlock.id}-${endBlock.id}`;
                    const marker = createOrUpdateMarker(markerId, color, headSize);
                    marker.setAttribute('orient', 'auto');
                    arrowLine.setAttribute('marker-end', `url(#${markerId})`);

                    tempGroup.classList.add('arrow-group');
                    tempGroup.dataset.startBlock = arrowStartBlock.id;
                    tempGroup.dataset.endBlock = endBlock.id;
                    tempGroup.dataset.headSize = headSize;
                    
                    arrowLine.classList.add('arrow-line');
                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hitbox.classList.add('arrow-hitbox');
                    tempGroup.appendChild(hitbox);
                    updateSingleArrow(tempGroup);
                    if (selection.includes(arrowStartBlock) && selection.includes(endBlock)) {
                        updateSelection(tempGroup, true);
                    }
                    recordState();
                }
            } else { 
                tempGroup?.remove(); 
            }
            
            document.getElementById('temp-arrowhead')?.remove();
            tempArrow = null;
        }
        
        function updateMarquee(e) {
            if (!marqueeBox) return;
            const x = Math.min(e.clientX, marqueeStartX);
            const y = Math.min(e.clientY, marqueeStartY);
            const width = Math.abs(e.clientX - marqueeStartX);
            const height = Math.abs(e.clientY - marqueeStartY);
            marqueeBox.style.left = `${x}px`;
            marqueeBox.style.top = `${y}px`;
            marqueeBox.style.width = `${width}px`;
            marqueeBox.style.height = `${height}px`;

            const marqueeRect = marqueeBox.getBoundingClientRect();
            document.querySelectorAll('.block').forEach(block => {
                const blockRect = block.getBoundingClientRect();
                const isIntersecting = !(marqueeRect.right < blockRect.left ||
                                        marqueeRect.left > blockRect.right ||
                                        marqueeRect.bottom < blockRect.top ||
                                        marqueeRect.top > blockRect.bottom);
                block.classList.toggle('pre-selected', isIntersecting);
            });
        }

        function finalizeMarqueeSelection() {
            deselectAll();
            const newlySelected = [];
            document.querySelectorAll('.block.pre-selected').forEach(block => {
                block.classList.remove('pre-selected');
                block.classList.add('selected');
                newlySelected.push(block);
            });
            selection = newlySelected;
            if (selection.length > 0) {
                lastSelectedItem = selection[selection.length - 1];
            }
            updateUIState();
        }

        function createOrUpdateMarker(id, color, size = 10) {
            let marker = document.getElementById(id);
            if (!marker) {
                marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', id);
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                marker.appendChild(polygon);
                svgDefs.appendChild(marker);
            }
            const width = Number(size);
            const height = width * 0.7;
            
            marker.setAttribute('markerWidth', width);
            marker.setAttribute('markerHeight', height);
            marker.setAttribute('refX', width * 0.9);
            marker.setAttribute('refY', height / 2);
            
            const polygon = marker.querySelector('polygon');
            polygon.setAttribute('points', `0 0, ${width} ${height / 2}, 0 ${height}`);
            polygon.setAttribute('fill', color);
            return marker;
        }

        function updateSingleArrow(arrowGroup) {
            const startBlock = document.getElementById(arrowGroup.dataset.startBlock);
            const endBlock = document.getElementById(arrowGroup.dataset.endBlock);
            if (!startBlock || !endBlock) return;
            const arrowLine = arrowGroup.querySelector('.arrow-line');
            const hitbox = arrowGroup.querySelector('.arrow-hitbox');
            if (!arrowLine || !hitbox) return;
            
            const startPoint = getClosestConnectionPoint(startBlock, endBlock);
            const endPoint = getClosestConnectionPoint(endBlock, startBlock);

            [arrowLine, hitbox].forEach(el => {
                el.setAttribute('x1', startPoint.x); 
                el.setAttribute('y1', startPoint.y);
                el.setAttribute('x2', endPoint.x); 
                el.setAttribute('y2', endPoint.y);
            });
            
            const color = arrowLine.getAttribute('stroke') || '#3498db';
            const headSize = arrowGroup.dataset.headSize || 10;
            
            const endMarkerUrl = arrowLine.getAttribute('marker-end');
            if (endMarkerUrl) {
                createOrUpdateMarker(endMarkerUrl.slice(5, -1), color, headSize);
            }
            const startMarkerUrl = arrowLine.getAttribute('marker-start');
            if (startMarkerUrl) {
                createOrUpdateMarker(startMarkerUrl.slice(5, -1), color, headSize);
            }
        }

        function updateArrowsForBlock(block) {
            const blockId = block.id;
            svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(updateSingleArrow);
        }

        function updateCoordinates(e = null) {
            if (selection.length > 1) {
                coordsDisplay.innerHTML = `${selection.length} items selected | Z: ${Math.round(scale * 100)}%`;
            } else if (selection.length === 1) {
                const item = selection[0];
                if (item.classList.contains('block')) {
                    const x = parseInt(item.style.left);
                    const y = parseInt(item.style.top);
                    coordsDisplay.innerHTML = `X: ${x}, Y: ${y} | Z: ${Math.round(scale * 100)}%`;
                } else if (item.classList.contains('arrow-group')) {
                    coordsDisplay.innerHTML = `Arrow selected | Z: ${Math.round(scale * 100)}%`;
                }
            } else if (e) {
                const mouseCoords = screenToGridCoords(e.clientX, e.clientY);
                coordsDisplay.innerHTML = `X: ${Math.round(mouseCoords.x)}, Y: ${Math.round(mouseCoords.y)} | Z: ${Math.round(scale * 100)}%`;
            } else {
                coordsDisplay.innerHTML = `Nothing selected | Z: ${Math.round(scale * 100)}%`;
            }
        }
        
        function editCoordinates(e) {
            if (e.target.tagName === 'INPUT') return;
            e.stopPropagation();
            const blockToEdit = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : null;
            if (!blockToEdit) return;
            const x = parseInt(blockToEdit.style.left); 
            const y = parseInt(blockToEdit.style.top);
            coordsDisplay.innerHTML = `X: <input type="number" value="${x}" id="coord-x"> Y: <input type="number" value="${y}" id="coord-y">`;
            const inputX = document.getElementById('coord-x'); 
            const inputY = document.getElementById('coord-y');
            inputX.focus(); 
            inputX.select();
            const applyAndClose = () => {
                const newX = parseInt(inputX.value || 0);
                const newY = parseInt(inputY.value || 0);
                const gridSize = 30;
                blockToEdit.style.left = `${Math.max(0, Math.round(newX / gridSize) * gridSize)}px`;
                blockToEdit.style.top = `${Math.max(0, Math.round(newY / gridSize) * gridSize)}px`;
                updateArrowsForBlock(blockToEdit); 
                updateCoordinates();
                document.removeEventListener('click', handleClickOutside, true);
                document.removeEventListener('keydown', handleInputKeyDown, true);
                recordState();
            };
            const handleInputKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    applyAndClose();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    updateCoordinates(); 
                    document.removeEventListener('click', handleClickOutside, true);
                    document.removeEventListener('keydown', handleInputKeyDown, true);
                }
            };
            const handleClickOutside = (e) => {
                if (!coordsDisplay.contains(e.target)) {
                    applyAndClose();
                }
            };
            setTimeout(() => {
                document.addEventListener('click', handleClickOutside, true);
                document.addEventListener('keydown', handleInputKeyDown, true);
            }, 0);
        }

        let customizeInputs = {}; 
        const nonColorInputs = {
            handleVisible: document.getElementById('handle-visible'),
            textSize: document.getElementById('text-size'),
            textFont: document.getElementById('text-font'),
            linkSrc: document.getElementById('link-src'),
            arrowWidth: document.getElementById('arrow-width'),
            arrowHeadSize: document.getElementById('arrow-head-size'),
            boldBtn: document.getElementById('bold-btn'),
            italicBtn: document.getElementById('italic-btn'),
            underlineBtn: document.getElementById('underline-btn'),
        };
        const controlGroups = {
            block: document.getElementById('block-controls'), 
            handle: document.getElementById('handle-controls'),
            text: document.getElementById('text-controls'), 
            link: document.getElementById('link-controls'),
            arrow: document.getElementById('arrow-controls'),
            grid: document.getElementById('grid-controls')
        }

        function updateCustomizePanel() {
            const hasBlock = selection.some(item => item.classList.contains('block'));
            const hasArrow = selection.some(item => item.classList.contains('arrow-group'));
            const lastSelectedBlock = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : selection.find(i => i.classList.contains('block'));
            const hasIframe = lastSelectedBlock?.querySelector('iframe');
            
            controlGroups.block.classList.toggle('hidden', !hasBlock);
            controlGroups.handle.classList.toggle('hidden', !hasBlock);
            controlGroups.arrow.classList.toggle('hidden', !hasArrow);
            controlGroups.grid.classList.toggle('hidden', hasBlock || hasArrow);
            
            controlGroups.text.classList.toggle('hidden', !hasBlock || hasIframe);
            controlGroups.link.classList.toggle('hidden', !hasIframe);

            if (hasBlock && lastSelectedBlock) {
                const computed = getComputedStyle(lastSelectedBlock);
                if (customizeInputs.blockBg) customizeInputs.blockBg.setColor(computed.backgroundColor, true); 
                if (customizeInputs.blockBorder) customizeInputs.blockBorder.setColor(computed.borderColor, true);
                
                const handleColor = computed.getPropertyValue('--handle-color').trim();
                if (customizeInputs.handle) customizeInputs.handle.setColor(handleColor || '#808080', true);
                nonColorInputs.handleVisible.checked = computed.getPropertyValue('--handle-display').trim() !== 'none';

                if (hasIframe) {
                    nonColorInputs.linkSrc.value = hasIframe.src;
                } else if (isEditing) {
                    updateTextControlsOnSelectionChange();
                }
            }
            if (hasArrow) {
                const arrowToSample = lastSelectedItem?.classList.contains('arrow-group') ? lastSelectedItem : selection.find(i => i.classList.contains('arrow-group'));
                if (arrowToSample) {
                    const arrowLine = arrowToSample.querySelector('.arrow-line');
                    if (customizeInputs.arrow) customizeInputs.arrow.setColor(arrowLine.getAttribute('stroke') || '#000000', true);
                    nonColorInputs.arrowWidth.value = arrowLine.getAttribute('stroke-width');
                    nonColorInputs.arrowHeadSize.value = arrowToSample.dataset.headSize || 10;
                }
            }
        }
        
        function formatText(command, value = null) {
            if (!isEditing) return;
            restoreEditorSelection();
            document.execCommand(command, false, value);
            saveEditorSelection();
            updateTextControlsOnSelectionChange();
        };

        function addFormattingButtonListener(element, command) {
            element.addEventListener('mousedown', (e) => {
                e.preventDefault(); 
                formatText(command);
                recordState();
            });
        };

        addFormattingButtonListener(nonColorInputs.boldBtn, 'bold');
        addFormattingButtonListener(nonColorInputs.italicBtn, 'italic');
        addFormattingButtonListener(nonColorInputs.underlineBtn, 'underline');
        
        nonColorInputs.textSize.addEventListener('change', e => {
            restoreEditorSelection();
            document.execCommand('fontSize', false, '1');
            const fontElements = activeEditingElement.getElementsByTagName('font');
            for (let i = 0, len = fontElements.length; i < len; ++i) {
                if (fontElements[i].size == "1") {
                    fontElements[i].removeAttribute("size");
                    fontElements[i].style.fontSize = e.target.value + "px";
                }
            }
            saveEditorSelection();
            recordState();
        });
        
        nonColorInputs.textFont.addEventListener('change', e => {
            formatText('fontName', e.target.value);
            recordState();
        });

        nonColorInputs.handleVisible.addEventListener('change', e => {
            const value = e.target.checked ? 'block' : 'none';
            selection.forEach(i => i.classList.contains('block') && i.style.setProperty('--handle-display', value));
            recordState();
        });
        
        nonColorInputs.linkSrc.addEventListener('change', recordState);

        const updateSelectedArrows = (property, value) => {
            selection.forEach(item => {
                if (item.classList.contains('arrow-group')) {
                    const arrowLine = item.querySelector('.arrow-line');
                    if (property === 'width') {
                        arrowLine.setAttribute('stroke-width', value);
                    } else if (property === 'headSize') {
                        item.dataset.headSize = value;
                    }
                    updateSingleArrow(item);
                }
            });
        };

        nonColorInputs.arrowWidth.addEventListener('input', e => updateSelectedArrows('width', e.target.value));
        nonColorInputs.arrowHeadSize.addEventListener('input', e => updateSelectedArrows('headSize', e.target.value));
        nonColorInputs.arrowWidth.addEventListener('change', recordState);
        nonColorInputs.arrowHeadSize.addEventListener('change', recordState);


        function updateTextControlsOnSelectionChange() {
            if (!isEditing || !activeEditingElement) return;

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            let parentEl = selection.getRangeAt(0).commonAncestorContainer;
            if (parentEl.nodeType !== 1) {
                parentEl = parentEl.parentNode;
            }
            
            const styles = window.getComputedStyle(parentEl);
            nonColorInputs.boldBtn.classList.toggle('active', styles.fontWeight === '700' || styles.fontWeight === 'bold');
            nonColorInputs.italicBtn.classList.toggle('active', styles.fontStyle === 'italic');
            nonColorInputs.underlineBtn.classList.toggle('active', styles.textDecorationLine.includes('underline'));
            
            const currentSize = Math.round(parseFloat(styles.fontSize));
            let closestOption = nonColorInputs.textSize.options[0];
             for(const option of nonColorInputs.textSize.options) {
                if (Math.abs(option.value - currentSize) <= Math.abs(closestOption.value - currentSize)) {
                    closestOption = option;
                }
            }
            nonColorInputs.textSize.value = closestOption.value;
            
            const fontOption = Array.from(nonColorInputs.textFont.options).find(opt => styles.fontFamily.includes(opt.value));
            nonColorInputs.textFont.value = fontOption ? fontOption.value : nonColorInputs.textFont.options[0].value;
            
            if (customizeInputs.text) {
                customizeInputs.text.setColor(styles.color, true);
            }
        }

        function initializeColorPickers() {
            if (customizeInputs.blockBg) {
                Object.values(customizeInputs).filter(p => p.setColor).forEach(p => p.destroy());
            }

            const defaultSwatches = [
                '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3',
                '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39',
                '#ffeb3b', '#ffc107', '#ff9800', '#795548', '#9e9e9e', '#607d8b'
            ];

            const pickerConfig = (el, defaultColor) => ({
                el, theme: 'classic', default: defaultColor,
                swatches: defaultSwatches,
                components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true, clear: true } }
            });

            const pickers = {
                blockBg: Pickr.create(pickerConfig('#block-bg-color', '#ffffff')),
                blockBorder: Pickr.create(pickerConfig('#block-border-color', '#000000')),
                handle: Pickr.create(pickerConfig('#handle-color', '#808080')),
                text: Pickr.create(pickerConfig('#text-color', '#333333')),
                arrow: Pickr.create(pickerConfig('#arrow-color', '#3498db')),
                gridBg: Pickr.create(pickerConfig('#grid-bg-color', '#000000')),
                gridLines: Pickr.create(pickerConfig('#grid-line-color', '#FFFFFF33'))
            };

            const manageSinglePickerVisibility = (p) => {
                p.on('show', instance => {
                    if (currentlyVisiblePicker && currentlyVisiblePicker !== instance) {
                        currentlyVisiblePicker.hide();
                    }
                    currentlyVisiblePicker = instance;
                    activePicker = instance;
                }).on('hide', instance => {
                    if (currentlyVisiblePicker === instance) {
                        currentlyVisiblePicker = null;
                    }
                    if(activePicker === instance) activePicker = null;
                });
            };
            
            const addPickerListeners = (p) => {
                 const handleEnterKey = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const saveBtn = p.getRoot().interaction.save;
                        saveBtn.click();
                    }
                };

                p.on('show', instance => { 
                    const inputs = instance.getRoot().interaction.result.parentElement.querySelectorAll('input');
                    inputs.forEach(input => input.addEventListener('keydown', handleEnterKey));
                }).on('hide', (instance) => { 
                    const inputs = instance.getRoot().interaction.result.parentElement.querySelectorAll('input');
                    inputs.forEach(input => input.removeEventListener('keydown', handleEnterKey));
                });
            };

            pickers.blockBg.on('save', (c, i) => { i.hide(); selection.forEach(item => item.classList.contains('block') && (item.style.backgroundColor = c.toRGBA().toString())); recordState(); });
            pickers.blockBorder.on('save', (c, i) => { i.hide(); selection.forEach(item => item.classList.contains('block') && (item.style.borderColor = c.toRGBA().toString())); recordState(); });
            pickers.handle.on('save', (c, i) => { i.hide(); selection.forEach(item => item.classList.contains('block') && item.style.setProperty('--handle-color', c.toRGBA().toString())); recordState(); });
            pickers.text.on('save', (c, i) => { i.hide(); formatText('foreColor', c.toRGBA().toString()); recordState(); });
            pickers.arrow.on('save', (c, i) => { i.hide(); selection.forEach(item => { if (item.classList.contains('arrow-group')) { item.querySelector('.arrow-line').setAttribute('stroke', c.toRGBA().toString()); updateSingleArrow(item); }}); recordState(); });
            pickers.gridBg.on('save', (c, i) => { i.hide(); document.body.style.background = c.toRGBA().toString(); recordState(); });
            pickers.gridLines.on('save', (c, i) => { i.hide(); grid.style.backgroundImage = `linear-gradient(${c.toRGBA().toString()} 1px, transparent 1px), linear-gradient(90deg, ${c.toRGBA().toString()} 1px, transparent 1px)`; recordState(); });
            
            Object.values(pickers).forEach(p => {
                manageSinglePickerVisibility(p);
                addPickerListeners(p);
            });
            customizeInputs = { ...customizeInputs, ...pickers };
            
            const textControlsToPreventBlur = [
                nonColorInputs.boldBtn, nonColorInputs.italicBtn, nonColorInputs.underlineBtn,
                customizeInputs.text.getRoot().button
            ];
            textControlsToPreventBlur.forEach(control => {
                control.addEventListener('mousedown', e => e.preventDefault());
            });
        }
        
        function showSmartColorPicker() {
            const tempEl = document.createElement('div');
            tempEl.style.position = 'fixed';
            const xPos = lastMouseX || (window.innerWidth - 300) / 2;
            const yPos = lastMouseY || window.innerHeight / 2;
            tempEl.style.left = `${xPos}px`;
            tempEl.style.top = `${yPos}px`;
            tempEl.style.width = '1px';
            tempEl.style.height = '1px';
            document.body.appendChild(tempEl);

            const picker = Pickr.create({
                el: tempEl, theme: 'classic',
                default: '#333',
                swatches: [
                    '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3',
                    '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39'
                ],
                position: 'bottom-middle',
                components: { preview: true, opacity: true, hue: true, interaction: { hex: true, rgba: true, input: true, save: true } }
            });

            let saveAction = () => {};
            let initialColor = '#ffffff';

            if (isEditing && activeEditingElement) {
                initialColor = window.getComputedStyle(activeEditingElement).color;
                saveAction = (c) => { formatText('foreColor', c.toRGBA().toString()); recordState(); };
            } else if (lastSelectedItem?.classList.contains('block')) {
                initialColor = window.getComputedStyle(lastSelectedItem).backgroundColor;
                saveAction = (c) => { selection.forEach(i => i.classList.contains('block') && (i.style.backgroundColor = c.toRGBA().toString())); recordState(); };
            } else if (lastSelectedItem?.classList.contains('arrow-group')) {
                initialColor = lastSelectedItem.querySelector('.arrow-line').getAttribute('stroke');
                saveAction = (c) => { selection.forEach(i => { if (i.classList.contains('arrow-group')) { i.querySelector('.arrow-line').setAttribute('stroke', c.toRGBA().toString()); updateSingleArrow(i); } }); recordState(); };
            } else {
                initialColor = window.getComputedStyle(document.body).backgroundColor;
                saveAction = (c) => { document.body.style.background = c.toRGBA().toString(); recordState(); };
            }
            
            picker.setColor(initialColor);

            const handleEnterKey = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    const saveBtn = picker.getRoot().interaction.save;
                    saveBtn.click();
                }
            };
            
            picker.on('show', instance => {
                if (currentlyVisiblePicker && currentlyVisiblePicker !== instance) {
                    currentlyVisiblePicker.hide();
                }
                currentlyVisiblePicker = instance;
                activePicker = instance;
                const inputs = instance.getRoot().interaction.result.parentElement.querySelectorAll('input');
                inputs.forEach(input => input.addEventListener('keydown', handleEnterKey));
                setTimeout(() => {
                    const pickerApp = instance.getRoot().app;
                    const pickerRect = pickerApp.getBoundingClientRect();
                    let newLeft = xPos;
                    let newTop = yPos + 15;
                    if (newLeft + pickerRect.width > window.innerWidth) newLeft = window.innerWidth - pickerRect.width - 5;
                    if (newTop + pickerRect.height > window.innerHeight) newTop = yPos - pickerRect.height - 15;
                    pickerApp.style.left = `${newLeft}px`;
                    pickerApp.style.top = `${newTop}px`;
                }, 0);
            });

            picker.on('save', (color, instance) => {
                saveAction(color);
                instance.hide();
            }).on('hide', (instance) => {
                if (currentlyVisiblePicker === instance) currentlyVisiblePicker = null;
                if(activePicker === instance) activePicker = null;
                const inputs = instance.getRoot().interaction.result.parentElement.querySelectorAll('input');
                inputs.forEach(input => input.removeEventListener('keydown', handleEnterKey));
                instance.destroyAndRemove();
            });

            picker.show();
        }

        function recordState() {
            saveCurrentPageState(); 
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const state = {
                pages: JSON.parse(JSON.stringify(pages)),
                currentPageIndex: currentPageIndex
            };
            history.push(state);
            if (history.length > MAX_HISTORY_STATES) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function loadState(state) {
            if (!state) return;
            pages = JSON.parse(JSON.stringify(state.pages));
            currentPageIndex = state.currentPageIndex;
            loadPage(currentPageIndex, true);
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        function saveCurrentPageState() {
            if (pages.length === 0 || currentPageIndex < 0) return;
            pages[currentPageIndex] = {
                blocks: Array.from(document.querySelectorAll('.block')).map(block => ({
                    id: block.id,
                    htmlContent: block.querySelector('.block-content').innerHTML,
                    x: parseInt(block.style.left),
                    y: parseInt(block.style.top),
                    width: block.style.width,
                    height: block.style.height,
                    bgColor: block.style.backgroundColor,
                    borderColor: block.style.borderColor,
                    handleColor: block.style.getPropertyValue('--handle-color'),
                    handleDisplay: block.style.getPropertyValue('--handle-display'),
                })),
                arrows: Array.from(svgCanvas.querySelectorAll('.arrow-group')).map(arrowGroup => {
                    const arrowLine = arrowGroup.querySelector('.arrow-line');
                    return {
                        startBlock: arrowGroup.dataset.startBlock,
                        endBlock: arrowGroup.dataset.endBlock,
                        color: arrowLine.getAttribute('stroke'),
                        width: arrowLine.getAttribute('stroke-width'),
                        headSize: arrowGroup.dataset.headSize,
                        bidirectional: arrowGroup.dataset.bidirectional === 'true',
                    };
                }),
                styles: {
                    gridBg: document.body.style.background,
                    gridLines: grid.style.backgroundImage,
                },
                viewport: { gridX, gridY, scale }
            };
        }

        function loadPage(index, isFirstLoad = false) {
            if (!isFirstLoad && currentPageIndex >= 0) {
                saveCurrentPageState();
            }
            if (index < 0 || index >= pages.length) return;

            currentPageIndex = index;
            const pageState = pages[currentPageIndex];
            applyPageState(pageState);
            updatePageUI();
        }

        function applyPageState(state) {
            document.querySelectorAll('.block').forEach(b => b.remove());
            svgCanvas.querySelectorAll('.arrow-group').forEach(ag => ag.remove());
            svgDefs.innerHTML = '';
            deselectAll();
            
            gridX = state.viewport?.gridX || 0;
            gridY = state.viewport?.gridY || 0;
            scale = state.viewport?.scale || 1;
            updateGridTransform();

            document.body.style.background = state.styles?.gridBg || '#000000';
            grid.style.backgroundImage = state.styles?.gridLines || `linear-gradient(rgba(255, 255, 255, 0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.2) 1px, transparent 1px)`;
            
            let maxId = 0;
            if (state.blocks && Array.isArray(state.blocks)) {
                state.blocks.forEach(b => {
                    if (b && b.id) {
                        const idNum = parseInt(b.id.split('-')[1]);
                        if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
                    }
                });
            }
            blockCounter = maxId + 1;

            if (state.blocks && Array.isArray(state.blocks)) {
                state.blocks.forEach(blockConfig => {
                    if(blockConfig) createBlock(blockConfig);
                });
            }
            if (state.arrows && Array.isArray(state.arrows)) {
                state.arrows.forEach(arrowData => {
                    if(arrowData) {
                        const startBlock = document.getElementById(arrowData.startBlock);
                        const endBlock = document.getElementById(arrowData.endBlock);
                        if (startBlock && endBlock) createArrow(arrowData);
                    }
                });
            }
        }
        
        function updatePageUI() {
            pageDisplay.textContent = `Page ${currentPageIndex + 1} / ${pages.length}`;
            prevPageBtn.disabled = currentPageIndex === 0;
            nextPageBtn.disabled = currentPageIndex >= pages.length - 1;
            deletePageBtn.disabled = pages.length <= 1;
        }

        function addNewPage() {
            saveCurrentPageState();
            const newPage = {
                blocks: [],
                arrows: [],
                viewport: { gridX: 0, gridY: 0, scale: 1 },
                styles: {
                    gridBg: document.body.style.background,
                    gridLines: grid.style.backgroundImage,
                }
            };
            pages.push(newPage);
            loadPage(pages.length - 1);
            recordState();
            showToast(`Page ${pages.length} added`);
        }

        function deleteCurrentPage() {
            if (pages.length <= 1) {
                showToast("Cannot delete the last page.");
                return;
            }
            const pageHasContent = pages[currentPageIndex] && pages[currentPageIndex].blocks.length > 0;
            let confirmed = true;
            if (pageHasContent) {
                confirmed = window.confirm("This slide has content. Are you sure you want to delete it?");
            }

            if (confirmed) {
                const deletedPageIndex = currentPageIndex + 1;
                pages.splice(currentPageIndex, 1);
                const newIndex = Math.min(currentPageIndex, pages.length - 1);
                loadPage(newIndex, true); 
                recordState();
                showToast(`Page ${deletedPageIndex} deleted`);
            }
        }
        
        function goToNextPage() {
            if (currentPageIndex < pages.length - 1) loadPage(currentPageIndex + 1);
        }
        function goToPrevPage() {
            if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
        }

        async function importPdf(file) {
            showToast(`Importing ${file.name}...`, 10000);
            const fileReader = new FileReader();

            fileReader.onload = async function() {
                try {
                    const typedarray = new Uint8Array(this.result);
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;

                    const wasEmpty = pages.length === 1 && pages[0].blocks.length === 0;
                    if (wasEmpty) {
                        pages.shift();
                    } else {
                        saveCurrentPageState();
                    }

                    const importStartIndex = pages.length;

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        
                        const availableWidth = container.clientWidth * 0.85;
                        const availableHeight = container.clientHeight * 0.85;
                        const unscaledViewport = page.getViewport({ scale: 1.0 });
                        const scaleX = availableWidth / unscaledViewport.width;
                        const scaleY = availableHeight / unscaledViewport.height;
                        const optimalScale = Math.min(scaleX, scaleY);
                        const viewport = page.getViewport({ scale: optimalScale });

                        const gridCenter = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);
                        const blockX = Math.max(0, gridCenter.x - viewport.width / 2);
                        const blockY = Math.max(0, gridCenter.y - viewport.height / 2);
                        
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;

                        const imageDataUrl = canvas.toDataURL();
                        const htmlContent = `<img src="${imageDataUrl}" style="width: 100%; height: auto; display: block;">`;

                        const newPage = {
                            blocks: [{
                                x: blockX,
                                y: blockY,
                                width: `${viewport.width}px`,
                                height: `${viewport.height}px`,
                                htmlContent: htmlContent,
                                id: `block-slide-${importStartIndex + i - 1}-${blockCounter++}`
                            }],
                            arrows: [],
                            viewport: { gridX: 0, gridY: 0, scale: 1 },
                            styles: {
                                gridBg: document.body.style.background,
                                gridLines: grid.style.backgroundImage,
                            }
                        };
                        pages.push(newPage);
                    }

                    loadPage(importStartIndex, true);
                    recordState();
                    showToast(`Successfully imported ${pdf.numPages} slides.`, 3000);
                } catch (error) {
                    console.error('Error importing PDF:', error);
                    showToast('Failed to import PDF. See console for details.', 3000);
                }
            };
            fileReader.readAsArrayBuffer(file);
        }

        function saveAllPages() {
            saveCurrentPageState();
            const state = {
                formatVersion: "2.0",
                pages: pages
            };
            download('mentmap-presentation.json', JSON.stringify(state, null, 2));
        }

        function loadAllPages(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (loadedData.pages && Array.isArray(loadedData.pages)) {
                        pages = loadedData.pages;
                    } else {
                        pages = [loadedData];
                    }
                    loadPage(0, true);
                    history = [];
                    historyIndex = -1;
                    recordState();
                } catch (err) {
                    console.error('Error parsing JSON:', err);
                    showToast('Failed to load file. It may be corrupted.');
                }
            };
            reader.readAsText(file);
            fileLoader.value = '';
        }

        function duplicateSelection() {
            const idMap = new Map();
            const newSelection = [];
            const offset = 30;
            const selectedBlocks = selection.filter(item => item.classList.contains('block'));
            const selectedArrows = selection.filter(item => item.classList.contains('arrow-group'));

            selectedBlocks.forEach(block => {
                const config = {
                    x: parseInt(block.style.left) + offset,
                    y: parseInt(block.style.top) + offset,
                    width: block.style.width,
                    height: block.style.height,
                    htmlContent: block.querySelector('.block-content').innerHTML,
                    bgColor: block.style.backgroundColor,
                    borderColor: block.style.borderColor,
                    handleColor: block.style.getPropertyValue('--handle-color'),
                    handleDisplay: block.style.getPropertyValue('--handle-display'),
                };
                const newBlock = createBlock(config);
                idMap.set(block.id, newBlock.id);
                newSelection.push(newBlock);
            });

            selectedArrows.forEach(arrow => {
                const startId = arrow.dataset.startBlock;
                const endId = arrow.dataset.endBlock;
                if (idMap.has(startId) && idMap.has(endId)) {
                    const arrowLine = arrow.querySelector('.arrow-line');
                    const newArrowData = {
                        startBlock: idMap.get(startId),
                        endBlock: idMap.get(endId),
                        color: arrowLine.getAttribute('stroke'),
                        width: arrowLine.getAttribute('stroke-width'),
                        headSize: arrow.dataset.headSize,
                        bidirectional: arrow.dataset.bidirectional === 'true',
                    };
                    const newArrowGroup = createArrow(newArrowData);
                    newSelection.push(newArrowGroup);
                }
            });

            deselectAll();
            newSelection.forEach(item => updateSelection(item, true));
            recordState();
        }

        function createArrow(arrowData) {
            const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            arrowGroup.classList.add('arrow-group');
            arrowGroup.dataset.startBlock = arrowData.startBlock;
            arrowGroup.dataset.endBlock = arrowData.endBlock;
            const headSize = arrowData.headSize || 10;
            arrowGroup.dataset.headSize = headSize;
            
            const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            arrowLine.classList.add('arrow-line');
            arrowLine.setAttribute('stroke', arrowData.color);
            arrowLine.setAttribute('stroke-width', arrowData.width);

            const endMarkerId = `arrowhead-end-${arrowData.startBlock}-${arrowData.endBlock}`;
            let marker = createOrUpdateMarker(endMarkerId, arrowData.color, headSize);
            marker.setAttribute('orient', 'auto');
            arrowLine.setAttribute('marker-end', `url(#${endMarkerId})`);

            if (arrowData.bidirectional) {
                arrowGroup.dataset.bidirectional = 'true';
                const startMarkerId = `arrowhead-start-${arrowData.startBlock}-${arrowData.endBlock}`;
                marker = createOrUpdateMarker(startMarkerId, arrowData.color, headSize);
                marker.setAttribute('orient', 'auto-start-reverse');
                arrowLine.setAttribute('marker-start', `url(#${startMarkerId})`);
            }
            
            const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hitbox.classList.add('arrow-hitbox');
            arrowGroup.appendChild(arrowLine);
            arrowGroup.appendChild(hitbox);
            svgCanvas.appendChild(arrowGroup);
            updateSingleArrow(arrowGroup);
            return arrowGroup;
        }

        function rgbToHex(rgb) {
            if (!rgb || rgb === 'transparent') return '#ffffff';
            if (rgb.startsWith('#')) return rgb;
            const rgbArr = rgb.match(/\d+/g);
            if (!rgbArr) return '#000000';
            const hex = rgbArr.map(x => ('0' + parseInt(x).toString(16)).slice(-2)).join('');
            return `#${hex}`;
        }

        function getBlockCenter(block) {
            const x = parseInt(block.style.left);
            const y = parseInt(block.style.top);
            return { x: x + block.offsetWidth / 2, y: y + block.offsetHeight / 2 };
        }
        
        function getClosestConnectionPoint(from, to) {
            const fromRect = { x: parseInt(from.style.left), y: parseInt(from.style.top), width: from.offsetWidth, height: from.offsetHeight };
            const toRect = { x: parseInt(to.style.left), y: parseInt(to.style.top), width: to.offsetWidth, height: to.offsetHeight };
            const fromCx = fromRect.x + fromRect.width / 2;
            const fromCy = fromRect.y + fromRect.height / 2;
            const toCx = toRect.x + toRect.width / 2;
            const toCy = toRect.y + toRect.height / 2;
            const dx = toCx - fromCx;
            const dy = toCy - fromCy;
            if (dx === 0 && dy === 0) return {x: fromCx, y: fromCy};
            const angle = Math.atan2(dy, dx);
            const fromHalfWidth = fromRect.width / 2;
            const fromHalfHeight = fromRect.height / 2;
            const fromAngle = Math.atan2(fromHalfHeight, fromHalfWidth);
            let pointX, pointY;
            const absAngle = Math.abs(angle);
            if (absAngle > Math.PI - fromAngle || absAngle < fromAngle) {
                let tan = Math.tan(angle);
                pointX = dx > 0 ? fromCx + fromHalfWidth : fromCx - fromHalfWidth;
                pointY = fromCy + (pointX - fromCx) * tan;
            } else {
                let cot = 1 / Math.tan(angle);
                pointY = dy > 0 ? fromCy + fromHalfHeight : fromCy - fromHalfHeight;
                pointX = fromCx + (pointY - fromCy) * cot;
            }
            return { x: pointX, y: pointY };
        }
        
        function download(filename, text) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        initialize();
    });
</script>
</body>
</html>