<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Grid System with Save/Load</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            height: 100vh;
            width: 100vw;
            display: flex;
            color: #333;
            cursor: default;
            transition: background 0.5s;
        }
        
        body.arrow-mode .block {
            cursor: crosshair;
        }

        .container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .grid {
            position: absolute;
            width: 300vw; /* Start with a larger base size */
            height: 300vh;
            left: 0;
            top: 0;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            background-position: center center;
            transform-origin: top left; /* Changed for easier transform management */
            will-change: transform;
            transition: background-image 0.5s;
        }
        
        #arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        #arrow-svg .arrow-group {
            pointer-events: all;
            cursor: pointer;
        }

        #arrow-svg .arrow-hitbox {
            stroke: transparent;
            stroke-width: 15; /* Increased clickable area */
        }

        #arrow-svg .arrow-group.selected .arrow-line {
            stroke: #e74c3c !important; /* Use important to override inline styles */
            stroke-width: 5px;
        }

        .block {
            position: absolute;
            width: 200px;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid transparent;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 15px;
            cursor: grab;
            overflow: hidden;
            transition: border-color 0.3s, box-shadow 0.3s; /* Removed 'all' for performance */
            user-select: none;
            z-index: 10;
            resize: none; /* Disable default resize handle */
            display: flex; /* Use flexbox for content layout */
            flex-direction: column;
        }

        .block.selected {
            border-color: #3498db;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
        }

        .block-content {
            outline: none;
            padding: 5px;
            line-height: 1.4;
            width: 100%;
            min-height: 30px;
            overflow-wrap: break-word;
            transition: color 0.3s, font-size 0.3s;
            flex-grow: 1; /* Allow content to fill space */
            -webkit-user-select: text; /* Allow text selection */
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .block-content[contenteditable="true"] {
            border: 1px dashed #3498db;
            padding: 4px;
        }

        .block-content iframe,
        .block-content img,
        .block-content video {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 5px;
            /* pointer-events: none; REMOVED to allow interaction */
        }

        .coordinates {
            position: fixed; bottom: 90px; right: 20px;
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px;
            border-radius: 20px; font-size: 0.9rem; z-index: 1000; cursor: pointer;
        }
        .coordinates input {
            width: 60px; background: #333; color: white; border: 1px solid #555;
            border-radius: 5px; padding: 2px 5px; text-align: center;
        }

        .instructions {
            position: fixed; bottom: 90px; left: 20px;
            background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px;
            border-radius: 20px; font-size: 0.9rem; z-index: 1000; opacity: 0.8;
        }

        .control-panel {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9); padding: 10px 15px;
            border-radius: 50px; display: flex; gap: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2); z-index: 1000;
        }

        .control-btn {
            background: #2c5364; color: white; border: none; padding: 10px 18px;
            border-radius: 30px; cursor: pointer; font-weight: 600;
            transition: all 0.3s; display: flex; align-items: center; gap: 8px;
            font-size: 14px;
        }
        .control-btn.active { background: #e74c3c; }
        .control-btn:hover { background: #3498db; transform: translateY(-2px); }
        .btn-icon { font-size: 16px; }

        /* --- Customize Panel --- */
        #customize-panel {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 2000;
            font-size: 14px;
        }
        .panel-header {
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header h3 { font-weight: 600; }
        .panel-close-btn {
            background: none; border: none; color: white; font-size: 20px;
            cursor: pointer; opacity: 0.7; transition: opacity 0.2s;
        }
        .panel-close-btn:hover { opacity: 1; }
        .panel-content { padding: 15px; }
        .control-group { margin-bottom: 15px; }
        .control-group h4 {
            font-size: 12px; text-transform: uppercase;
            color: #aaa; margin-bottom: 8px; border-bottom: 1px solid #555; padding-bottom: 5px;
        }
        .control-group label {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
        }
        .control-group input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 24px; height: 24px; background-color: transparent;
            border: none; cursor: pointer; padding: 0;
        }
        .control-group input[type="color"]::-webkit-color-swatch {
            border-radius: 50%; border: 1px solid #666;
        }
        .control-group input[type="range"], .control-group input[type="number"], .control-group select, .control-group input[type="text"] {
            width: 120px;
            background: #444; color: white; border: 1px solid #666; border-radius: 4px; padding: 3px;
        }
        .text-format-buttons {
            display: flex;
            gap: 10px;
        }
        .format-btn {
            flex: 1;
            background: #555;
            border: 1px solid #666;
            color: white;
            padding: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .format-btn:hover { background: #666; }
        .hidden { display: none !important; }
        
        /* Shortcut hint styling */
        .shortcut-hint {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0.9;
        }
        .shortcut-hint kbd {
            background: #555;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
        }

        /* --- Context Menu --- */
        #context-menu {
            display: none;
            position: fixed;
            z-index: 3000;
            background: rgba(50, 50, 50, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 5px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        }
        #context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #context-menu li {
            padding: 8px 15px;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
        }
        #context-menu li:hover {
            background: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="grid" id="grid">
            <svg id="arrow-svg">
                <defs></defs>
            </svg>
        </div>
    </div>

    <div class="coordinates" id="coordinates">Nothing selected</div>
    <div class="instructions" id="instructions">Hold Shift + Drag to pan</div>
    
    <div class="shortcut-hint" id="shortcut-hint" style="display: none;">
        Pressione <kbd>H</kbd> para mostrar/esconder os atalhos<br>Pressione <kbd>SHIFT D</kbd> para adicionar um bloco<br>Segure <kbd>Ctrl</kbd> e ligue dois blocos para adicionar uma seta<br>Pressione <kbd>B</kbd> para abrir/fechar o menu de customização<br>Pressione <kbd>Ctrl S</kbd> para salvar o mapa mental<br>Pressione <kbd>Ctrl L</kbd> para carregar um mapa mental/div>
    </div>

    <div class="control-panel">
        <button class="control-btn" id="add-content-btn"><span class="btn-icon">+</span><span>Adicionar conteúdo</span></button>
        <button class="control-btn" id="toggle-arrow-mode-btn"><span class="btn-icon">→</span><span>Seta</span></button>
        <button class="control-btn" id="toggle-customize-btn"><span class="btn-icon">🎨</span><span>Customizar</span></button>
        <button class="control-btn" id="save-btn"><span class="btn-icon">💾</span><span>Salvar</span></button>
        <button class="control-btn" id="load-btn"><span class="btn-icon">📂</span><span>Carregar</span></button>
    </div>

    <div id="context-menu">
        <ul>
            <li data-action="add-text">Add Text Block</li>
            <li data-action="add-image">Insert Image/Video File</li>
            <li data-action="add-link">Insert Video from Link</li>
            <li data-action="add-desmos">Insert Desmos from Link</li>
            <li data-action="add-doc-file">Insert Document File (.docx)</li>
            <li data-action="add-doc-link">Insert Google Doc/PDF Link</li>
        </ul>
    </div>

    <div id="customize-panel">
        <div class="panel-header"><h3>Customize</h3><button class="panel-close-btn">&times;</button></div>
        <div class="panel-content">
            <div id="block-controls" class="control-group hidden"><h4>Block</h4><label><span>Background</span><input type="color" id="block-bg-color"></label><label><span>Border</span><input type="color" id="block-border-color"></label></div>
            <div id="text-controls" class="control-group hidden">
                <h4>Text</h4>
                <div class="text-format-buttons">
                    <button id="bold-btn" class="format-btn"><b>B</b></button>
                    <button id="italic-btn" class="format-btn"><i>I</i></button>
                    <button id="underline-btn" class="format-btn"><u>U</u></button>
                </div>
                <label><span>Color</span><input type="color" id="text-color"></label><label><span>Size (px)</span><input type="number" id="text-size" min="8" max="48" step="1"></label><label><span>Font</span><select id="text-font"><option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">Default</option><option value="Arial, sans-serif">Arial</option><option value="Georgia, serif">Georgia</option><option value="Courier New, monospace">Courier New</option><option value="Verdana, sans-serif">Verdana</option><option value="Times New Roman, serif">Times New Roman</option></select></label>
            </div>
            <div id="link-controls" class="control-group hidden">
                <h4>Embed Link</h4>
                <label><span>URL</span><input type="text" id="link-src"></label>
            </div>
            <div id="arrow-controls" class="control-group hidden"><h4>Arrow</h4><label><span>Color</span><input type="color" id="arrow-color"></label><label><span>Width (px)</span><input type="range" id="arrow-width" min="1" max="10" step="1"></label></div>
            <div id="grid-controls" class="control-group"><h4>Grid</h4><label><span>Background</span><input type="color" id="grid-bg-color"></label><label><span>Line Color</span><input type="color" id="grid-line-color"></label></div>
        </div>
    </div>
    
    <input type="file" id="file-loader" accept=".json" style="display: none;">

    <script src="https://unpkg.com/mammoth@1.5.1/mammoth.browser.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- Element References ---
        const grid = document.getElementById('grid');
        const svgCanvas = document.getElementById('arrow-svg');
        const svgDefs = svgCanvas.querySelector('defs');
        const coordsDisplay = document.getElementById('coordinates');
        const instructions = document.getElementById('instructions');
        const addContentBtn = document.getElementById('add-content-btn');
        const toggleArrowModeBtn = document.getElementById('toggle-arrow-mode-btn');
        const toggleCustomizeBtn = document.getElementById('toggle-customize-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileLoader = document.getElementById('file-loader');
        const customizePanel = document.getElementById('customize-panel');
        const shortcutHint = document.getElementById('shortcut-hint');
        const contextMenu = document.getElementById('context-menu');
    
        // --- State Variables ---
        let isDragging = false, isPanning = false, isEditing = false, isArrowMode = false, isDrawingArrow = false;
        let isResizing = false;
        let resizeDirection = '';
        let currentBlock = null, arrowStartBlock = null;
        let selection = []; // Use an array for multi-selection
        let lastSelectedItem = null; // Track the last item clicked
        let startX, startY, mouseMoved = false; // Add mouseMoved flag
        let dragInitialPositions = []; // Store initial positions for multi-drag
        let potentialDeselectItem = null; // Defer deselection until mouseup
        let contextMenuX, contextMenuY;
        let gridX = 0, gridY = 0, blockCounter = 1;
        let tempArrow = null;
        let ctrlPressed = false;

        // Show shortcut hint briefly on load
        shortcutHint.style.display = 'block';
        setTimeout(() => {
            shortcutHint.style.display = 'none';
        }, 30000);

        // --- Initial Setup ---
        createBlock({ x: 539, y: 300, htmlContent: "MentMap: Faça seus materiais para apresentação e mapas mentais." });
        createBlock({ x: 1139, y: 300, htmlContent: "É extremamente fácil fazê-los" });
        grid.style.transform = `translate(${gridX}px, ${gridY}px)`; // Initial transform

        // --- Event Listeners ---
        addContentBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            contextMenuX = null;
            contextMenuY = null;
            const rect = addContentBtn.getBoundingClientRect();
            contextMenu.style.visibility = 'hidden';
            contextMenu.style.display = 'block';
            const menuHeight = contextMenu.offsetHeight;
            contextMenu.style.visibility = 'visible';
            contextMenu.style.left = `${rect.left}px`;
            contextMenu.style.top = `${rect.top - menuHeight - 10}px`;
        });
        toggleArrowModeBtn.addEventListener('click', toggleArrowMode);
        saveBtn.addEventListener('click', saveState);
        loadBtn.addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', loadState);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        grid.addEventListener('mousedown', handleGridMouseDown);
        grid.addEventListener('contextmenu', handleGridContextMenu);
        document.addEventListener('click', () => contextMenu.style.display = 'none');
        contextMenu.addEventListener('click', handleContextMenuClick);
        svgCanvas.addEventListener('click', handleArrowClick);
        coordsDisplay.addEventListener('click', editCoordinates);

        toggleCustomizeBtn.addEventListener('click', () => {
            if (customizePanel.style.display === 'block') {
                customizePanel.style.display = 'none';
            } else {
                customizePanel.style.display = 'block';
                updateCustomizePanel();
            }
        });

        // --- Selection Logic ---
        function updateSelection(item, shiftKey) {
            if (!shiftKey) {
                deselectAll();
            }
            const index = selection.indexOf(item);
            if (index > -1) {
                if (shiftKey) {
                    item.classList.remove('selected');
                    selection.splice(index, 1);
                    if (lastSelectedItem === item) {
                        lastSelectedItem = selection.length > 0 ? selection[selection.length - 1] : null;
                    }
                }
            } else {
                item.classList.add('selected');
                selection.push(item);
                lastSelectedItem = item;
            }
            updateUIState();
        }

        function deselectAll() {
            selection.forEach(item => item.classList.remove('selected'));
            selection = [];
            lastSelectedItem = null;
            updateUIState();
        }

        function updateUIState() {
            const selectedBlockIds = new Set(selection.filter(item => item.classList.contains('block')).map(block => block.id));
            if (selectedBlockIds.size >= 2) {
                svgCanvas.querySelectorAll('.arrow-group').forEach(arrow => {
                    const startId = arrow.dataset.startBlock;
                    const endId = arrow.dataset.endBlock;
                    if (selectedBlockIds.has(startId) && selectedBlockIds.has(endId)) {
                        if (!selection.includes(arrow)) {
                            selection.push(arrow);
                            arrow.classList.add('selected');
                        }
                    }
                });
            }
            updateCoordinates();
            updateCustomizePanel();
        }

        // --- Block & Arrow Management ---
        function createBlock(config) {
            const block = document.createElement('div');
            block.id = config.id || `block-${blockCounter++}`;
            block.className = 'block';
            block.style.left = `${config.x}px`;
            block.style.top = `${config.y}px`;
            block.style.width = config.width || '200px';
            block.style.height = config.height || '100px';
            if (config.bgColor) block.style.backgroundColor = config.bgColor;
            if (config.borderColor) block.style.borderColor = config.borderColor;
            
            const contentEl = document.createElement('div');
            contentEl.className = 'block-content';
            contentEl.innerHTML = config.htmlContent || config.content || '';
            
            block.appendChild(contentEl);
            grid.appendChild(block);

            block.addEventListener('mousedown', (e) => handleBlockMouseDown(e, block));
            block.addEventListener('mousemove', (e) => handleBlockMouseMove(e, block));
            block.addEventListener('mouseleave', () => {
                 if (!isResizing) document.body.style.cursor = 'default';
            });
            contentEl.addEventListener('dblclick', (e) => startEditing(block, e));
            contentEl.addEventListener('blur', (e) => {
                // Prevent blur from closing edit mode when interacting with customize panel
                if (!customizePanel.contains(e.relatedTarget)) {
                    finishEditing(block);
                }
            });
            
            new ResizeObserver(() => updateArrowsForBlock(block)).observe(block);
            return block;
        }

        function addNewBlock(contentType = 'text', contentData = 'New block.', options = {}) {
            const blocks = Array.from(document.querySelectorAll('.block'));
            let x, y;
            const offset = 25;
            const blockWidth = options.width ? parseInt(options.width) : 200;
            const blockHeight = options.height ? parseInt(options.height) : 100;

            const referenceBlock = (lastSelectedItem && lastSelectedItem.classList.contains('block')) ? lastSelectedItem : (blocks.length > 0 ? blocks[blocks.length - 1] : null);

            const placeInCenter = () => {
                const gridRect = grid.getBoundingClientRect();
                if (contextMenuX && contextMenuY) {
                    x = contextMenuX - gridRect.left;
                    y = contextMenuY - gridRect.top;
                } else {
                    x = Math.max(0, Math.round((window.innerWidth - blockWidth) / 2 - gridRect.left));
                    y = Math.max(0, Math.round((window.innerHeight - blockHeight) / 2 - gridRect.top));
                }
            };

            if (referenceBlock && !(contextMenuX && contextMenuY)) {
                x = parseInt(referenceBlock.style.left) + offset;
                y = parseInt(referenceBlock.style.top) + offset;
            } else {
                placeInCenter();
            }

            let config = { x, y };
            config.htmlContent = contentData;

            // Apply options overrides
            Object.assign(config, options);

            const newBlock = createBlock(config);
            updateSelection(newBlock, false);
        }

        // --- Event Handlers ---
        function handleBlockMouseDown(e, block) {
            const contentEl = block.querySelector('.block-content');
            // Prevent drag from starting if we are in edit mode
            if (isEditing && contentEl.contains(e.target)) {
                e.stopPropagation();
                return;
            }
            
            const resizeHandle = getResizeHandle(e, block);
            if (resizeHandle) {
                isResizing = true;
                resizeDirection = resizeHandle;
                currentBlock = block;
                startX = e.clientX;
                startY = e.clientY;
                document.body.style.cursor = `${resizeHandle}-resize`;
                e.stopPropagation();
                return;
            }

            if (isArrowMode || ctrlPressed) {
                startArrow(e, block);
            } else {
                if (e.shiftKey && selection.includes(block)) potentialDeselectItem = block;
                else if (!e.shiftKey && selection.includes(block) && selection.length > 1) potentialDeselectItem = block;
                else if (!selection.includes(block)) updateSelection(block, e.shiftKey);
                
                if (selection.includes(block)) {
                    startDragging(e, block);
                }
            }
        }

        function handleBlockMouseMove(e, block) {
            if (isResizing || isDragging) return;
            const handle = getResizeHandle(e, block);
            if (handle) {
                document.body.style.cursor = `${handle}-resize`;
            } else {
                block.style.cursor = 'grab';
                document.body.style.cursor = 'default';
            }
        }

        function handleMouseMove(e) {
            if (!isDragging && !isResizing && !isPanning && !isDrawingArrow) return;
            mouseMoved = true;
            if (isResizing) resizeBlock(e);
            else if (isDragging && currentBlock) {
                potentialDeselectItem = null;
                dragBlock(e);
            } else if (isPanning) panGrid(e);
            else if (isDrawingArrow) drawArrow(e);
        }

        function handleMouseUp(e) {
            if (potentialDeselectItem) {
                if (e.shiftKey) updateSelection(potentialDeselectItem, true); 
                else updateSelection(potentialDeselectItem, false);
                potentialDeselectItem = null;
            }
            if (isDrawingArrow) endArrow(e);
            if (isDragging) stopDragging();
            if (isResizing) {
                isResizing = false;
                currentBlock = null;
                document.body.style.cursor = 'default';
            }
            if (isPanning) {
                isPanning = false;
                document.body.style.cursor = 'default';
                instructions.textContent = "Hold Shift + Drag to pan";
            }
        }

        function handleGridMouseDown(e) {
            if (e.target === grid || e.target === svgCanvas) {
                if (e.shiftKey) {
                    isPanning = true;
                    instructions.textContent = "Panning...";
                    document.body.style.cursor = 'grabbing';
                } else {
                    deselectAll();
                }
            }
        }

        function handleGridContextMenu(e) {
            e.preventDefault();
            contextMenuX = e.clientX;
            contextMenuY = e.clientY;
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.style.display = 'block';
        }

        function handleContextMenuClick(e) {
            const action = e.target.dataset.action;
            if (!action) return;
            switch (action) {
                case 'add-text': addNewBlock('html', 'New block.'); break;
                case 'add-image':
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*,video/*';
                    fileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = res => {
                                let html;
                                if (file.type.startsWith('image/')) html = `<img src="${res.target.result}" alt="User content">`;
                                else if (file.type.startsWith('video/')) html = `<video src="${res.target.result}" controls></video>`;
                                addNewBlock('html', html);
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    fileInput.click();
                    break;
                case 'add-link':
                    const url = prompt('Enter YouTube, Vimeo, or Google Drive video URL:');
                    if (url) {
                        let embedUrl;
                        if (url.includes('youtube.com/watch?v=')) embedUrl = `https://www.youtube.com/embed/${new URL(url).searchParams.get('v')}`;
                        else if (url.includes('youtu.be/')) embedUrl = `https://www.youtube.com/embed/${new URL(url).pathname.slice(1)}`;
                        else if (url.includes('vimeo.com/')) embedUrl = `https://player.vimeo.com/video/${new URL(url).pathname.slice(1)}`;
                        else if (url.includes('drive.google.com/file/d/')) {
                            const match = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
                            if (match && match[1]) embedUrl = `https://drive.google.com/file/d/${match[1]}/preview`;
                        }
                        if (embedUrl) addNewBlock('html', `<iframe src="${embedUrl}" allow="autoplay; fullscreen"></iframe>`);
                        else alert('Invalid or unsupported video URL.');
                    }
                    break;
                case 'add-desmos':
                    const desmosUrl = prompt('Enter the Desmos graph URL:');
                    if (desmosUrl && desmosUrl.includes('desmos.com/calculator')) addNewBlock('html', `<iframe src="${desmosUrl}"></iframe>`);
                    else if (desmosUrl) alert('Invalid Desmos URL.');
                    break;
                case 'add-doc-file':
                    const docFileInput = document.createElement('input');
                    docFileInput.type = 'file';
                    docFileInput.accept = '.docx';
                    docFileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file && window.mammoth) {
                            const reader = new FileReader();
                            reader.onload = res => {
                                mammoth.convertToHtml({ arrayBuffer: res.target.result })
                                    .then(result => {
                                        const docHtml = `<div style="padding: 20px; font-family: serif; line-height: 1.6; background: white; height: 100%; overflow-y: auto;">${result.value}</div>`;
                                        addNewBlock('html', docHtml, { width: '800px', height: '600px' });
                                    })
                                    .catch(err => {
                                        console.error("Error converting docx:", err);
                                        alert("Could not convert the DOCX file.");
                                    });
                            };
                            reader.readAsArrayBuffer(file);
                        }
                    };
                    docFileInput.click();
                    break;
                case 'add-doc-link':
                    const docUrl = prompt('Enter Google Doc or PDF share URL:');
                    if (docUrl) {
                        let embedUrl;
                        const match = docUrl.match(/docs\.google\.com\/document\/d\/([a-zA-Z0-9_-]+)/);
                        if (match && match[1]) {
                            // Use the editable link for Google Docs
                            embedUrl = `https://docs.google.com/document/d/${match[1]}/edit?embedded=true`;
                        } else if (docUrl.toLowerCase().endsWith('.pdf')) {
                            embedUrl = docUrl;
                        }

                        if (embedUrl) {
                            const iframeHtml = `<iframe src="${embedUrl}" style="width:100%; height:100%; border:none;"></iframe>`;
                            addNewBlock('html', iframeHtml, { width: '800px', height: '600px' });
                        } else {
                            alert('Invalid Google Doc or PDF URL.');
                        }
                    }
                    break;
            }
            contextMenu.style.display = 'none';
        }
        
        function handleArrowClick(e) {
            const group = e.target.closest('.arrow-group');
            if (group) {
                e.stopPropagation();
                updateSelection(group, e.shiftKey);
            }
        }

        function handleKeyDown(e) {
            if (isEditing) return;
            if (e.key === 'Control') {
                ctrlPressed = true;
                if (!isArrowMode) {
                    isArrowMode = true;
                    document.body.classList.add('arrow-mode');
                    instructions.textContent = "Click & drag between blocks";
                    toggleArrowModeBtn.classList.add('active');
                }
            }
            if (e.key === 'Delete') {
                selection.forEach(item => {
                    if (item.classList.contains('block')) {
                        const blockId = item.id;
                        svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(a => {
                            const markerId = a.querySelector('.arrow-line')?.getAttribute('marker-end')?.slice(5, -1);
                            if (markerId) document.getElementById(markerId)?.remove();
                            a.remove();
                        });
                        item.remove();
                    } else if (item.classList.contains('arrow-group')) {
                        const markerId = item.querySelector('.arrow-line')?.getAttribute('marker-end')?.slice(5, -1);
                        if (markerId) document.getElementById(markerId)?.remove();
                        item.remove();
                    }
                });
                deselectAll();
            }
            if (e.key === 'b' || e.key === 'B') {
                e.preventDefault();
                customizePanel.style.display = customizePanel.style.display === 'block' ? 'none' : 'block';
                if (customizePanel.style.display === 'block') updateCustomizePanel();
            }
            if (e.shiftKey && (e.key === 'd' || e.key === 'D')) { e.preventDefault(); addNewBlock(); }
            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); saveState(); }
            if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) { e.preventDefault(); fileLoader.click(); }
            if (e.key === 'h' || e.key === 'H') { e.preventDefault(); shortcutHint.style.display = shortcutHint.style.display === 'none' ? 'block' : 'none'; }
        }

        function handleKeyUp(e) {
            if (e.key === 'Control') {
                ctrlPressed = false;
                if (isArrowMode) {
                    isArrowMode = false;
                    document.body.classList.remove('arrow-mode');
                    instructions.textContent = "Hold Shift + Drag to pan";
                    toggleArrowModeBtn.classList.remove('active');
                }
            }
        }

        // --- Text Editing (Rich Text) ---
        function startEditing(block, e) {
            // Do not start editing if the click is on an interactive element inside
            if (e.target.closest('a, button, input')) return;
            const contentEl = block.querySelector('.block-content');
            // Only make text/doc content editable, not iframes
            if (contentEl && !contentEl.querySelector('iframe')) {
                isEditing = true;
                contentEl.contentEditable = true;
                contentEl.focus();
            }
        }

        function finishEditing(block) {
            const contentEl = block.querySelector('.block-content');
            if (contentEl && contentEl.isContentEditable) {
                isEditing = false;
                contentEl.contentEditable = false;
                updateArrowsForBlock(block);
            }
        }

        // --- Dragging, Panning, and Arrow Drawing ---
        function getResizeHandle(e, block) {
            const rect = block.getBoundingClientRect();
            const margin = 10;
            const onTopEdge = e.clientY < rect.top + margin;
            const onBottomEdge = e.clientY > rect.bottom - margin;
            const onLeftEdge = e.clientX < rect.left + margin;
            const onRightEdge = e.clientX > rect.right - margin;

            if (onTopEdge && onLeftEdge) return 'nw';
            if (onTopEdge && onRightEdge) return 'ne';
            if (onBottomEdge && onLeftEdge) return 'sw';
            if (onBottomEdge && onRightEdge) return 'se';
            return ''; // No handle if not in a corner
        }

        function resizeBlock(e) {
            if (!isResizing || !currentBlock) return;
            const rect = currentBlock.getBoundingClientRect();
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            let newWidth = rect.width, newHeight = rect.height, newLeft = rect.left, newTop = rect.top;
            if (resizeDirection.includes('e')) newWidth += dx;
            if (resizeDirection.includes('w')) { newWidth -= dx; newLeft += dx; }
            if (resizeDirection.includes('s')) newHeight += dy;
            if (resizeDirection.includes('n')) { newHeight -= dy; newTop += dy; }
            const minSize = 50;
            if (newWidth > minSize) {
                currentBlock.style.width = `${newWidth}px`;
                currentBlock.style.left = `${newLeft - grid.getBoundingClientRect().left}px`;
            }
            if (newHeight > minSize) {
                currentBlock.style.height = `${newHeight}px`;
                currentBlock.style.top = `${newTop - grid.getBoundingClientRect().top}px`;
            }
            startX = e.clientX;
            startY = e.clientY;
            updateArrowsForBlock(currentBlock);
        }

        function startDragging(e, block) {
            currentBlock = block; 
            isDragging = true;
            document.body.style.cursor = 'grabbing';
            block.style.cursor = 'grabbing';
            startX = e.clientX; 
            startY = e.clientY;
            dragInitialPositions = selection.filter(item => item.classList.contains('block')).map(item => ({ el: item, x: item.offsetLeft, y: item.offsetTop }));
            dragInitialPositions.forEach(pos => pos.el.style.transition = 'none');
        }

        // --- Grid Expansion and Dragging Logic (REVISED) ---
        function dragBlock(e) {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            // --- Grid Expansion Logic ---
            const expansionBuffer = 100;
            const expansionAmount = 500;
            const mainDraggedBlock = currentBlock ? dragInitialPositions.find(p => p.el === currentBlock) : dragInitialPositions[0];

            if (mainDraggedBlock) {
                const gridRect = grid.getBoundingClientRect();
                const blockScreenX = mainDraggedBlock.x + dx + gridRect.left;
                const blockScreenY = mainDraggedBlock.y + dy + gridRect.top;
                
                // Expand right
                const blockScreenRight = blockScreenX + mainDraggedBlock.el.offsetWidth;
                if (blockScreenRight > window.innerWidth - expansionBuffer) {
                    grid.style.width = `${grid.offsetWidth + expansionAmount}px`;
                }
                // Expand bottom
                const blockScreenBottom = blockScreenY + mainDraggedBlock.el.offsetHeight;
                if (blockScreenBottom > window.innerHeight - expansionBuffer) {
                    grid.style.height = `${grid.offsetHeight + expansionAmount}px`;
                }
            }
            
            // --- Block Dragging Logic ---
            dragInitialPositions.forEach(pos => {
                const newX = pos.x + dx;
                const newY = pos.y + dy;
                pos.el.style.left = `${newX}px`;
                pos.el.style.top = `${newY}px`;
                updateArrowsForBlock(pos.el);
            });
            updateCoordinates(); 
        }

        function stopDragging() { 
            if (isDragging) {
                document.body.style.cursor = 'default';
                dragInitialPositions.forEach(pos => {
                    pos.el.style.transition = '';
                    pos.el.style.cursor = 'grab';
                });
            }
            isDragging = false; 
            currentBlock = null; 
            dragInitialPositions = [];
        }
        
        function panGrid(e) {
            gridX = Math.min(0, gridX + e.movementX);
            gridY = Math.min(0, gridY + e.movementY);
            grid.style.transform = `translate(${gridX}px, ${gridY}px)`;
        }

        function toggleArrowMode() {
            isArrowMode = !isArrowMode;
            ctrlPressed = isArrowMode;
            document.body.classList.toggle('arrow-mode', isArrowMode);
            toggleArrowModeBtn.classList.toggle('active', isArrowMode);
            instructions.textContent = isArrowMode ? "Click & drag between blocks" : "Hold Shift + Drag to pan";
        }

        function startArrow(e, block) {
            isDrawingArrow = true; 
            arrowStartBlock = block;
            mouseMoved = false;
            const startPoint = getBlockCenter(block);
            const tempGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempArrow.setAttribute('x1', startPoint.x); 
            tempArrow.setAttribute('y1', startPoint.y);
            tempArrow.setAttribute('x2', startPoint.x); 
            tempArrow.setAttribute('y2', startPoint.y);
            tempArrow.setAttribute('stroke', '#3498db'); 
            tempArrow.setAttribute('stroke-width', '3');

            createOrUpdateMarker('temp-arrowhead', '#3498db');
            tempArrow.setAttribute('marker-end', 'url(#temp-arrowhead)');

            tempGroup.appendChild(tempArrow);
            svgCanvas.appendChild(tempGroup);
        }

        function drawArrow(e) {
            if (!tempArrow) return;
            const gridRect = grid.getBoundingClientRect();
            tempArrow.setAttribute('x2', e.clientX - gridRect.left);
            tempArrow.setAttribute('y2', e.clientY - gridRect.top);
        }

        function endArrow(e) {
            const tempGroup = tempArrow.parentElement;
            if (!mouseMoved) {
                tempGroup.remove();
            } else {
                const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                const endBlock = elementUnderCursor ? elementUnderCursor.closest('.block') : null;
                if (endBlock && endBlock !== arrowStartBlock) {
                    const arrowExists = svgCanvas.querySelector(`.arrow-group[data-start-block="${arrowStartBlock.id}"][data-end-block="${endBlock.id}"]`);
                    if (arrowExists) {
                        tempGroup.remove();
                    } else {
                        const arrowLine = tempArrow;
                        const color = arrowLine.getAttribute('stroke');
                        const markerId = `arrowhead-${arrowStartBlock.id}-${endBlock.id}`;
                        createOrUpdateMarker(markerId, color);
                        arrowLine.setAttribute('marker-end', `url(#${markerId})`);

                        tempGroup.classList.add('arrow-group');
                        tempGroup.setAttribute('data-start-block', arrowStartBlock.id);
                        tempGroup.setAttribute('data-end-block', endBlock.id);
                        arrowLine.classList.add('arrow-line');
                        const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        hitbox.classList.add('arrow-hitbox');
                        tempGroup.appendChild(hitbox);
                        updateSingleArrow(tempGroup);
                        if (selection.includes(arrowStartBlock) && selection.includes(endBlock)) {
                            updateSelection(tempGroup, true);
                        }
                    }
                } else { 
                    tempGroup.remove(); 
                }
            }
            document.getElementById('temp-arrowhead')?.remove();
            isDrawingArrow = false; 
            arrowStartBlock = null; 
            tempArrow = null;
        }

        // --- Arrow and Coordinate Updates ---
        function createOrUpdateMarker(id, color) {
            let marker = document.getElementById(id);
            if (!marker) {
                marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', id);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '8');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                marker.appendChild(polygon);
                svgDefs.appendChild(marker);
            }
            marker.querySelector('polygon').setAttribute('fill', color);
        }

        function updateSingleArrow(arrowGroup) {
            const startBlock = document.getElementById(arrowGroup.dataset.startBlock);
            const endBlock = document.getElementById(arrowGroup.dataset.endBlock);
            if (!startBlock || !endBlock) return;
            const arrowLine = arrowGroup.querySelector('.arrow-line');
            const hitbox = arrowGroup.querySelector('.arrow-hitbox');
            if (!arrowLine || !hitbox) return;
            const startPoint = getClosestConnectionPoint(startBlock, endBlock);
            const endPoint = getClosestConnectionPoint(endBlock, startBlock);
            [arrowLine, hitbox].forEach(el => {
                el.setAttribute('x1', startPoint.x); 
                el.setAttribute('y1', startPoint.y);
                el.setAttribute('x2', endPoint.x); 
                el.setAttribute('y2', endPoint.y);
            });
            
            const color = arrowLine.getAttribute('stroke') || '#3498db';
            const markerId = arrowLine.getAttribute('marker-end')?.slice(5, -1);
            if (markerId) {
                const marker = document.getElementById(markerId);
                if (marker) marker.querySelector('polygon').setAttribute('fill', color);
            }
        }

        function updateArrowsForBlock(block) {
            const blockId = block.id;
            svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(updateSingleArrow);
        }

        function updateCoordinates() {
            if (selection.length > 1) {
                coordsDisplay.innerHTML = `${selection.length} items selected`;
            } else if (selection.length === 1) {
                const item = selection[0];
                if (item.classList.contains('block')) {
                    const x = parseInt(item.style.left);
                    const y = parseInt(item.style.top);
                    coordsDisplay.innerHTML = `X: ${x}, Y: ${y}`;
                } else if (item.classList.contains('arrow-group')) {
                    coordsDisplay.innerHTML = `Arrow selected`;
                }
            } else {
                coordsDisplay.textContent = "Nothing selected";
            }
        }
        
        function editCoordinates(e) {
            e.stopPropagation();
            const blockToEdit = lastSelectedItem && lastSelectedItem.classList.contains('block') ? lastSelectedItem : null;
            if (!blockToEdit || isEditing) return;
            const x = parseInt(blockToEdit.style.left); 
            const y = parseInt(blockToEdit.style.top);
            coordsDisplay.innerHTML = `X: <input type="number" value="${x}" id="coord-x"> Y: <input type="number" value="${y}" id="coord-y">`;
            const inputX = document.getElementById('coord-x'); 
            const inputY = document.getElementById('coord-y');
            inputX.focus(); 
            inputX.select();
            const applyAndClose = () => {
                blockToEdit.style.left = `${parseInt(inputX.value) || 0}px`;
                blockToEdit.style.top = `${parseInt(inputY.value) || 0}px`;
                updateArrowsForBlock(blockToEdit); 
                updateCoordinates();
                document.removeEventListener('click', handleClickOutside, true);
            };
            const handleClickOutside = (e) => {
                if (!coordsDisplay.contains(e.target)) {
                    applyAndClose();
                }
            };
            setTimeout(() => document.addEventListener('click', handleClickOutside, true), 0);
            [inputX, inputY].forEach(input => {
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        applyAndClose();
                    }
                });
            });
        }

        // --- Customization Panel ---
        const customizeInputs = {
            block: document.getElementById('block-controls'), 
            text: document.getElementById('text-controls'), 
            link: document.getElementById('link-controls'),
            arrow: document.getElementById('arrow-controls'),
            grid: document.getElementById('grid-controls'),
            blockBg: document.getElementById('block-bg-color'), 
            blockBorder: document.getElementById('block-border-color'),
            textColor: document.getElementById('text-color'), 
            textSize: document.getElementById('text-size'),
            textFont: document.getElementById('text-font'),
            linkSrc: document.getElementById('link-src'),
            arrowColor: document.getElementById('arrow-color'), 
            arrowWidth: document.getElementById('arrow-width'),
            gridBg: document.getElementById('grid-bg-color'), 
            gridLines: document.getElementById('grid-line-color'),
            boldBtn: document.getElementById('bold-btn'),
            italicBtn: document.getElementById('italic-btn'),
            underlineBtn: document.getElementById('underline-btn'),
        };
        
        customizePanel.querySelector('.panel-close-btn').addEventListener('click', () => customizePanel.style.display = 'none');
        
        function updateCustomizePanel() {
            const hasBlock = selection.some(item => item.classList.contains('block'));
            const hasArrow = selection.some(item => item.classList.contains('arrow-group'));
            const lastSelectedBlock = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : selection.find(i => i.classList.contains('block'));
            const hasIframe = lastSelectedBlock && lastSelectedBlock.querySelector('iframe');
            
            customizeInputs.block.classList.toggle('hidden', !hasBlock);
            customizeInputs.arrow.classList.toggle('hidden', !hasArrow);
            customizeInputs.grid.classList.toggle('hidden', hasBlock || hasArrow);
            
            // Context-specific controls
            customizeInputs.text.classList.toggle('hidden', !hasBlock || hasIframe);
            customizeInputs.link.classList.toggle('hidden', !hasIframe);

            if (hasBlock && lastSelectedBlock) {
                const computed = getComputedStyle(lastSelectedBlock);
                customizeInputs.blockBg.value = rgbToHex(computed.backgroundColor); 
                customizeInputs.blockBorder.value = rgbToHex(computed.borderColor);

                if (hasIframe) {
                    customizeInputs.linkSrc.value = hasIframe.src;
                } else {
                    const content = lastSelectedBlock.querySelector('.block-content');
                    const computedContent = getComputedStyle(content);
                    customizeInputs.textColor.value = rgbToHex(computedContent.color); 
                    customizeInputs.textSize.value = parseInt(computedContent.fontSize);
                    const fontOption = Array.from(customizeInputs.textFont.options).find(opt => opt.value === computedContent.fontFamily);
                    customizeInputs.textFont.value = fontOption ? fontOption.value : customizeInputs.textFont.options[0].value;
                }
            }
            if (hasArrow) {
                const arrowToSample = lastSelectedItem?.classList.contains('arrow-group') ? lastSelectedItem : selection.find(i => i.classList.contains('arrow-group'));
                if (arrowToSample) {
                    const arrowLine = arrowToSample.querySelector('.arrow-line');
                    customizeInputs.arrowColor.value = rgbToHex(arrowLine.getAttribute('stroke') || '#000000');
                    customizeInputs.arrowWidth.value = arrowLine.getAttribute('stroke-width');
                }
            }
        }
        
        // --- Customization Event Listeners ---
        const formatText = (command) => {
            document.execCommand(command, false, null);
            selection.forEach(item => {
                const contentEl = item.querySelector('.block-content');
                if(item.classList.contains('block') && contentEl && contentEl.isContentEditable) {
                    contentEl.focus();
                }
            });
        };
        customizeInputs.boldBtn.addEventListener('mousedown', (e) => { e.preventDefault(); formatText('bold'); });
        customizeInputs.italicBtn.addEventListener('mousedown', (e) => { e.preventDefault(); formatText('italic'); });
        customizeInputs.underlineBtn.addEventListener('mousedown', (e) => { e.preventDefault(); formatText('underline'); });

        const applyStyleToSelection = (property, value) => {
             selection.forEach(item => { 
                if (item.classList.contains('block')) {
                    const content = item.querySelector('.block-content');
                    if(content && !content.querySelector('iframe')) document.execCommand('styleWithCSS', false, true); document.execCommand(property, false, value); document.execCommand('styleWithCSS', false, false);
                }
            });
        };

        customizeInputs.blockBg.addEventListener('input', e => { selection.forEach(item => { if (item.classList.contains('block')) item.style.backgroundColor = e.target.value; }); });
        customizeInputs.blockBorder.addEventListener('input', e => { selection.forEach(item => { if (item.classList.contains('block')) item.style.borderColor = e.target.value; }); });
        customizeInputs.textColor.addEventListener('input', e => formatText('foreColor', e.target.value));
        customizeInputs.textSize.addEventListener('input', e => formatText('fontSize', 7)); // Map size to 1-7 range later
        customizeInputs.textFont.addEventListener('input', e => formatText('fontName', e.target.value));
        
        customizeInputs.linkSrc.addEventListener('change', e => {
            selection.forEach(item => {
                const iframe = item.querySelector('iframe');
                if (iframe) iframe.src = e.target.value;
            });
        });

        customizeInputs.arrowColor.addEventListener('input', e => { 
            selection.forEach(item => { 
                if (item.classList.contains('arrow-group')) { 
                    item.querySelector('.arrow-line').setAttribute('stroke', e.target.value); 
                    updateSingleArrow(item); 
                } 
            }); 
        });
        customizeInputs.arrowWidth.addEventListener('input', e => { selection.forEach(item => { if (item.classList.contains('arrow-group')) item.querySelector('.arrow-line').setAttribute('stroke-width', e.target.value); }); });
        customizeInputs.gridBg.addEventListener('input', e => { document.body.style.background = e.target.value; });
        customizeInputs.gridLines.addEventListener('input', e => {
            const color = e.target.value;
            grid.style.backgroundImage = `linear-gradient(${color} 1px, transparent 1px), linear-gradient(90deg, ${color} 1px, transparent 1px)`;
        });
        
        // --- Save & Load Logic ---
        function saveState() {
            const state = {
                blocks: Array.from(document.querySelectorAll('.block')).map(block => {
                    const contentEl = block.querySelector('.block-content');
                    return {
                        id: block.id,
                        htmlContent: contentEl.innerHTML,
                        x: parseInt(block.style.left),
                        y: parseInt(block.style.top),
                        width: block.style.width,
                        height: block.style.height,
                        bgColor: block.style.backgroundColor,
                        borderColor: block.style.borderColor,
                    };
                }),
                arrows: Array.from(svgCanvas.querySelectorAll('.arrow-group')).map(arrowGroup => {
                    const arrowLine = arrowGroup.querySelector('.arrow-line');
                    return {
                        startBlock: arrowGroup.getAttribute('data-start-block'),
                        endBlock: arrowGroup.getAttribute('data-end-block'),
                        color: arrowLine.getAttribute('stroke'),
                        width: arrowLine.getAttribute('stroke-width'),
                    };
                }),
                styles: {
                    gridBg: document.body.style.background,
                    gridLines: grid.style.backgroundImage,
                }
            };
            download('grid-state.json', JSON.stringify(state, null, 2));
        }

        function loadState(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    applyState(JSON.parse(e.target.result));
                } catch (err) {
                    console.error('Error parsing JSON:', err);
                    alert('Failed to load file. It may be corrupted.');
                }
            };
            reader.readAsText(file);
        }

        function applyState(state) {
            document.querySelectorAll('.block').forEach(block => block.remove());
            svgCanvas.querySelectorAll('.arrow-group, marker').forEach(el => el.remove()); // Clear markers too
            deselectAll();
            gridX = 0; gridY = 0;
            grid.style.transform = `translate(${gridX}px, ${gridY}px)`;
            if (state.styles) {
                if (state.styles.gridBg) document.body.style.background = state.styles.gridBg;
                if (state.styles.gridLines) grid.style.backgroundImage = state.styles.gridLines;
            }
            if (state.blocks) state.blocks.forEach(createBlock);
            if (state.arrows) {
                state.arrows.forEach(arrowData => {
                    const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    arrowGroup.classList.add('arrow-group');
                    arrowGroup.setAttribute('data-start-block', arrowData.startBlock);
                    arrowGroup.setAttribute('data-end-block', arrowData.endBlock);
                    const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    arrowLine.classList.add('arrow-line');
                    arrowLine.setAttribute('stroke', arrowData.color);
                    arrowLine.setAttribute('stroke-width', arrowData.width);

                    const markerId = `arrowhead-${arrowData.startBlock}-${arrowData.endBlock}`;
                    createOrUpdateMarker(markerId, arrowData.color);
                    arrowLine.setAttribute('marker-end', `url(#${markerId})`);
                    
                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hitbox.classList.add('arrow-hitbox');
                    arrowGroup.appendChild(arrowLine);
                    arrowGroup.appendChild(hitbox);
                    svgCanvas.appendChild(arrowGroup);
                    updateSingleArrow(arrowGroup);
                });
            }
        }

        // --- Utility Functions ---
        function rgbToHex(rgb) {
            if (!rgb) return '#000000';
            const rgbArr = rgb.match(/\d+/g);
            if (!rgbArr) return '#000000';
            const hex = rgbArr.map(x => ('0' + parseInt(x).toString(16)).slice(-2)).join('');
            return `#${hex}`;
        }

        function getBlockCenter(block) {
            const x = parseInt(block.style.left);
            const y = parseInt(block.style.top);
            return { x: x + block.offsetWidth / 2, y: y + block.offsetHeight / 2 };
        }
        
        function getClosestConnectionPoint(from, to) {
            const fromCenter = getBlockCenter(from);
            const toCenter = getBlockCenter(to);
            const dx = toCenter.x - fromCenter.x;
            const dy = toCenter.y - fromCenter.y;
            const halfW = from.offsetWidth / 2;
            const halfH = from.offsetHeight / 2;
            if (dx === 0 && dy === 0) return { x: fromCenter.x - halfW, y: fromCenter.y - halfH };
            const slope = dy / dx;
            const diagSlope = halfH / halfW;
            let point = { x: 0, y: 0 };
            if (Math.abs(slope) < diagSlope) {
                if (dx > 0) { point.x = fromCenter.x + halfW; point.y = fromCenter.y + halfW * slope; }
                else { point.x = fromCenter.x - halfW; point.y = fromCenter.y - halfW * slope; }
            } else {
                if (dy > 0) { point.y = fromCenter.y + halfH; point.x = fromCenter.x + halfH / slope; }
                else { point.y = fromCenter.y - halfH; point.x = fromCenter.x - halfH / slope; }
            }
            return point;
        }
        
        function download(filename, text) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }
    });
    </script>
</body>
</html>

