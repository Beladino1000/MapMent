<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas - MentMap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --glow-color: #0d82e8;
            --background-start: #111827;
            --background-end: #0c0d24;
            --text-light: #f9fafb;
            --text-muted: #9ca3af;
            --panel-bg: rgba(23, 25, 43, 0.7);
            --border-color: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes backgroundPan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(90deg, var(--background-start), var(--background-end), var(--background-start));
            background-size: 200% 200%;
            animation: backgroundPan 30s ease infinite;
            height: 100vh;
            width: 100vw;
            display: flex;
            color: var(--text-light);
            cursor: default;
            user-select: none;
            -webkit-user-select: none;
        }
        
        body.arrow-mode .block {
            cursor: crosshair;
        }

        .container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .grid {
            position: absolute;
            width: 500vw;
            height: 500vh;
            left: 0;
            top: 0;
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            background-position: top left;
            transform-origin: top left;
            will-change: transform;
            transition: background-image 0.5s;
        }
        
        #arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        #arrow-svg .arrow-group {
            pointer-events: all;
            cursor: pointer;
            transition: filter 0.3s ease;
        }
        
        #arrow-svg .arrow-line {
             transition: stroke 0.3s ease, stroke-width 0.3s ease;
        }

        #arrow-svg .arrow-hitbox {
            stroke: transparent;
            stroke-width: 20;
        }

        #arrow-svg .arrow-group.selected {
            filter: url(#selection-glow);
        }
        #arrow-svg .arrow-group:hover .arrow-line {
            stroke: var(--glow-color);
        }


        .block {
            position: absolute;
            width: 250px;
            height: auto;
            min-height: 100px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            padding: 18px;
            cursor: grab;
            overflow: visible;
            transition: border-color 0.3s, box-shadow 0.3s, transform 0.2s ease-out, background-color 0.3s;
            z-index: 10;
            display: flex;
            flex-direction: column;
            color: var(--text-light);
        }
        .block:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), 0 0 20px rgba(13, 130, 232, 0.3);
        }
        
        .block.selected {
            border-color: var(--glow-color);
            box-shadow: 0 0 25px rgba(13, 130, 232, 0.7);
        }
        
        .block.pre-selected {
            outline: 2px dashed rgba(13, 130, 232, 0.6);
        }

        .block-name {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0.7;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .block-content {
            outline: none;
            padding: 5px;
            line-height: 1.5;
            width: 100%;
            min-height: 30px;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            flex-grow: 1;
            cursor: text;
            font-size: 15px;
        }

        .block-content[contenteditable="true"] {
            border: 1px dashed var(--glow-color);
            padding: 4px;
            user-select: text;
            -webkit-user-select: text;
        }
        
        /* Correção para redimensionamento de iframe */
        .block-content.has-iframe {
            padding: 0;
            overflow: hidden; /* Garante que o iframe não ultrapasse a borda arredondada */
            height: 100%;
        }
        
        .block-content.has-iframe iframe {
             border-radius: 0 !important; /* Remove o radius do iframe para que o do pai funcione */
        }

        .block-content iframe,
        .block-content img,
        .block-content video {
            width: 100%;
            height: 100%; /* Alterado de 'auto' para 100% para iframes */
            display: block;
            border: none;
            border-radius: 8px;
            cursor: default;
        }

        .block.dragging iframe,
        .block.dragging video,
        .block.is-held-down iframe,
        .block.is-held-down video {
            pointer-events: none;
        }
        
        body.is-drawing-arrow iframe {
            pointer-events: none;
        }
        
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--handle-color, rgba(255, 255, 255, 0.2));
            display: var(--handle-display, block);
            border: 2px solid var(--background-start);
            border-radius: 50%;
            z-index: 20;
            opacity: 0;
            transition: all 0.2s;
        }
        .block:hover .resize-handle {
            opacity: 1;
            background-color: var(--handle-color, var(--glow-color));
        }

        .handle-n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .handle-e { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .handle-se { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .handle-s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .handle-w { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .handle-nw { top: -6px; left: -6px; cursor: nwse-resize; }
        
        .coordinates {
            position: fixed; 
            top: 10px; 
            left: 10px;
            background: rgba(23, 25, 43, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: var(--text-light); 
            padding: 8px 12px;
            border-radius: 8px; 
            font-size: 0.8rem; 
            z-index: 2001; 
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }
        .coordinates.hidden {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }
        .coordinates input {
            width: 60px; 
            background: rgba(0,0,0,0.3); 
            color: white; 
            border: 1px solid #555;
            border-radius: 5px; 
            padding: 2px 5px; 
            text-align: center;
        }

        .shortcut-hint {
            position: fixed;
            top: 10px;
            right: 265px;
            left: auto;
            background: rgba(23, 25, 43, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: var(--text-light);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
            z-index: 1000;
            opacity: 0.95;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            transition: right 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }

        body.sidebar-hidden .shortcut-hint {
            right: 15px;
        }

        .shortcut-hint kbd {
            background: rgba(255,255,255,0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        .shortcut-hint hr {
            border-color: var(--border-color);
            margin: 8px 0;
        }

        .shortcut-hint .hint-line {
            margin-bottom: 6px;
        }
        .shortcut-hint .hint-category {
            font-weight: bold;
            margin-top: 8px;
            margin-bottom: 4px;
        }

        #context-menu {
            display: none;
            position: fixed;
            z-index: 3000;
            background: rgba(30, 32, 55, 0.85);
            backdrop-filter: blur(16px);
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            border: 1px solid var(--border-color);
            min-width: 180px;
        }
        #context-menu ul { list-style: none; padding: 0; margin: 0; }
        #context-menu li { padding: 9px 16px; color: var(--text-light); cursor: pointer; border-radius: 5px; font-size: 14px; transition: background-color 0.2s; }
        #context-menu li:hover { background: var(--glow-color); }
        #context-menu .menu-header {
            color: var(--text-muted);
            font-size: 11px;
            padding: 8px 15px 4px;
            cursor: default;
            font-weight: 600;
            text-transform: uppercase;
        }
        #context-menu li.menu-header:hover { background: transparent; }
        #context-menu .has-submenu { position: relative; }
        #context-menu .has-submenu .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: -6px;
            background: rgba(30, 32, 55, 0.85);
            backdrop-filter: blur(16px);
            border-radius: 8px;
            padding: 6px;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.4);
            list-style: none;
            min-width: 160px;
            z-index: 3001;
            border: 1px solid var(--border-color);
        }
        #context-menu .has-submenu:hover > .submenu { display: block; }
        #context-menu .separator {
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 8px;
            padding: 0;
        }
        .submenu .submenu-input-group {
            padding: 5px 10px;
            display: flex;
            gap: 5px;
        }
        .submenu .submenu-input-group input {
            width: 60px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px;
        }
        .submenu .submenu-input-group button {
            background: var(--glow-color);
            border: none;
            color: white;
            border-radius: 4px;
            padding: 0 8px;
            cursor: pointer;
        }


        .marquee-box {
            position: fixed;
            border: 1px dashed var(--glow-color);
            background: rgba(13, 130, 232, 0.2);
            pointer-events: none;
            z-index: 9999;
        }

        .toast-notification {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            z-index: 10000;
            font-size: 15px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .toast-notification.show { opacity: 1; bottom: 100px; }

        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 250px;
            height: 100vh;
            background: rgba(23, 25, 43, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: var(--text-light);
            box-shadow: -5px 0 25px rgba(0,0,0,0.5);
            border-left: 1px solid var(--border-color);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-size: 13px;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            overflow-y: auto;
        }
        .sidebar.hidden {
            transform: translateX(100%);
        }

        .sidebar-section { padding: 15px; border-bottom: 1px solid var(--border-color); }
        .sidebar-section:last-child { border-bottom: none; }
        .sidebar-section h4 {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }

        #blocks-list-container {
            min-height: 100px; /* Garante que a seção tenha uma altura mínima */
            max-height: 25vh;
            overflow-y: auto;
        }

        #blocks-list { list-style: none; padding: 0; }
        #blocks-list li {
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 5px;
            background: rgba(0,0,0,0.2);
            cursor: grab;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s, border-top 0.2s;
        }
        #blocks-list li:hover { background: rgba(255,255,255,0.2); }
        #blocks-list li.selected { background: var(--glow-color); }
        #blocks-list li.dragging {
            opacity: 0.4;
            background: var(--glow-color);
        }
        
        #rename-block-form {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        #rename-block-form input {
            flex-grow: 1;
        }


        .page-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .page-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
        }
        .page-btn:hover { background-color: var(--glow-color); transform: scale(1.1); }
        .page-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; background-color: rgba(255, 255, 255, 0.1); }
        #page-display {
            font-weight: 600;
            background: rgba(0,0,0,0.3);
            padding: 5px 12px;
            border-radius: 15px;
            min-width: 80px;
            text-align: center;
            margin: 5px 0;
        }

        .actions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .control-btn {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 13px;
        }
        #add-content-btn { grid-column: 1 / -1; } /* Make add button full width */
        .control-btn.active { background: var(--glow-color); box-shadow: 0 0 10px var(--glow-color); }
        .control-btn:hover { background: var(--glow-color); }
        .control-btn:disabled { background: #444; color: #888; cursor: not-allowed; }

        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .color-picker-wrapper { width: 24px; height: 24px; border-radius: 50%; border: 2px solid var(--border-color); cursor: pointer; transition: transform 0.2s; }
        .color-picker-wrapper:hover { transform: scale(1.15); }
        .control-group input[type="range"], .control-group input[type="number"], .control-group input[type="checkbox"] {
            width: 120px;
            background: rgba(0,0,0,0.3); color: white; border: 1px solid #666; border-radius: 4px; padding: 3px;
        }
        .sidebar .control-group input[type="text"], .add-family-form input[type="text"], #rename-block-form input[type="text"] {
             width: 100%;
            background: rgba(0,0,0,0.3);
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
        }
         .sidebar .control-group input[type="text"]:focus, .add-family-form input[type="text"]:focus, #rename-block-form input[type="text"]:focus {
            outline: none;
            border-color: var(--glow-color);
            box-shadow: 0 0 5px rgba(13, 130, 232, 0.5);
        }

        .control-group input[type="checkbox"] { width: auto; }
        .text-format-buttons { display: flex; gap: 10px; margin-bottom: 12px; }
        .format-btn { flex: 1; background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); color: white; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .format-btn:hover { background: rgba(255,255,255,0.2); }
        .format-btn.active { background-color: var(--glow-color); }
        .hidden { display: none !important; }

        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid #666; border-radius: 4px; padding: 4px 8px; padding-right: 25px;
            width: 100%; cursor: pointer;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto;
        }
        .select-wrapper {
             width: 120px;
        }

        .sidebar::-webkit-scrollbar, #blocks-list-container::-webkit-scrollbar { width: 10px; }
        .sidebar::-webkit-scrollbar-track, #blocks-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
        .sidebar::-webkit-scrollbar-thumb, #blocks-list-container::-webkit-scrollbar-thumb { background: #555; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        .sidebar::-webkit-scrollbar-thumb:hover, #blocks-list-container::-webkit-scrollbar-thumb:hover { background: var(--glow-color); }
        
        #custom-color-picker {
            position: fixed;
            width: 240px;
            background: rgba(30, 32, 55, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 4000;
            padding: 10px;
            font-size: 13px;
            color: #eee;
        }
        .color-picker-header {
            padding: 8px; text-align: center; font-weight: bold; cursor: move;
            background: rgba(255,255,255,0.1); margin: -10px -10px 10px -10px;
            border-top-left-radius: 8px; border-top-right-radius: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .color-picker-body { display: flex; flex-direction: column; gap: 10px; }
        .color-spectrum { width: 100%; height: 120px; position: relative; cursor: crosshair; background: linear-gradient(to top, black, transparent), linear-gradient(to right, white, hsl(0, 100%, 50%)); }
        .spectrum-cursor {
            position: absolute; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.7), 0 0 0 2px black inset; pointer-events: none; transform: translate(-50%, -50%);
        }
        .color-slider { width: 100%; -webkit-appearance: none; appearance: none; height: 10px; border-radius: 5px; background: #555; outline: none; }
        .hue-slider { background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }
        .opacity-slider { background: linear-gradient(to right, transparent, white); }
        .color-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%;
            background: #fff; cursor: pointer; border: 2px solid #333;
        }
        .color-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 10px; align-items: center; }
        .color-inputs label { font-size: 12px; color: var(--text-muted); }
        .color-inputs input {
            width: 100%; background: #333; border: 1px solid #666; color: #fff;
            border-radius: 4px; padding: 4px; text-align: center;
        }
        .color-inputs input[type="number"] { -moz-appearance: textfield; }
        .color-inputs input[type="number"]::-webkit-inner-spin-button, .color-inputs input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .color-picker-footer { margin-top: 10px; display: flex; gap: 10px; }
        .color-picker-footer button {
            flex: 1; background: rgba(255,255,255,0.1); color: var(--text-light); border: 1px solid var(--border-color);
            padding: 8px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;
        }
        .color-picker-footer button:hover { background: rgba(255,255,255,0.2); }
        .color-picker-footer button.confirm-btn:hover { background: var(--glow-color); }

        #families-list { list-style: none; padding: 0; max-height: 150px; overflow-y: auto; }
        #families-list li { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-radius: 4px; margin-bottom: 5px; background: rgba(0,0,0,0.2); }
        #families-list span { flex-grow: 1; cursor: pointer; }
        .family-actions button { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 14px; padding: 2px 5px; }
        .family-actions button:hover { color: var(--text-light); }
        .add-family-form { display: flex; gap: 5px; margin-top: 10px; }
        .add-family-form input { flex-grow: 1; }

    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="grid" id="grid">
            <svg id="arrow-svg">
                <defs>
                    <filter id="selection-glow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="5" result="blur"></feGaussianBlur>
                        <feFlood flood-color="var(--glow-color)" result="color"></feFlood>
                        <feComposite in="color" in2="blur" operator="in" result="glow"></feComposite>
                        <feMerge>
                            <feMergeNode in="glow"></feMergeNode>
                            <feMergeNode in="SourceGraphic"></feMergeNode>
                        </feMerge>
                    </filter>
                </defs>
            </svg>
        </div>
    </div>

    <div class="coordinates" id="coordinates" data-translate-key="coords_nothing">Nada selecionado</div>

    <div class="shortcut-hint" id="shortcut-hint" style="display: none;">
        <div class="hint-line"><span data-translate-key="hint_toggle">Pressione <kbd>H</kbd> para mostrar/esconder os atalhos</span></div><hr>
        <div class="hint-category" data-translate-key="hint_nav_title">Navegação e Visualização:</div>
        <div class="hint-line"><span data-translate-key="hint_pan">Segure <kbd>Shift</kbd> ou <kbd>Clique Meio</kbd> para mover o mapa</span></div>
        <div class="hint-line"><span data-translate-key="hint_zoom">Use o <kbd>Scroll</kbd> para dar zoom</span></div>
        <div class="hint-line"><span data-translate-key="hint_slides">Use <kbd>←</kbd> / <kbd>→</kbd> para mudar de slide</span></div>
        <div class="hint-line"><span data-translate-key="hint_sidebar">Use <kbd>G</kbd> Esconder/Mostrar Painel Lateral</span></div>
        <div class="hint-line"><span data-translate-key="hint_coords"><kbd>N</kbd> Esconder/Mostrar Coordenadas</span></div>
        <hr>
        <div class="hint-category" data-translate-key="hint_actions_title">Ações e Atalhos:</div>
        <div class="hint-line"><span data-translate-key="hint_add"><kbd>Shift</kbd> + <kbd>A</kbd> Adicionar conteúdo</span></div>
        <div class="hint-line"><span data-translate-key="hint_duplicate"><kbd>Shift</kbd> + <kbd>D</kbd> Duplicar/Adicionar</span></div>
        <div class="hint-line"><span data-translate-key="hint_add_slide"><kbd>Shift</kbd> + <kbd>+</kbd> Adicionar Slide</span></div>
        <div class="hint-line"><span data-translate-key="hint_delete_slide"><kbd>Shift</kbd> + <kbd>-</kbd> Deletar Slide</span></div>
        <div class="hint-line"><span data-translate-key="hint_smart_color"><kbd>B</kbd> Paleta de Cores Inteligente</span></div>
        <div class="hint-line"><span data-translate-key="hint_parent_move"><kbd>P</kbd> Ativar/Desativar Movimento em Grupo</span></div>
        <div class="hint-line"><span data-translate-key="hint_delete"><kbd>Delete</kbd> Apagar itens</span></div>
        <div class="hint-line"><span data-translate-key="hint_undo"><kbd>Ctrl</kbd> + <kbd>Z</kbd> Desfazer</span></div>
        <div class="hint-line"><span data-translate-key="hint_redo"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> Refazer</span></div>
        <div class="hint-line"><span data-translate-key="hint_save"><kbd>Ctrl</kbd> + <kbd>S</kbd> para salvar</span></div>
        <div class="hint-line"><span data-translate-key="hint_load"><kbd>Ctrl</kbd> + <kbd>L</kbd> para carregar</span></div>
    </div>

    <div class="sidebar">
        <div class="sidebar-section">
            <h4 data-translate-key="sidebar_blocks_list">Lista de Blocos</h4>
            <div id="blocks-list-container">
                <ul id="blocks-list"></ul>
            </div>
            <div id="rename-block-form" class="hidden">
                <input type="text" id="rename-block-input" placeholder="Novo nome do bloco">
                <button class="page-btn" id="rename-block-btn" title="Confirmar">✓</button>
            </div>
        </div>
        <div class="sidebar-section">
            <h4 data-translate-key="sidebar_customize">Customizar</h4>
            <div id="customize-content">
                <div id="block-controls" class="control-group hidden">
                    <h5 data-translate-key="sidebar_block">Bloco</h5>
                    <label>
                        <span data-translate-key="sidebar_family">Família</span>
                        <div class="select-wrapper">
                             <select id="family-select"></select>
                        </div>
                    </label>
                    <label><span data-translate-key="sidebar_background">Fundo</span><div class="color-picker-wrapper" data-color-target="blockBg"></div></label>
                    <label><span data-translate-key="sidebar_border">Borda</span><div class="color-picker-wrapper" data-color-target="blockBorder"></div></label>
                </div>
                <div id="handle-controls" class="control-group hidden"><h5 data-translate-key="sidebar_handles">Alças</h5><label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="handle"></div></label><label><span data-translate-key="sidebar_visible">Visível</span><input type="checkbox" id="handle-visible" checked></label></div>
                <div id="text-controls" class="control-group hidden">
                    <h5 data-translate-key="sidebar_text">Texto</h5>
                    <div class="text-format-buttons">
                        <button id="bold-btn" class="format-btn"><b>B</b></button>
                        <button id="italic-btn" class="format-btn"><i>I</i></button>
                        <button id="underline-btn" class="format-btn"><u>U</u></button>
                    </div>
                    <label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="text"></div></label>
                    <label>
                        <span data-translate-key="sidebar_size">Tamanho (px)</span>
                        <div class="select-wrapper">
                            <select id="text-size"></select>
                        </div>
                    </label>
                    <label>
                        <span data-translate-key="sidebar_font">Fonte</span>
                        <div class="select-wrapper">
                            <select id="text-font">
                                <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" data-translate-key="font_default">Padrão</option>
                                <option value="Arial, sans-serif">Arial</option>
                                <option value="Georgia, serif">Georgia</option>
                                <option value="Courier New, monospace">Courier New</option>
                                <option value="Verdana, sans-serif">Verdana</option>
                                <option value="Times New Roman, serif">Times New Roman</option>
                            </select>
                        </div>
                    </label>
                </div>
                <div id="link-controls" class="control-group hidden">
                    <h5 data-translate-key="sidebar_embed">Link Incorporado</h5>
                    <label><span>URL</span><input type="text" id="link-src"></label>
                </div>
                <div id="arrow-controls" class="control-group hidden">
                    <h5 data-translate-key="sidebar_arrow">Seta</h5>
                    <label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="arrow"></div></label>
                    <label><span data-translate-key="sidebar_size">Tamanho</span><input type="range" id="arrow-width" min="1" max="10" step="1"></label>
                </div>
                <div id="grid-controls" class="control-group"><h5 data-translate-key="sidebar_grid">Grade</h5><label><span data-translate-key="sidebar_background">Fundo</span><div class="color-picker-wrapper" data-color-target="gridBg"></div></label><label><span data-translate-key="sidebar_lines">Linhas</span><div class="color-picker-wrapper" data-color-target="gridLines"></div></label></div>
            </div>
        </div>
        <div class="sidebar-section">
            <h4 data-translate-key="sidebar_families">Famílias</h4>
            <ul id="families-list"></ul>
            <div class="add-family-form">
                <input type="text" id="new-family-name" placeholder="Nome da nova família">
                <button class="page-btn" id="add-family-btn" title="Criar Família">+</button>
            </div>
        </div>
        <div class="sidebar-section">
            <h4 data-translate-key="sidebar_slides">Slides</h4>
            <div class="page-controls">
                <button class="page-btn" id="prev-page-btn" title="Slide Anterior (←)">▲</button>
                <span id="page-display">Slide 1 / 1</span>
                <button class="page-btn" id="next-page-btn" title="Próximo Slide (→)">▼</button>
                <button class="page-btn" id="add-page-btn" title="Adicionar Novo Slide (Shift +)">+</button>
                <button class="page-btn" id="delete-page-btn" title="Deletar Slide Atual (Shift -)">🗑️</button>
            </div>
        </div>
        <div class="sidebar-section">
            <h4 data-translate-key="sidebar_actions">Ações</h4>
            <div class="actions-grid">
                <button class="control-btn" id="add-content-btn"><span class="btn-icon">+</span><span data-translate-key="btn_add_content">Adicionar</span></button>
                <button class="control-btn" id="toggle-arrow-mode-btn"><span class="btn-icon">→</span><span data-translate-key="btn_arrow_mode">Modo Seta</span></button>
                <button class="control-btn" id="save-btn"><span class="btn-icon">💾</span><span data-translate-key="btn_save">Salvar</span></button>
                <button class="control-btn" id="load-btn"><span class="btn-icon">📂</span><span data-translate-key="btn_load">Carregar</span></button>
                <button class="control-btn active" id="toggle-snap-btn"><span class="btn-icon">🧲</span><span data-translate-key="btn_snap">Encaixe</span></button>
                <button class="control-btn active" id="toggle-parent-move-btn" title="Ativar/Desativar Movimento em Grupo (P)"><span class="btn-icon">👨‍👩‍👧‍👦</span><span data-translate-key="btn_parent_move">Grupo</span></button>
            </div>
        </div>
    </div>

    <div id="context-menu">
        <!-- O conteúdo deste menu será gerado dinamicamente via JS -->
    </div>
    
    <input type="file" id="file-loader" accept=".json" style="display: none;">

    <div id="custom-color-picker" class="hidden">
        <div class="color-picker-header" data-translate-key="color_picker_title">Seletor de Cores</div>
        <div class="color-picker-body">
            <div class="color-spectrum" id="color-spectrum">
                <div class="spectrum-cursor" id="spectrum-cursor"></div>
            </div>
            <input type="range" min="0" max="360" value="0" class="color-slider hue-slider" id="hue-slider">
            <input type="range" min="0" max="1" value="1" step="0.01" class="color-slider opacity-slider" id="opacity-slider">
            <div class="color-inputs">
                <label for="hex-input">HEX</label>
                <input type="text" id="hex-input">
                <label for="rgba-input-r">RGBA</label>
                <div style="display: flex; gap: 2px;">
                    <input type="number" id="rgba-input-r" min="0" max="255">
                    <input type="number" id="rgba-input-g" min="0" max="255">
                    <input type="number" id="rgba-input-b" min="0" max="255">
                    <input type="number" id="rgba-input-a" min="0" max="1" step="0.1">
                </div>
            </div>
        </div>
        <div class="color-picker-footer">
            <button id="color-picker-cancel" data-translate-key="btn_cancel">Cancelar</button>
            <button id="color-picker-confirm" class="confirm-btn" data-translate-key="btn_confirm">Confirmar</button>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

    document.addEventListener('DOMContentLoaded', function() {

        // --- Sistema de Internacionalização (i18n) ---
        const translations = {
            'pt': {
                page_title: "Canvas Interativo - MentMap",
                coords_nothing: "Nada selecionado",
                coords_items: "itens selecionados",
                coords_arrow: "Seta selecionada",
                hint_toggle: "Pressione <kbd>H</kbd> para mostrar/esconder os atalhos",
                hint_nav_title: "Navegação e Visualização:",
                hint_pan: "Segure <kbd>Shift</kbd> ou <kbd>Clique Meio</kbd> para mover o mapa",
                hint_zoom: "Use o <kbd>Scroll</kbd> para dar zoom",
                hint_slides: "Use <kbd>←</kbd> / <kbd>→</kbd> para mudar de slide",
                hint_sidebar: "Use <kbd>G</kbd> para Esconder/Mostrar Painel Lateral",
                hint_coords: "<kbd>N</kbd> para Esconder/Mostrar Coordenadas",
                hint_actions_title: "Ações e Atalhos:",
                hint_add: "<kbd>Shift</kbd> + <kbd>A</kbd> para Adicionar conteúdo",
                hint_duplicate: "<kbd>Shift</kbd> + <kbd>D</kbd> para Duplicar/Adicionar",
                hint_add_slide: "<kbd>Shift</kbd> + <kbd>+</kbd> para Adicionar Slide",
                hint_delete_slide: "<kbd>Shift</kbd> + <kbd>-</kbd> para Deletar Slide",
                hint_smart_color: "<kbd>B</kbd> para Paleta de Cores Inteligente",
                hint_parent_move: "<kbd>P</kbd> Ativar/Desativar Movimento em Grupo",
                hint_delete: "<kbd>Delete</kbd> para Apagar itens",
                hint_undo: "<kbd>Ctrl</kbd> + <kbd>Z</kbd> para Desfazer",
                hint_redo: "<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> para Refazer",
                hint_save: "<kbd>Ctrl</kbd> + <kbd>S</kbd> para salvar",
                hint_load: "<kbd>Ctrl</kbd> + <kbd>L</kbd> para carregar",
                sidebar_customize: "Customizar",
                sidebar_blocks_list: "Lista de Blocos",
                sidebar_block: "Bloco",
                sidebar_background: "Fundo",
                sidebar_border: "Borda",
                sidebar_handles: "Alças",
                sidebar_color: "Cor",
                sidebar_visible: "Visível",
                sidebar_text: "Texto",
                sidebar_size: "Tamanho (px)",
                sidebar_font: "Fonte",
                font_default: "Padrão",
                sidebar_embed: "Link Incorporado",
                sidebar_arrow: "Seta",
                sidebar_grid: "Grade",
                sidebar_lines: "Linhas",
                sidebar_slides: "Slides",
                sidebar_families: "Famílias",
                sidebar_family: "Família",
                sidebar_actions: "Ações",
                btn_add_content: "Adicionar",
                btn_arrow_mode: "Modo Seta",
                btn_save: "Salvar",
                btn_load: "Carregar",
                btn_snap: "Encaixe",
                btn_parent_move: "Grupo",
                menu_move: "Mover",
                menu_move_to: "Para >",
                menu_move_prev: "Slide anterior",
                menu_move_next: "Próximo slide",
                menu_move_specific: "Slide nº:",
                menu_rename: "Renomear",
                menu_add: "Adicionar >",
                menu_add_text: "Bloco de Texto",
                menu_from_file: "Do Arquivo >",
                menu_add_media: "Imagem / Vídeo",
                menu_add_pdf: "PDF como Slides",
                menu_add_phet: "PhET Colorado",
                menu_from_link: "Do Link >",
                color_picker_title: "Seletor de Cores",
                btn_cancel: "Cancelar",
                btn_confirm: "Confirmar",
                toast_snap_on: "Encaixe na Grade Ativado",
                toast_snap_off: "Encaixe na Grade Desativado",
                toast_parent_move_on: "Movimento em Grupo Ativado",
                toast_parent_move_off: "Movimento em Grupo Desativado",
                toast_page_added: "Slide {page} adicionado",
                toast_page_deleted: "Slide {page} deletado",
                toast_cant_delete_last: "Não é possível deletar o último slide.",
                toast_pdf_importing: "Importando {name}... Isso pode levar um momento.",
                toast_pdf_success: "Importado com sucesso {numPages} slides.",
                toast_pdf_error: "Falha ao importar PDF. Veja o console para detalhes.",
                toast_file_loaded: "Arquivo carregado com sucesso!",
                toast_file_error: "Falha ao carregar arquivo. Pode estar corrompido.",
                toast_media_error: "Não foi possível carregar a imagem ou vídeo da URL.",
                toast_block_renamed: "Bloco renomeado para '{name}'.",
                toast_blocks_moved: "{count} bloco(s) movido(s) para o Slide {slide}.",
                toast_invalid_slide: "Número do slide inválido!",
                prompt_media_url: "Insira a URL da Imagem ou Vídeo (YouTube, Vimeo, etc.):",
                prompt_pdf_url: "Insira a URL do PDF para importar como slides:",
                prompt_desmos_url: "Insira a URL do gráfico Desmos:",
                prompt_geogebra_url: "Insira a URL do applet GeoGebra (ex: de compartilhar > incorporar):",
                prompt_phet_url: "Insira a URL da simulação PhET Colorado:",
                flowchart_block_0: "Bem-vindo ao MentMap! 👋\nSiga este fluxograma para aprender o básico.",
                flowchart_block_1: "1. NAVEGAÇÃO\nSegure SHIFT e arraste para mover o canvas. Use o Scroll para dar zoom.",
                flowchart_block_2: "2. ADICIONAR CONTEÚDO\nClique com o botão direito para adicionar blocos de texto, imagens, etc.",
                flowchart_block_3: "3. EDITAR TEXTO\nClique uma vez no texto para editar. Use o painel (letra G) para formatar.",
                flowchart_block_4: "4. CONECTAR IDEIAS\nAtive o 'Modo Seta' ou segure CTRL e arraste entre os blocos.",
                flowchart_block_5: "5. CUSTOMIZAR\nSelecione um item e use o painel lateral (letra G) para mudar cores e fontes.",
                flowchart_block_6: "6. AÇÕES RÁPIDAS\nUse atalhos como Shift+D (duplicar), Delete (apagar) e Ctrl+Z (desfazer).",
                flowchart_block_7: "7. SALVAR E APRESENTAR\nUse os 'Slides' para apresentar e Ctrl+S para salvar seu trabalho."
            }
            // As outras linguagens foram omitidas por brevidade, mas deveriam ser atualizadas também.
        };
        let currentLangStrings = translations['pt'];

        function setLanguage(lang) {
            const langCode = lang.split('-')[0];
            const supportedLangs = ['pt', 'en', 'ja', 'zh'];
            const finalLang = supportedLangs.includes(langCode) ? langCode : 'en';

            currentLangStrings = translations[finalLang] || translations['pt'];
            document.documentElement.lang = finalLang;

            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.dataset.translateKey;
                if (currentLangStrings[key]) {
                    if (key.startsWith('hint_')) {
                        el.innerHTML = currentLangStrings[key];
                    } else {
                        el.textContent = currentLangStrings[key];
                    }
                }
            });
             document.title = currentLangStrings.page_title;
        }


        const container = document.getElementById('container');
        const grid = document.getElementById('grid');
        const svgCanvas = document.getElementById('arrow-svg');
        const svgDefs = svgCanvas.querySelector('defs');
        const coordsDisplay = document.getElementById('coordinates');
        const addContentBtn = document.getElementById('add-content-btn');
        const toggleArrowModeBtn = document.getElementById('toggle-arrow-mode-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileLoader = document.getElementById('file-loader');
        const shortcutHint = document.getElementById('shortcut-hint');
        const contextMenu = document.getElementById('context-menu');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const addPageBtn = document.getElementById('add-page-btn');
        const deletePageBtn = document.getElementById('delete-page-btn');
        const pageDisplay = document.getElementById('page-display');
        const sidebar = document.querySelector('.sidebar');
        const toggleSnapBtn = document.getElementById('toggle-snap-btn');
        const toggleParentMoveBtn = document.getElementById('toggle-parent-move-btn');
        const familySelect = document.getElementById('family-select');
        const familiesList = document.getElementById('families-list');
        const addFamilyBtn = document.getElementById('add-family-btn');
        const newFamilyNameInput = document.getElementById('new-family-name');
        const blocksList = document.getElementById('blocks-list');
        const renameBlockForm = document.getElementById('rename-block-form');
        const renameBlockInput = document.getElementById('rename-block-input');
        const renameBlockBtn = document.getElementById('rename-block-btn');

    
        let isDragging = false, isPanning = false, isEditing = false, isArrowMode = false, isDrawingArrow = false;
        let isResizing = false;
        let isMarqueeSelecting = false;
        let isSnapEnabled = true;
        let isParentMoveEnabled = true;
        let isEditingCoords = false; // State to fix coordinates editing bug
        let resizeDirection = '';
        let resizeInitialRect = null; 
        let resizeInitialStates = [];
        let currentBlock = null, arrowStartBlock = null;
        let selection = []; 
        let lastSelectedItem = null; 
        let startX, startY, mouseMoved = false, lastMouseX = 0, lastMouseY = 0;
        let dragInitialPositions = [];
        let contextMenuX, contextMenuY;
        let gridX = 0, gridY = 0, blockCounter = 1;
        let scale = 1;
        let tempArrow = null;
        let ctrlPressed = false;
        let lastBlockCreationAction = () => addNewBlock({ contentModel: [{ text: 'Novo Bloco.', style: {} }] });
        let activeEditingElement = null; 
        let marqueeBox = null, marqueeStartX = 0, marqueeStartY = 0;
        let mouseDownTarget = null;
        let marqueeHasMoved = false;
        
        let activeContentModel = [];
        
        let pages = [];
        let currentPageIndex = 0;
        let families = [];

        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY_STATES = 32;

        setLanguage(navigator.language);

        shortcutHint.style.display = 'block';
        setTimeout(() => {
            shortcutHint.style.display = 'none';
        }, 30000);

        function initialize() {
            populateFontSizeSelector();
            const initialPage = {
                blocks: [
                    { x: 830, y: 100, width: '280px', name: "Boas-vindas", contentModel: [{ text: currentLangStrings.flowchart_block_0, style: {} }], id: 'block-0', zIndex: 8 },
                    { x: 830, y: 280, width: '280px', name: "Navegação", contentModel: [{ text: currentLangStrings.flowchart_block_1, style: {} }], id: 'block-1', zIndex: 7 },
                    { x: 830, y: 460, width: '280px', name: "Adicionar Conteúdo", contentModel: [{ text: currentLangStrings.flowchart_block_2, style: {} }], id: 'block-2', zIndex: 6 },
                    { x: 830, y: 640, width: '280px', name: "Editar Texto", contentModel: [{ text: currentLangStrings.flowchart_block_3, style: {} }], id: 'block-3', zIndex: 5 },
                    { x: 830, y: 820, width: '280px', name: "Conectar Ideias", contentModel: [{ text: currentLangStrings.flowchart_block_4, style: {} }], id: 'block-4', zIndex: 4 },
                    { x: 830, y: 1000, width: '280px', name: "Customizar", contentModel: [{ text: currentLangStrings.flowchart_block_5, style: {} }], id: 'block-5', zIndex: 3 },
                    { x: 830, y: 1180, width: '280px', name: "Ações Rápidas", contentModel: [{ text: currentLangStrings.flowchart_block_6, style: {} }], id: 'block-6', zIndex: 2 },
                    { x: 830, y: 1360, width: '280px', name: "Salvar e Apresentar", contentModel: [{ text: currentLangStrings.flowchart_block_7, style: {} }], id: 'block-7', zIndex: 1 }
                ],
                arrows: [
                    { startBlock: 'block-0', endBlock: 'block-1', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-1', endBlock: 'block-2', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-2', endBlock: 'block-3', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-3', endBlock: 'block-4', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-4', endBlock: 'block-5', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-5', endBlock: 'block-6', color: '#0d82e8', width: '3' },
                    { startBlock: 'block-6', endBlock: 'block-7', color: '#0d82e8', width: '3' }
                ],
                viewport: { gridX: 0, gridY: 0, scale: 0.8 }, // Adjusted zoom to see more of the flowchart
                styles: {},
                families: []
            };
            blockCounter = 8;
            pages = [initialPage];
            currentPageIndex = 0;
            loadPage(0, true);
            initializeColorPickers();
            recordState(); 
        }
        
        function populateFontSizeSelector() {
            const fontSizes = [8, 9, 10, 11, 12, 14, 15, 16, 18, 20, 24, 30, 36, 48, 64, 72];
            const sizeSelect = document.getElementById('text-size');
            sizeSelect.innerHTML = '';
            fontSizes.forEach(size => {
                const option = document.createElement('option');
                option.value = size;
                option.textContent = size;
                sizeSelect.appendChild(option);
            });
        }

        // --- Listeners de Eventos Principais ---
        addContentBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            const rect = addContentBtn.getBoundingClientRect();
            showContextMenu(rect.left - contextMenu.offsetWidth - 10, rect.top, false, 'add');
        });
        toggleArrowModeBtn.addEventListener('click', toggleArrowMode);
        toggleSnapBtn.addEventListener('click', () => {
            isSnapEnabled = !isSnapEnabled;
            toggleSnapBtn.classList.toggle('active', isSnapEnabled);
            showToast(isSnapEnabled ? currentLangStrings.toast_snap_on : currentLangStrings.toast_snap_off);
        });
        saveBtn.addEventListener('click', saveAllPages);
        loadBtn.addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', (e) => { loadAllPages(e); });
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('keydown', handleKeyDown, true);
        document.addEventListener('keyup', handleKeyUp);
        document.addEventListener('mousedown', handleGlobalMouseDown, true);
        container.addEventListener('mousedown', handleGridMouseDown);
        container.addEventListener('contextmenu', handleGridContextMenu);
        container.addEventListener('wheel', handleZoom, { passive: false });
        container.addEventListener('mousemove', (e) => {
            if (!isDragging && !isResizing && !isPanning) {
                updateCoordinates(e);
            }
        });
        document.addEventListener('click', () => contextMenu.style.display = 'none');
        contextMenu.addEventListener('click', (e) => e.stopPropagation()); // Prevent menu from closing on item click
        svgCanvas.addEventListener('click', handleArrowClick);
        coordsDisplay.addEventListener('click', editCoordinates);

        prevPageBtn.addEventListener('click', goToPrevPage);
        nextPageBtn.addEventListener('click', goToNextPage);
        addPageBtn.addEventListener('click', addNewPage);
        deletePageBtn.addEventListener('click', deleteCurrentPage);
        
        renameBlockBtn.addEventListener('click', confirmRenameBlock);
        renameBlockInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                confirmRenameBlock();
            }
        });
        
        // --- Family Listeners ---
        addFamilyBtn.addEventListener('click', addNewFamily);
        newFamilyNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addNewFamily();
            }
        });
        familySelect.addEventListener('change', assignFamilyToSelection);
        toggleParentMoveBtn.addEventListener('click', toggleParentMove);


        document.addEventListener('selectionchange', () => {
            if (isEditing) {
                updateTextControlsOnSelectionChange();
            }
        });
        
        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, duration);
        }

        function screenToGridCoords(screenX, screenY) {
            const gridRect = grid.getBoundingClientRect();
            return {
                x: (screenX - gridRect.left) / scale,
                y: (screenY - gridRect.top) / scale,
            };
        }
        
        function updateGridTransform() {
            grid.style.transform = `translate(${gridX}px, ${gridY}px) scale(${scale})`;
        }

        function updateSelection(item, shiftKey, fromSidebar = false) {
             if (!shiftKey) {
                deselectAll();
            }
            const index = selection.indexOf(item);
            if (index > -1) {
                if (shiftKey) {
                    item.classList.remove('selected');
                    selection.splice(index, 1);
                    if (lastSelectedItem === item) {
                        lastSelectedItem = selection.length > 0 ? selection[selection.length - 1] : null;
                    }
                }
            } else {
                item.classList.add('selected');
                selection.push(item);
                lastSelectedItem = item;
            }

            if (!fromSidebar && item.classList.contains('block')) {
                 const listItems = blocksList.querySelectorAll('li');
                 listItems.forEach(li => li.classList.remove('selected'));
                 const correspondingLi = blocksList.querySelector(`[data-block-id="${item.id}"]`);
                 if(correspondingLi) correspondingLi.classList.add('selected');
            }
            
            updateUIState();
        }

        function deselectAll() {
            selection.forEach(item => item.classList.remove('selected'));
            selection = [];
            lastSelectedItem = null;
            blocksList.querySelectorAll('li').forEach(li => li.classList.remove('selected'));
            updateUIState();
        }

        function updateUIState() {
            const selectedBlockIds = new Set(selection.filter(item => item.classList.contains('block')).map(block => block.id));
            if (selectedBlockIds.size >= 2) {
                svgCanvas.querySelectorAll('.arrow-group').forEach(arrow => {
                    const startId = arrow.dataset.startBlock;
                    const endId = arrow.dataset.endBlock;
                    if (selectedBlockIds.has(startId) && selectedBlockIds.has(endId)) {
                        if (!selection.includes(arrow)) {
                            selection.push(arrow);
                            arrow.classList.add('selected');
                        }
                    }
                });
            }
            updateCoordinates();
            updateCustomizePanel();
            updateBlocksList();
        }

        function createBlock(config) {
            const block = document.createElement('div');
            block.id = config.id || `block-${blockCounter++}`;
            block.className = 'block';
            block.style.left = `${config.x}px`;
            block.style.top = `${config.y}px`;
            block.style.width = config.width || '250px';
            if (config.height) { 
                block.style.height = config.height;
            }
            const bgColor = config.bgColor || 'var(--panel-bg)';
            block.style.backgroundColor = bgColor;
            if (config.borderColor) block.style.borderColor = config.borderColor;

            block.style.zIndex = config.zIndex || blockCounter;

            if (config.handleColor) block.style.setProperty('--handle-color', config.handleColor);
            if (config.handleDisplay) block.style.setProperty('--handle-display', config.handleDisplay);

            if (config.familyId) {
                block.dataset.familyId = config.familyId;
            }
            
            block.contentModel = config.contentModel || [];

            const nameEl = document.createElement('div');
            nameEl.className = 'block-name';
            block.appendChild(nameEl);

            const contentEl = document.createElement('div');
            contentEl.className = 'block-content';
            block.appendChild(contentEl);

            // Armazenar o nome no elemento para fácil acesso
            block.dataset.name = config.name || `Bloco ${block.id.split('-')[1]}`;
            updateBlockNameDisplay(block);


            if (config.htmlContent) { 
                block.contentModel = parseContent(contentEl, config.htmlContent);
            }
            
            renderContent(block.contentModel, contentEl);

            // Adiciona a classe 'has-iframe' se necessário
            if (contentEl.querySelector('iframe')) {
                contentEl.classList.add('has-iframe');
            }

            const handles = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `resize-handle handle-${handle}`;
                block.appendChild(handleEl);
            });
            
            grid.appendChild(block);

            block.addEventListener('mousedown', (e) => handleBlockMouseDown(e, block));
            block.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!selection.includes(block)) {
                   updateSelection(block, e.shiftKey);
                }
                showContextMenu(e.clientX, e.clientY, true);
            });

            contentEl.addEventListener('keydown', (e) => {
                if (isEditing && (e.key === 'Enter' && !e.shiftKey)) {
                    e.preventDefault();
                    finishEditing();
                }
            });
            
            new ResizeObserver(() => updateArrowsForBlock(block)).observe(block);
            return block;
        }

        function addNewBlock(options = {}) {
            let coords;
            if (contextMenuX && contextMenuY) {
                coords = screenToGridCoords(contextMenuX, contextMenuY);
            } else {
                coords = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);
            }
            
            const isEmbed = options.contentModel && options.contentModel[0].isHTML;

            let config = {
                x: coords.x,
                y: coords.y,
                contentModel: options.contentModel || [{ text: 'Novo Bloco.', style: {} }],
                name: `Bloco ${blockCounter}`,
                zIndex: findHighestZIndex() + 1
            };
            Object.assign(config, options);

            const newBlock = createBlock(config);
            updateSelection(newBlock, false);
            
            if (!isEmbed) {
                startEditing(newBlock);
                const contentEl = newBlock.querySelector('.block-content');
                const range = document.createRange();
                range.selectNodeContents(contentEl);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            recordState();
            updateBlocksList();
        }

        function handleBlockMouseDown(e, block) {
            block.classList.add('is-held-down');
            if (e.target.tagName === 'IFRAME' || e.target.tagName === 'VIDEO' || e.target.tagName === 'IMG') {
                return;
            }
            
            // Ignorar clique direito para não interferir com o menu de contexto do bloco
            if (e.button === 2) return;

            e.stopPropagation();
            mouseDownTarget = e.target;
            startX = e.clientX;
            startY = e.clientY;
            mouseMoved = false;

            const contentEl = block.querySelector('.block-content');
            if (isEditing && contentEl.contains(e.target)) {
                return;
            }
            
            const handle = e.target.closest('.resize-handle');
            if (handle) {
                isResizing = true;
                resizeDirection = handle.className.match(/handle-([a-z]{1,2})/)[1];
                currentBlock = block;
                document.body.style.cursor = getComputedStyle(handle).cursor;

                resizeInitialRect = {
                    width: block.offsetWidth,
                    height: block.offsetHeight,
                    left: block.offsetLeft,
                    top: block.offsetTop,
                };

                resizeInitialStates = []; // For other family members
                if (isParentMoveEnabled && currentBlock.dataset.familyId) {
                    const familyId = currentBlock.dataset.familyId;
                    pages.forEach((page, pageIndex) => {
                        page.blocks.forEach(blockData => {
                            if (blockData.familyId === familyId) {
                                const el = pageIndex === currentPageIndex ? document.getElementById(blockData.id) : null;
                                resizeInitialStates.push({
                                    el: el,
                                    id: blockData.id,
                                    pageIndex: pageIndex,
                                    x: blockData.x,
                                    y: blockData.y,
                                    width: parseFloat(blockData.width),
                                    height: parseFloat(blockData.height) || (el ? el.offsetHeight : 100)
                                });
                            }
                        });
                    });
                } else {
                    resizeInitialStates.push({
                        el: currentBlock,
                        id: currentBlock.id,
                        pageIndex: currentPageIndex,
                        x: currentBlock.offsetLeft,
                        y: currentBlock.offsetTop,
                        width: currentBlock.offsetWidth,
                        height: currentBlock.offsetHeight
                    });
                }
                return;
            }

            if (isArrowMode || ctrlPressed) {
                isDrawingArrow = true;
                arrowStartBlock = block;
                startArrow(e, block);
                return;
            }
            
            currentBlock = block;
        }

        function handleMouseMove(e) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            if (!mouseMoved && (isDrawingArrow || currentBlock || isMarqueeSelecting)) {
                const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                if (dist > 3) mouseMoved = true;
            }

            if (currentBlock && !isDragging && !isResizing && !isPanning && !isDrawingArrow && mouseMoved) {
                isDragging = true;
                document.body.style.cursor = 'grabbing';
                
                dragInitialPositions = [];
                if (isParentMoveEnabled && currentBlock.dataset.familyId) {
                    const familyId = currentBlock.dataset.familyId;
                    pages.forEach((page, pageIndex) => {
                        page.blocks.forEach(blockData => {
                            if (blockData.familyId === familyId) {
                                const el = pageIndex === currentPageIndex ? document.getElementById(blockData.id) : null;
                                dragInitialPositions.push({
                                    el: el,
                                    id: blockData.id,
                                    pageIndex: pageIndex,
                                    x: blockData.x, // Store original position from data model
                                    y: blockData.y
                                });
                                if (el) {
                                   el.style.transition = 'none';
                                   el.classList.add('dragging');
                                }
                            }
                        });
                    });
                } else {
                    if (!selection.includes(currentBlock)) {
                        updateSelection(currentBlock, e.shiftKey);
                    }
                    const blocksToDrag = selection.filter(item => item.classList.contains('block'));
                    dragInitialPositions = blocksToDrag.map(item => ({
                        el: item,
                        id: item.id,
                        pageIndex: currentPageIndex,
                        x: parseInt(item.style.left),
                        y: parseInt(item.style.top)
                    }));
                    dragInitialPositions.forEach(pos => {
                        pos.el.style.transition = 'none';
                        pos.el.classList.add('dragging');
                    });
                }
            }

            if (isResizing) resizeBlock(e);
            else if (isDragging) dragBlock(e);
            else if (isPanning) panGrid(e);
            else if (isDrawingArrow) drawArrow(e);
            else if (isMarqueeSelecting) {
                marqueeHasMoved = true;
                updateMarquee(e);
            }
        }

        function handleMouseUp(e) {
            // Handle selection/editing on click (no movement)
            if (!mouseMoved) {
                if (currentBlock) { // Clicked on a block
                    if (e.shiftKey) {
                        updateSelection(currentBlock, true);
                    } else {
                        // If the click was on the content and it's not an embed, edit it.
                        if (mouseDownTarget && mouseDownTarget.closest('.block-content') && !currentBlock.querySelector('iframe, video, img')) {
                            startEditing(currentBlock);
                        } else {
                            // If it's not already the single selected item, select it.
                            if (!(selection.length === 1 && selection[0] === currentBlock)) {
                               updateSelection(currentBlock, false);
                            }
                        }
                    }
                } else if (isMarqueeSelecting && !marqueeHasMoved) {
                    // This was a simple click on the grid, not a drag for marquee
                    deselectAll();
                }
            }
            
            const wasDraggingOrResizing = isDragging || isResizing;

            if (isDrawingArrow) endArrow(e);
            
            if (isDragging) {
                document.body.style.cursor = 'default';
                dragInitialPositions.forEach(pos => {
                    if (pos.el) {
                        pos.el.style.transition = '';
                        pos.el.classList.remove('dragging');
                    }
                });
                dragInitialPositions = [];
            }

            if (isResizing) {
                document.body.style.cursor = 'default';
                resizeInitialRect = null;
                resizeInitialStates = [];
            }
            if (isPanning) {
                document.body.style.cursor = 'default';
            }
            
            if (isMarqueeSelecting && marqueeHasMoved) {
                finalizeMarqueeSelection();
            }
            if (isMarqueeSelecting) {
                isMarqueeSelecting = false;
                if(marqueeBox) marqueeBox.remove();
                marqueeBox = null;
            }

            isDragging = false;
            isResizing = false;
            isPanning = false;
            isDrawingArrow = false;
            arrowStartBlock = null;
            currentBlock = null;
            mouseDownTarget = null;

            if(wasDraggingOrResizing) {
                recordState();
            }

            // Limpa a classe de qualquer bloco que a tenha, garantindo a interatividade do iframe após o arraste.
            document.querySelectorAll('.is-held-down').forEach(b => b.classList.remove('is-held-down'));
        }

        function handleGlobalMouseDown(e) {
            if (!contextMenu.contains(e.target)) {
                 contextMenu.style.display = 'none';
            }
            if (document.getElementById('custom-color-picker') && !document.getElementById('custom-color-picker').classList.contains('hidden')) {
                if (!e.target.closest('#custom-color-picker') && !e.target.closest('.color-picker-wrapper')) {
                    colorPicker.hide();
                }
            }
            if (isEditing && activeEditingElement) {
                const currentBlockEl = activeEditingElement.closest('.block');
                if (!currentBlockEl.contains(e.target) && !e.target.closest('.sidebar') && !e.target.closest('#custom-color-picker')) {
                    finishEditing();
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        }

        function handleGridMouseDown(e) {
            mouseDownTarget = e.target;
            startX = e.clientX;
            startY = e.clientY;
            mouseMoved = false;
            const isGridElement = e.target === grid || e.target === svgCanvas || e.target === container;
            if (isGridElement) {
                if (e.shiftKey || e.button === 1) {
                    isPanning = true;
                    document.body.style.cursor = 'grabbing';
                    e.preventDefault(); 
                } else if (e.button === 0) {
                    isMarqueeSelecting = true;
                    marqueeHasMoved = false;
                    marqueeBox = document.createElement('div');
                    marqueeBox.className = 'marquee-box';
                    document.body.appendChild(marqueeBox);
                    marqueeStartX = e.clientX;
                    marqueeStartY = e.clientY;
                    marqueeBox.style.left = `${e.clientX}px`;
                    marqueeBox.style.top = `${e.clientY}px`;
                }
            }
        }

        function handleGridContextMenu(e) {
            e.preventDefault();
            deselectAll();
            showContextMenu(e.clientX, e.clientY, false);
        }

        function getAddSubMenuHTML() {
            return `
                <li class="menu-header" data-translate-key="menu_add">Adicionar</li>
                <li data-action="add-text" data-translate-key="menu_add_text">Bloco de Texto</li>
                <li class="has-submenu">
                    <span data-translate-key="menu_from_file">Do Arquivo ></span>
                    <ul class="submenu">
                        <li data-action="add-media-file" data-translate-key="menu_add_media">Imagem / Vídeo</li>
                        <li data-action="import-pdf-file" data-translate-key="menu_add_pdf">PDF como Slides</li>
                    </ul>
                </li>
                <li class="has-submenu">
                    <span data-translate-key="menu_from_link">Do Link ></span>
                    <ul class="submenu">
                        <li data-action="add-media-link" data-translate-key="menu_add_media">Imagem / Vídeo</li>
                        <li data-action="add-pdf-link" data-translate-key="menu_add_pdf">PDF como Slides</li>
                        <li data-action="add-desmos-link">Desmos</li>
                        <li data-action="add-geogebra-link">GeoGebra</li>
                        <li data-action="add-phet-link" data-translate-key="menu_add_phet">PhET Colorado</li>
                    </ul>
                </li>
            `;
        }


        function showContextMenu(x, y, isBlockMenu, contentType = 'full') {
            contextMenuX = x;
            contextMenuY = y;

            let menuHTML = '<ul>';

            if (contentType === 'add') {
                menuHTML += getAddSubMenuHTML();
            } else {
                 if (isBlockMenu) {
                    menuHTML += `
                        <li class="has-submenu">
                            <span data-translate-key="menu_move_to">Mover para ></span>
                            <ul class="submenu">
                                <li data-action="move-prev-slide" data-translate-key="menu_move_prev">Slide anterior</li>
                                <li data-action="move-next-slide" data-translate-key="menu_move_next">Próximo slide</li>
                                <li>
                                    <div class="submenu-input-group">
                                        <span data-translate-key="menu_move_specific">Slide nº:</span>
                                        <input type="number" id="move-slide-input" min="1" />
                                        <button id="move-slide-confirm">✓</button>
                                    </div>
                                </li>
                            </ul>
                        </li>
                        <li data-action="rename-block" data-translate-key="menu_rename">Renomear</li>
                        <li class="separator"></li>
                    `;
                }

                menuHTML += `
                    <li class="has-submenu">
                        <span data-translate-key="menu_add">Adicionar ></span>
                        <ul class="submenu">
                            ${getAddSubMenuHTML()}
                        </ul>
                    </li>
                `;
            }

            menuHTML += '</ul>';
            contextMenu.innerHTML = menuHTML;
            setLanguage(document.documentElement.lang);

            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';

            // Adicionar listeners dinamicamente
            contextMenu.querySelectorAll('[data-action]').forEach(item => {
                item.addEventListener('click', handleContextMenuClick);
            });
            
            const moveInput = document.getElementById('move-slide-input');
            const moveConfirm = document.getElementById('move-slide-confirm');

            if(moveInput && moveConfirm) {
                 moveConfirm.addEventListener('click', () => {
                    const pageNum = parseInt(moveInput.value);
                    moveSelectionToPage(pageNum);
                });
                moveInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const pageNum = parseInt(moveInput.value);
                        moveSelectionToPage(pageNum);
                    }
                });
            }
        }

        function handleContextMenuClick(e) {
            e.stopPropagation();
            const target = e.currentTarget;
            const action = target.dataset.action;
            if (!action) return;
            
            const actionMap = {
                // Ações de Mover
                'move-prev-slide': () => moveSelectionToPage(currentPageIndex), // 0-indexed
                'move-next-slide': () => moveSelectionToPage(currentPageIndex + 2), // 0-indexed
                'rename-block': () => startRenamingBlock(),

                // Ações de Adicionar
                'add-text': () => { 
                    lastBlockCreationAction = () => addNewBlock({ contentModel: [{ text: currentLangStrings.menu_add_text, style: {} }] });
                    lastBlockCreationAction();
                },
                'add-media-file': () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*,video/*';
                    lastBlockCreationAction = () => fileInput.click();
                    fileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = res => {
                                const dataUrl = res.target.result;
                                if (file.type.startsWith('image/')) {
                                    const img = new Image();
                                    img.onload = () => {
                                        const aspectRatio = img.height / img.width;
                                        const maxWidth = 800;
                                        const newWidth = Math.min(img.width, maxWidth);
                                        const newHeight = newWidth * aspectRatio;
                                        const html = `<img src="${dataUrl}" alt="User content">`;
                                        addNewBlock({ contentModel: [{ text: html, style: {}, isHTML: true }], width: `${newWidth}px`, height: `${newHeight}px` });
                                    };
                                    img.src = dataUrl;
                                } else if (file.type.startsWith('video/')) {
                                    const video = document.createElement('video');
                                    video.onloadedmetadata = () => {
                                        const aspectRatio = video.videoHeight / video.videoWidth;
                                        const maxWidth = 800;
                                        const newWidth = Math.min(video.videoWidth, maxWidth);
                                        const newHeight = newWidth * aspectRatio;
                                        const html = `<video src="${dataUrl}" controls></video>`;
                                        addNewBlock({ contentModel: [{ text: html, style: {}, isHTML: true }], width: `${newWidth}px`, height: `${newHeight}px` });
                                    };
                                    video.src = dataUrl;
                                }
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    lastBlockCreationAction();
                },
                 'import-pdf-file': () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.pdf';
                    fileInput.onchange = e => {
                        const file = e.target.files[0];
                        if (file) {
                            importPdfFromFile(file);
                        }
                    };
                    fileInput.click();
                },
                'add-media-link': () => {
                    const createMediaLinkBlock = () => {
                        const url = prompt(currentLangStrings.prompt_media_url);
                        if (!url) return;

                        let embedUrl;
                        if (url.includes('youtube.com/watch?v=')) embedUrl = `https://www.youtube.com/embed/${new URL(url).searchParams.get('v')}`;
                        else if (url.includes('youtu.be/')) embedUrl = `https://www.youtube.com/embed/${new URL(url).pathname.slice(1)}`;
                        else if (url.includes('vimeo.com/')) embedUrl = `https://player.vimeo.com/video/${new URL(url).pathname.slice(1)}`;
                        else if (url.includes('drive.google.com/file/d/')) {
                            const match = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
                            if (match && match[1]) embedUrl = `https://drive.google.com/file/d/${match[1]}/preview`;
                        }

                        if (embedUrl) {
                            addNewBlock({ contentModel: [{ text: `<iframe src="${embedUrl}" allow="autoplay; fullscreen"></iframe>`, style: {}, isHTML: true }], width: '560px', height: '315px' });
                        } else {
                            const img = new Image();
                            img.onload = () => {
                                const aspectRatio = img.height / img.width;
                                const maxWidth = 800;
                                const newWidth = Math.min(img.width, maxWidth);
                                const newHeight = newWidth * aspectRatio;
                                const html = `<img src="${url}" alt="User content">`;
                                addNewBlock({ contentModel: [{ text: html, style: {}, isHTML: true }], width: `${newWidth}px`, height: `${newHeight}px` });
                            };
                            img.onerror = () => {
                                showToast(currentLangStrings.toast_media_error);
                            };
                            img.src = url;
                        }
                    };
                    lastBlockCreationAction = createMediaLinkBlock;
                    lastBlockCreationAction();
                },
                'add-pdf-link': () => {
                    const createPdfLinkBlock = () => {
                        const url = prompt(currentLangStrings.prompt_pdf_url);
                        if (url) {
                            const name = url.substring(url.lastIndexOf('/') + 1);
                            showToast(currentLangStrings.toast_pdf_importing.replace('{name}', name), 5000);
                            fetch(url)
                                .then(response => {
                                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                                    return response.arrayBuffer();
                                })
                                .then(arrayBuffer => processPdfData(arrayBuffer, name))
                                .catch(e => {
                                    console.error("Error fetching PDF from URL:", e);
                                    showToast(currentLangStrings.toast_pdf_error);
                                });
                        }
                    };
                    lastBlockCreationAction = createPdfLinkBlock;
                    lastBlockCreationAction();
                },
                'add-desmos-link': () => {
                    const createDesmosBlock = () => {
                        const desmosUrl = prompt(currentLangStrings.prompt_desmos_url);
                        if (desmosUrl && desmosUrl.includes('desmos.com/calculator')) addNewBlock({ contentModel: [{ text: `<iframe src="${desmosUrl}"></iframe>`, style: {}, isHTML: true }], width: '600px', height: '400px' });
                        else if (desmosUrl) showToast('Invalid Desmos URL.');
                    };
                    lastBlockCreationAction = createDesmosBlock;
                    lastBlockCreationAction();
                },
                'add-geogebra-link': () => {
                    const createGeoGebraBlock = () => {
                        const geoGebraUrl = prompt(currentLangStrings.prompt_geogebra_url);
                        if (geoGebraUrl && geoGebraUrl.includes('geogebra.org')) {
                            addNewBlock({ contentModel: [{ text: `<iframe src="${geoGebraUrl}" style="border:0px;width:100%;height:100%;" allowfullscreen></iframe>`, style: {}, isHTML: true }], width: '600px', height: '450px' });
                        } else if (geoGebraUrl) {
                            showToast('Invalid GeoGebra URL.');
                        }
                    };
                    lastBlockCreationAction = createGeoGebraBlock;
                    lastBlockCreationAction();
                },
                'add-phet-link': () => {
                    const createPhetBlock = () => {
                        const phetUrl = prompt(currentLangStrings.prompt_phet_url);
                        if (phetUrl && phetUrl.includes('phet.colorado.edu')) {
                            addNewBlock({ contentModel: [{ text: `<iframe src="${phetUrl}" style="border:0px;width:100%;height:100%;" allowfullscreen scrolling="no"></iframe>`, style: {}, isHTML: true }], width: '800px', height: '600px' });
                        } else if (phetUrl) {
                            showToast('Invalid PhET Colorado URL.');
                        }
                    };
                    lastBlockCreationAction = createPhetBlock;
                    lastBlockCreationAction();
                }
            };

            if(actionMap[action]) actionMap[action]();
            contextMenu.style.display = 'none';
        }
        
        function handleArrowClick(e) {
            const group = e.target.closest('.arrow-group');
            if (group) {
                e.stopPropagation();
                updateSelection(group, e.shiftKey);
            }
        }

        function handleKeyDown(e) {
            const isInputFocused = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;
            if (isInputFocused && e.target !== document.body) {
                return;
            }

            if (colorPicker && !colorPicker.isHidden() && e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('color-picker-confirm').click();
                return;
            }
            if (colorPicker && !colorPicker.isHidden() && e.key === 'Escape') {
                e.preventDefault();
                document.getElementById('color-picker-cancel').click();
                return;
            }
            
            if (e.ctrlKey && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                e.preventDefault();
                redo();
            }

            if (e.key === 'ArrowRight' || e.key === 'PageDown') {
                e.preventDefault();
                goToNextPage();
            }
            if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                e.preventDefault();
                goToPrevPage();
            }

            if (e.key === 'Control') {
                ctrlPressed = true;
                if (!isArrowMode) {
                    document.body.classList.add('arrow-mode');
                }
            }
            if (e.key === 'Delete') {
                selection.forEach(item => {
                    if (item.classList.contains('block')) {
                        const blockId = item.id;
                        svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(a => {
                            const arrowLine = a.querySelector('.arrow-line');
                            if (arrowLine) {
                                const endMarkerUrl = arrowLine.getAttribute('marker-end');
                                if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();
                                const startMarkerUrl = arrowLine.getAttribute('marker-start');
                                if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();
                            }
                            a.remove();
                        });
                        item.remove();
                    } else if (item.classList.contains('arrow-group')) {
                        const arrowLine = item.querySelector('.arrow-line');
                        if (arrowLine) {
                            const endMarkerUrl = arrowLine.getAttribute('marker-end');
                            if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();
                            const startMarkerUrl = arrowLine.getAttribute('marker-start');
                            if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();
                        }
                        item.remove();
                    }
                });
                deselectAll();
                recordState();
                updateBlocksList(); 
            }
            if (e.key === 'F2' || e.key === 'r') {
                e.preventDefault();
                startRenamingBlock();
            }
            if (e.key === 'b' || e.key === 'B') {
                e.preventDefault();
                showSmartColorPicker();
            }
            if(e.key === 'g' || e.key === 'G') {
                e.preventDefault();
                sidebar.classList.toggle('hidden');
                document.body.classList.toggle('sidebar-hidden');
            }
            if(e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                coordsDisplay.classList.toggle('hidden');
            }
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                toggleParentMove();
            }
            if (e.shiftKey && e.key === '+') {
                e.preventDefault();
                addNewPage();
            }
            if(e.shiftKey && e.key === '-') {
                e.preventDefault();
                deleteCurrentPage();
            }
            if (e.shiftKey && (e.key === 'd' || e.key === 'D')) {
                e.preventDefault();
                if (selection.length > 0) duplicateSelection();
                else lastBlockCreationAction();
            }
            if (e.shiftKey && (e.key === 'a' || e.key === 'A')) {
                e.preventDefault();
                showContextMenu(lastMouseX, lastMouseY, false, 'add');
            }
            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); saveAllPages(); }
            if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) { e.preventDefault(); fileLoader.click(); }
            if (e.key === 'h' || e.key === 'H') { e.preventDefault(); shortcutHint.style.display = shortcutHint.style.display === 'none' ? 'block' : 'none'; }
        }

        function handleKeyUp(e) {
            if (e.key === 'Control') {
                ctrlPressed = false;
                if (!toggleArrowModeBtn.classList.contains('active')) {
                     document.body.classList.remove('arrow-mode');
                }
            }
        }
        
        function handleDynamicTextUpdate() {
            if (!isEditing || !activeEditingElement) return;
            const block = activeEditingElement.closest('.block');
            block.contentModel = parseContent(activeEditingElement);
            activeContentModel = JSON.parse(JSON.stringify(block.contentModel));
        }

        function startEditing(block) {
            const contentEl = block.querySelector('.block-content');
            if (contentEl.querySelector('iframe, video, img')) return;
            
            if (selection.length !== 1 || selection[0] !== block) {
                updateSelection(block, false);
            }

            sidebar.classList.remove('hidden');
            document.body.classList.remove('sidebar-hidden');
            isEditing = true;
            activeEditingElement = contentEl;
            activeContentModel = JSON.parse(JSON.stringify(block.contentModel)); 

            contentEl.contentEditable = true;
            contentEl.addEventListener('input', handleDynamicTextUpdate); 
            contentEl.focus();
            updateCustomizePanel();
        }

        function finishEditing() {
            if (!isEditing || !activeEditingElement) return;
            const block = activeEditingElement.closest('.block');
            
            activeEditingElement.removeEventListener('input', handleDynamicTextUpdate); 
            
            block.contentModel = parseContent(activeEditingElement);

            isEditing = false;
            activeEditingElement.contentEditable = false;
            activeEditingElement = null;
            activeContentModel = [];

            updateArrowsForBlock(block);
            recordState();
        }
        
        function resizeBlock(e) {
            if (!isResizing || !currentBlock || resizeInitialStates.length === 0) return;

            const dx = (e.clientX - startX) / scale;
            const dy = (e.clientY - startY) / scale;
            const gridSize = 30;
            const primaryState = resizeInitialStates.find(s => s.id === currentBlock.id);
            if (!primaryState) return;

            let dw = 0, dh = 0, dLeft = 0, dTop = 0;

            if (resizeDirection.includes('e')) dw = dx;
            if (resizeDirection.includes('w')) { dw = -dx; dLeft = dx; }
            if (resizeDirection.includes('s')) dh = dy;
            if (resizeDirection.includes('n')) { dh = -dy; dTop = dy; }

            let newWidth = primaryState.width + dw;
            let newHeight = primaryState.height + dh;
            let newLeft = primaryState.x + dLeft;
            let newTop = primaryState.y + dTop;

            if (isSnapEnabled) {
                if (resizeDirection.includes('e')) {
                    const newRight = primaryState.x + newWidth;
                    newWidth = (Math.round(newRight / gridSize) * gridSize) - primaryState.x;
                }
                if (resizeDirection.includes('w')) {
                    const snappedLeft = Math.round(newLeft / gridSize) * gridSize;
                    newWidth += (newLeft - snappedLeft);
                    newLeft = snappedLeft;
                }
                if (resizeDirection.includes('s')) {
                    const newBottom = primaryState.y + newHeight;
                    newHeight = (Math.round(newBottom / gridSize) * gridSize) - primaryState.y;
                }
                if (resizeDirection.includes('n')) {
                    const snappedTop = Math.round(newTop / gridSize) * gridSize;
                    newHeight += (newTop - snappedTop);
                    newTop = snappedTop;
                }
            }
            
            const finalDw = newWidth - primaryState.width;
            const finalDh = newHeight - primaryState.height;
            const finalDLeft = newLeft - primaryState.x;
            const finalDTop = newTop - primaryState.y;
            const minSize = 50;

            resizeInitialStates.forEach(state => {
                let memberNewWidth = state.width + finalDw;
                let memberNewHeight = state.height + finalDh;
                let memberNewLeft = state.x + finalDLeft;
                let memberNewTop = state.y + finalDTop;

                if (state.el) {
                    if (memberNewWidth >= minSize) {
                        state.el.style.width = `${memberNewWidth}px`;
                        state.el.style.left = `${memberNewLeft}px`;
                    }
                    if (memberNewHeight >= minSize) {
                        state.el.style.height = `${memberNewHeight}px`;
                        state.el.style.top = `${memberNewTop}px`;
                    }
                    updateArrowsForBlock(state.el);
                }

                const blockData = pages[state.pageIndex].blocks.find(b => b.id === state.id);
                if (blockData) {
                    if (memberNewWidth >= minSize) {
                        blockData.width = `${memberNewWidth}px`;
                        blockData.x = memberNewLeft;
                    }
                    if (memberNewHeight >= minSize) {
                        blockData.height = `${memberNewHeight}px`;
                        blockData.y = memberNewTop;
                    }
                }
            });
        }

        function dragBlock(e) {
            const dx = (e.clientX - startX) / scale;
            const dy = (e.clientY - startY) / scale;
            const gridSize = 30;

            dragInitialPositions.forEach(pos => {
                const newX = pos.x + dx;
                const newY = pos.y + dy;
                
                let finalX, finalY;
                if (isSnapEnabled) {
                    finalX = Math.max(0, Math.round(newX / gridSize) * gridSize);
                    finalY = Math.max(0, Math.round(newY / gridSize) * gridSize);
                } else {
                    finalX = Math.max(0, newX);
                    finalY = Math.max(0, newY);
                }

                // Update the DOM element if it's on the current page
                if (pos.el) {
                    pos.el.style.left = `${finalX}px`;
                    pos.el.style.top = `${finalY}px`;
                    updateArrowsForBlock(pos.el);
                }
                
                // Update the data model for all blocks in the drag group,
                // regardless of which page they are on.
                const blockData = pages[pos.pageIndex].blocks.find(b => b.id === pos.id);
                if (blockData) {
                    blockData.x = finalX;
                    blockData.y = finalY;
                }
            });

            updateCoordinates();
        }
        
        function panGrid(e) {
            gridX = Math.min(0, gridX + e.movementX);
            gridY = Math.min(0, gridY + e.movementY);
            updateGridTransform();
        }

        function handleZoom(e) {
            if (e.target.closest('.sidebar')) return;
            e.preventDefault();
            const scaleAmount = 0.05;
            let mousePoint = screenToGridCoords(e.clientX, e.clientY);
            
            if (gridX === 0) mousePoint.x = 0;
            if (gridY === 0) mousePoint.y = 0;
            
            const oldScale = scale;
            if (e.deltaY < 0) scale += scaleAmount;
            else scale -= scaleAmount;
            
            scale = Math.max(0.1, Math.min(scale, 3));

            gridX += mousePoint.x * (oldScale - scale);
            gridY += mousePoint.y * (oldScale - scale);
            
            gridX = Math.min(0, gridX);
            gridY = Math.min(0, gridY);

            updateGridTransform();
            updateCoordinates(e);
        }

        function toggleArrowMode() {
            isArrowMode = !isArrowMode;
            document.body.classList.toggle('arrow-mode', isArrowMode);
            toggleArrowModeBtn.classList.toggle('active', isArrowMode);
        }

        function startArrow(e, block) {
            document.body.classList.add('is-drawing-arrow');
            const startPoint = getBlockCenter(block);
            const tempGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tempArrow.setAttribute('x1', startPoint.x); 
            tempArrow.setAttribute('y1', startPoint.y);
            tempArrow.setAttribute('x2', startPoint.x); 
            tempArrow.setAttribute('y2', startPoint.y);
            tempArrow.setAttribute('stroke', '#3498db'); 
            tempArrow.setAttribute('stroke-width', '3');

            const marker = createOrUpdateMarker('temp-arrowhead', '#3498db', 10);
            marker.setAttribute('orient', 'auto');
            tempArrow.setAttribute('marker-end', 'url(#temp-arrowhead)');

            tempGroup.appendChild(tempArrow);
            svgCanvas.appendChild(tempGroup);
        }

        function drawArrow(e) {
            if (!tempArrow) return;
            const coords = screenToGridCoords(e.clientX, e.clientY);
            tempArrow.setAttribute('x2', coords.x);
            tempArrow.setAttribute('y2', coords.y);
        }
        
        let cr='Right to copy: Bernardo Teixeira Mendonça - 09/072024';

        function endArrow(e) {
            const tempGroup = tempArrow.parentElement;
            if (!mouseMoved) {
                tempGroup?.remove();
                document.getElementById('temp-arrowhead')?.remove();
                tempArrow = null;
                document.body.classList.remove('is-drawing-arrow');
                return;
            }

            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const endBlock = elementUnderCursor ? elementUnderCursor.closest('.block') : null;

            const reverseArrow = endBlock ? svgCanvas.querySelector(`.arrow-group[data-start-block="${endBlock.id}"][data-end-block="${arrowStartBlock.id}"]`) : null;

            if (reverseArrow) {
                const reverseLine = reverseArrow.querySelector('.arrow-line');
                const color = reverseLine.getAttribute('stroke');
                const strokeWidth = parseFloat(reverseLine.getAttribute('stroke-width')) || 3;
                const headSize = strokeWidth * 3 + 5;
                
                const startMarkerId = `arrowhead-start-${endBlock.id}-${arrowStartBlock.id}`;
                const marker = createOrUpdateMarker(startMarkerId, color, headSize);
                marker.setAttribute('orient', 'auto-start-reverse');
                
                reverseLine.setAttribute('marker-start', `url(#${startMarkerId})`);
                reverseArrow.dataset.bidirectional = 'true';
                
                tempGroup?.remove();
                recordState();

            } else if (endBlock && endBlock !== arrowStartBlock) {
                const arrowExists = svgCanvas.querySelector(`.arrow-group[data-start-block="${arrowStartBlock.id}"][data-end-block="${endBlock.id}"]`);
                if (arrowExists) {
                    tempGroup?.remove();
                } else {
                    const arrowLine = tempArrow;
                    const color = arrowLine.getAttribute('stroke');
                    const strokeWidth = parseFloat(arrowLine.getAttribute('stroke-width')) || 3;
                    const headSize = strokeWidth * 3 + 5;
                    
                    const markerId = `arrowhead-end-${arrowStartBlock.id}-${endBlock.id}`;
                    const marker = createOrUpdateMarker(markerId, color, headSize);
                    marker.setAttribute('orient', 'auto');
                    arrowLine.setAttribute('marker-end', `url(#${markerId})`);

                    tempGroup.classList.add('arrow-group');
                    tempGroup.dataset.startBlock = arrowStartBlock.id;
                    tempGroup.dataset.endBlock = endBlock.id;
                    
                    arrowLine.classList.add('arrow-line');
                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hitbox.classList.add('arrow-hitbox');
                    tempGroup.appendChild(hitbox);
                    updateSingleArrow(tempGroup);
                    if (selection.includes(arrowStartBlock) && selection.includes(endBlock)) {
                        updateSelection(tempGroup, true);
                    }
                    recordState();
                }
            } else { 
                tempGroup?.remove(); 
            }
            
            document.getElementById('temp-arrowhead')?.remove();
            tempArrow = null;
            document.body.classList.remove('is-drawing-arrow');
        }
        
        function updateMarquee(e) {
            if (!marqueeBox) return;
            const x = Math.min(e.clientX, marqueeStartX);
            const y = Math.min(e.clientY, marqueeStartY);
            const width = Math.abs(e.clientX - marqueeStartX);
            const height = Math.abs(e.clientY - marqueeStartY);
            marqueeBox.style.left = `${x}px`;
            marqueeBox.style.top = `${y}px`;
            marqueeBox.style.width = `${width}px`;
            marqueeBox.style.height = `${height}px`;

            const marqueeRect = marqueeBox.getBoundingClientRect();
            document.querySelectorAll('.block').forEach(block => {
                const blockRect = block.getBoundingClientRect();
                const isIntersecting = !(marqueeRect.right < blockRect.left ||
                                        marqueeRect.left > blockRect.right ||
                                        marqueeRect.bottom < blockRect.top ||
                                        marqueeRect.top > blockRect.bottom);
                block.classList.toggle('pre-selected', isIntersecting);
            });
        }

        function finalizeMarqueeSelection() {
            deselectAll();
            const newlySelected = [];
            document.querySelectorAll('.block.pre-selected').forEach(block => {
                block.classList.remove('pre-selected');
                block.classList.add('selected');
                newlySelected.push(block);
            });
            selection = newlySelected;
            if (selection.length > 0) {
                lastSelectedItem = selection[selection.length - 1];
            }
            updateUIState();
        }

        function createOrUpdateMarker(id, color, size = 10) {
            let marker = document.getElementById(id);
            if (!marker) {
                marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', id);
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                marker.appendChild(polygon);
                svgDefs.appendChild(marker);
            }
            const width = Number(size);
            const height = width * 0.7;
            
            marker.setAttribute('markerWidth', width);
            marker.setAttribute('markerHeight', height);
            marker.setAttribute('refX', width * 0.9);
            marker.setAttribute('refY', height / 2);
            
            const polygon = marker.querySelector('polygon');
            polygon.setAttribute('points', `0 0, ${width} ${height / 2}, 0 ${height}`);
            polygon.setAttribute('fill', color);
            return marker;
        }

        function updateSingleArrow(arrowGroup) {
            const startBlock = document.getElementById(arrowGroup.dataset.startBlock);
            const endBlock = document.getElementById(arrowGroup.dataset.endBlock);
            if (!startBlock || !endBlock) return;
            const arrowLine = arrowGroup.querySelector('.arrow-line');
            const hitbox = arrowGroup.querySelector('.arrow-hitbox');
            if (!arrowLine || !hitbox) return;
            
            const startPoint = getClosestConnectionPoint(startBlock, endBlock);
            const endPoint = getClosestConnectionPoint(endBlock, startBlock);

            [arrowLine, hitbox].forEach(el => {
                el.setAttribute('x1', startPoint.x); 
                el.setAttribute('y1', startPoint.y);
                el.setAttribute('x2', endPoint.x); 
                el.setAttribute('y2', endPoint.y);
            });
            
            const color = arrowLine.getAttribute('stroke') || '#3498db';
            const strokeWidth = parseFloat(arrowLine.getAttribute('stroke-width')) || 3;
            const headSize = strokeWidth * 3 + 5; 
            
            const endMarkerUrl = arrowLine.getAttribute('marker-end');
            if (endMarkerUrl) {
                createOrUpdateMarker(endMarkerUrl.slice(5, -1), color, headSize);
            }
            const startMarkerUrl = arrowLine.getAttribute('marker-start');
            if (startMarkerUrl) {
                createOrUpdateMarker(startMarkerUrl.slice(5, -1), color, headSize);
            }
        }

        function updateArrowsForBlock(block) {
            const blockId = block.id;
            svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(updateSingleArrow);
        }

        function updateCoordinates(e = null) {
            if (isEditingCoords) return;
            if (selection.length > 1) {
                coordsDisplay.innerHTML = `${selection.length} ${currentLangStrings.coords_items} | Z: ${Math.round(scale * 100)}%`;
            } else if (selection.length === 1) {
                const item = selection[0];
                if (item.classList.contains('block')) {
                    const x = parseInt(item.style.left);
                    const y = parseInt(item.style.top);
                    coordsDisplay.innerHTML = `X: ${x}, Y: ${y} | Z: ${Math.round(scale * 100)}%`;
                } else if (item.classList.contains('arrow-group')) {
                    coordsDisplay.innerHTML = `${currentLangStrings.coords_arrow} | Z: ${Math.round(scale * 100)}%`;
                }
            } else if (e) {
                const mouseCoords = screenToGridCoords(e.clientX, e.clientY);
                coordsDisplay.innerHTML = `X: ${Math.round(mouseCoords.x)}, Y: ${Math.round(mouseCoords.y)} | Z: ${Math.round(scale * 100)}%`;
            } else {
                coordsDisplay.innerHTML = `${currentLangStrings.coords_nothing} | Z: ${Math.round(scale * 100)}%`;
            }
        }
        
        function editCoordinates(e) {
            if (e.target.tagName === 'INPUT' || isEditingCoords) return;
            e.stopPropagation();

            const blockToEdit = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : null;
            if (!blockToEdit) return;

            isEditingCoords = true;

            const x = parseInt(blockToEdit.style.left); 
            const y = parseInt(blockToEdit.style.top);
            coordsDisplay.innerHTML = `X: <input type="number" value="${x}" id="coord-x"> Y: <input type="number" value="${y}" id="coord-y">`;
            
            const inputX = document.getElementById('coord-x'); 
            const inputY = document.getElementById('coord-y');
            inputX.focus(); 
            inputX.select();

            const applyAndClose = () => {
                const newX = parseInt(inputX.value || 0);
                const newY = parseInt(inputY.value || 0);
                const gridSize = 30;
                blockToEdit.style.left = `${Math.max(0, Math.round(newX / gridSize) * gridSize)}px`;
                blockToEdit.style.top = `${Math.max(0, Math.round(newY / gridSize) * gridSize)}px`;
                
                isEditingCoords = false;
                updateArrowsForBlock(blockToEdit); 
                updateCoordinates();
                document.removeEventListener('click', handleClickOutside, true);
                document.removeEventListener('keydown', handleInputKeyDown, true);
                recordState();
            };

            const handleInputKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    applyAndClose();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    isEditingCoords = false;
                    updateCoordinates(); 
                    document.removeEventListener('click', handleClickOutside, true);
                    document.removeEventListener('keydown', handleInputKeyDown, true);
                }
            };

            const handleClickOutside = (e) => {
                if (!coordsDisplay.contains(e.target)) {
                    applyAndClose();
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', handleClickOutside, true);
                document.addEventListener('keydown', handleInputKeyDown, true);
            }, 0);
        }

        const nonColorInputs = {
            handleVisible: document.getElementById('handle-visible'),
            textSize: document.getElementById('text-size'),
            textFont: document.getElementById('text-font'),
            linkSrc: document.getElementById('link-src'),
            arrowWidth: document.getElementById('arrow-width'),
            boldBtn: document.getElementById('bold-btn'),
            italicBtn: document.getElementById('italic-btn'),
            underlineBtn: document.getElementById('underline-btn'),
        };
        const controlGroups = {
            block: document.getElementById('block-controls'), 
            handle: document.getElementById('handle-controls'),
            text: document.getElementById('text-controls'), 
            link: document.getElementById('link-controls'),
            arrow: document.getElementById('arrow-controls'),
            grid: document.getElementById('grid-controls')
        }

        function updateCustomizePanel() {
            const hasBlock = selection.some(item => item.classList.contains('block'));
            const hasArrow = selection.some(item => item.classList.contains('arrow-group'));
            const lastSelectedBlock = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : selection.find(i => i.classList.contains('block'));
            const hasIframe = lastSelectedBlock?.querySelector('iframe');
            
            controlGroups.block.classList.toggle('hidden', !hasBlock);
            controlGroups.handle.classList.toggle('hidden', !hasBlock);
            controlGroups.arrow.classList.toggle('hidden', !hasArrow);
            controlGroups.grid.classList.toggle('hidden', hasBlock || hasArrow);
            
            controlGroups.text.classList.toggle('hidden', !hasBlock || hasIframe);
            controlGroups.link.classList.toggle('hidden', !hasIframe);

            if (hasBlock && lastSelectedBlock) {
                const computed = getComputedStyle(lastSelectedBlock);
                document.querySelector('[data-color-target="blockBg"]').style.background = computed.backgroundColor;
                document.querySelector('[data-color-target="blockBorder"]').style.background = computed.borderColor;
                document.querySelector('[data-color-target="handle"]').style.background = computed.getPropertyValue('--handle-color').trim() || '#808080';
                
                nonColorInputs.handleVisible.checked = computed.getPropertyValue('--handle-display').trim() !== 'none';
                
                updateFamilySelectDropdown();
                const familyId = lastSelectedBlock.dataset.familyId || 'none';
                familySelect.value = familyId;

                if (hasIframe) {
                    nonColorInputs.linkSrc.value = hasIframe.src;
                } else {
                    if (isEditing) updateTextControlsOnSelectionChange();
                    else { 
                        const styles = getStyleOfFirstCharacter(lastSelectedBlock.contentModel);
                        document.querySelector('[data-color-target="text"]').style.background = styles.color || '#f9fafb';
                    }
                }
            }
            if (hasArrow) {
                const arrowToSample = lastSelectedItem?.classList.contains('arrow-group') ? lastSelectedItem : selection.find(i => i.classList.contains('arrow-group'));
                if (arrowToSample) {
                    const arrowLine = arrowToSample.querySelector('.arrow-line');
                    const color = arrowLine.getAttribute('stroke') || '#f9fafb';
                    document.querySelector('[data-color-target="arrow"]').style.background = color;
                    nonColorInputs.arrowWidth.value = arrowLine.getAttribute('stroke-width');
                }
            }
            
            const bodyStyle = getComputedStyle(document.body);
            const gridStyle = getComputedStyle(grid);

            document.querySelector('[data-color-target="gridBg"]').style.background = bodyStyle.backgroundImage;
            const gridLineColorMatch = gridStyle.backgroundImage.match(/rgba?\((\d+,\s*\d+,\s*\d+,\s*[\d.]+)\)/);
            document.querySelector('[data-color-target="gridLines"]').style.background = gridLineColorMatch ? `rgb(${gridLineColorMatch[1]})` : 'rgba(255,255,255,0.1)';
        }

        nonColorInputs.boldBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ fontWeight: 'bold' }); });
        nonColorInputs.italicBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ fontStyle: 'italic' }); });
        nonColorInputs.underlineBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ textDecoration: 'underline' }); });
        nonColorInputs.textSize.addEventListener('change', e => applyStyleToSelection({ fontSize: `${e.target.value}px` }));
        nonColorInputs.textFont.addEventListener('change', e => applyStyleToSelection({ fontFamily: e.target.value }));
        
        nonColorInputs.handleVisible.addEventListener('change', e => {
            const value = e.target.checked ? 'block' : 'none';
            selection.forEach(i => i.classList.contains('block') && i.style.setProperty('--handle-display', value));
            recordState();
        });
        
        nonColorInputs.linkSrc.addEventListener('change', recordState);

        const updateSelectedArrows = (widthValue) => {
            selection.forEach(item => {
                if (item.classList.contains('arrow-group')) {
                    const arrowLine = item.querySelector('.arrow-line');
                    arrowLine.setAttribute('stroke-width', widthValue);
                    updateSingleArrow(item);
                }
            });
        };

        nonColorInputs.arrowWidth.addEventListener('input', e => updateSelectedArrows(e.target.value));
        nonColorInputs.arrowWidth.addEventListener('change', recordState);


        function updateTextControlsOnSelectionChange() {
            if (!isEditing || !activeEditingElement) return;

            const selection = window.getSelection();
            if (selection.rangeCount === 0 || selection.isCollapsed) {
                const { index } = getSelectionIndices(activeEditingElement);
                const styles = getStyleAtCharacterIndex(index > 0 ? index - 1 : 0);
                updateToolbarUI(styles);
                return;
            };

            const styles = getCommonStyleInSelection();
            updateToolbarUI(styles);
        }

        function updateToolbarUI(styles) {
            if (!styles) return;
            nonColorInputs.boldBtn.classList.toggle('active', styles.fontWeight === 'bold');
            nonColorInputs.italicBtn.classList.toggle('active', styles.fontStyle === 'italic');
            nonColorInputs.underlineBtn.classList.toggle('active', styles.textDecoration === 'underline');

            const currentSize = Math.round(parseFloat(styles.fontSize)) || 15;
            let closestOption = nonColorInputs.textSize.options[0];
            for (const option of nonColorInputs.textSize.options) {
                if (Math.abs(option.value - currentSize) <= Math.abs(closestOption.value - currentSize)) {
                    closestOption = option;
                }
            }
            nonColorInputs.textSize.value = closestOption.value;

            const fontOption = Array.from(nonColorInputs.textFont.options).find(opt => (styles.fontFamily || "").includes(opt.value));
            nonColorInputs.textFont.value = fontOption ? fontOption.value : nonColorInputs.textFont.options[0].value;
            
            document.querySelector('[data-color-target="text"]').style.background = styles.color || '#f9fafb';
        }

        let colorPicker = null;
        function initializeColorPickers() {
            colorPicker = createColorPicker();
            document.querySelectorAll('.color-picker-wrapper').forEach(wrapper => {
                wrapper.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const targetType = wrapper.dataset.colorTarget;
                    let initialColor = wrapper.style.backgroundColor || 'rgba(255, 255, 255, 1)';

                    colorPicker.show(initialColor, (newColor) => {
                        handleColorConfirm(targetType, newColor);
                        recordState();
                    });
                    
                    const rect = wrapper.getBoundingClientRect();
                    colorPicker.setPosition(rect.left - 250, rect.top);
                });
            });
        }
        
        function handleColorConfirm(targetType, color) {
            const actions = {
                'blockBg': () => selection.forEach(item => {
                    if (item.classList.contains('block')) {
                        item.style.backgroundColor = color;
                        updateBlockNameDisplay(item);
                    }
                }),
                'blockBorder': () => selection.forEach(item => item.classList.contains('block') && (item.style.borderColor = color)),
                'handle': () => selection.forEach(item => item.classList.contains('block') && item.style.setProperty('--handle-color', color)),
                'text': () => applyStyleToSelection({ color: color }),
                'arrow': () => selection.forEach(item => { if (item.classList.contains('arrow-group')) { item.querySelector('.arrow-line').setAttribute('stroke', color); updateSingleArrow(item); }}),
                'gridBg': () => document.body.style.background = color,
                'gridLines': () => grid.style.backgroundImage = `radial-gradient(${color} 1px, transparent 1px)`
            };

            if (actions[targetType]) {
                actions[targetType]();
                updateCustomizePanel();
            }
        }

        function showSmartColorPicker() {
            let targetType = 'gridBg';
            let initialColor = document.body.style.background;

            if (isEditing && activeEditingElement) {
                targetType = 'text';
                initialColor = getCommonStyleInSelection()?.color || '#f9fafb';
            } else if (lastSelectedItem?.classList.contains('block')) {
                targetType = 'blockBg';
                initialColor = getComputedStyle(lastSelectedItem).backgroundColor;
            } else if (lastSelectedItem?.classList.contains('arrow-group')) {
                targetType = 'arrow';
                initialColor = lastSelectedItem.querySelector('.arrow-line').getAttribute('stroke');
            }
            
            colorPicker.show(initialColor, (newColor) => {
                handleColorConfirm(targetType, newColor);
                recordState();
            });
            colorPicker.setPosition(lastMouseX, lastMouseY);
        }

        function recordState() {
            saveCurrentPageState(); 
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const state = {
                pages: JSON.parse(JSON.stringify(pages)),
                currentPageIndex: currentPageIndex,
                families: JSON.parse(JSON.stringify(families)),
                blockCounter: blockCounter
            };
            history.push(state);
            if (history.length > MAX_HISTORY_STATES) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function loadState(state) {
            if (!state) return;
            pages = JSON.parse(JSON.stringify(state.pages));
            families = state.families ? JSON.parse(JSON.stringify(state.families)) : [];
            currentPageIndex = state.currentPageIndex;
            blockCounter = state.blockCounter || blockCounter;
            loadPage(currentPageIndex, true);
            renderFamiliesList();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        function saveCurrentPageState() {
            if (isEditing) finishEditing();
            if (pages.length === 0 || currentPageIndex < 0) return;
            pages[currentPageIndex] = {
                blocks: Array.from(document.querySelectorAll('.block')).map(block => ({
                    id: block.id,
                    name: block.dataset.name,
                    contentModel: block.contentModel,
                    x: parseInt(block.style.left),
                    y: parseInt(block.style.top),
                    width: block.style.width,
                    height: block.style.height,
                    bgColor: block.style.backgroundColor,
                    borderColor: block.style.borderColor,
                    zIndex: parseInt(block.style.zIndex) || 0,
                    handleColor: block.style.getPropertyValue('--handle-color'),
                    handleDisplay: block.style.getPropertyValue('--handle-display'),
                    familyId: block.dataset.familyId
                })),
                arrows: Array.from(svgCanvas.querySelectorAll('.arrow-group')).map(arrowGroup => {
                    const arrowLine = arrowGroup.querySelector('.arrow-line');
                    return {
                        startBlock: arrowGroup.dataset.startBlock,
                        endBlock: arrowGroup.dataset.endBlock,
                        color: arrowLine.getAttribute('stroke'),
                        width: arrowLine.getAttribute('stroke-width'),
                        bidirectional: arrowGroup.dataset.bidirectional === 'true',
                    };
                }),
                styles: {
                    gridBg: document.body.style.background,
                    gridLines: grid.style.backgroundImage,
                },
                viewport: { gridX, gridY, scale }
            };
        }

        function loadPage(index, isFirstLoad = false) {
            if (!isFirstLoad && currentPageIndex >= 0) {
                saveCurrentPageState();
            }
            if (index < 0 || index >= pages.length) return;

            currentPageIndex = index;
            const pageState = pages[currentPageIndex];
            applyPageState(pageState, isFirstLoad);
            updatePageUI();
        }

        function applyPageState(state, isFirstLoad = false) {
            document.querySelectorAll('.block').forEach(b => b.remove());
            svgCanvas.querySelectorAll('.arrow-group').forEach(ag => ag.remove());
            
            const glowFilter = svgDefs.querySelector('#selection-glow');
            svgDefs.innerHTML = '';
            if (glowFilter) svgDefs.appendChild(glowFilter);

            deselectAll();
            
            gridX = state.viewport?.gridX || 0;
            gridY = state.viewport?.gridY || 0;
            
            if (isFirstLoad) {
                scale = state.viewport?.scale || 1;
            }
            updateGridTransform();

            document.body.style.background = state.styles?.gridBg || 'linear-gradient(90deg, var(--background-start), var(--background-end), var(--background-start))';
            grid.style.backgroundImage = state.styles?.gridLines || `radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px)`;
            
            let maxId = 0;
            if (state.blocks && Array.isArray(state.blocks)) {
                state.blocks.forEach(b => {
                    if (b && b.id) {
                        const idNum = parseInt(b.id.split('-')[1]);
                        if (!isNaN(idNum) && idNum > maxId) maxId = idNum;
                    }
                });
            }
             blockCounter = Math.max(blockCounter, maxId + 1);


            if (state.blocks && Array.isArray(state.blocks)) {
                state.blocks.forEach(blockConfig => {
                    if(blockConfig) createBlock(blockConfig);
                });
            }
            if (state.arrows && Array.isArray(state.arrows)) {
                state.arrows.forEach(arrowData => {
                    if(arrowData) {
                        const startBlock = document.getElementById(arrowData.startBlock);
                        const endBlock = document.getElementById(arrowData.endBlock);
                        if (startBlock && endBlock) createArrow(arrowData);
                    }
                });
            }
        }
        
        function updatePageUI() {
            pageDisplay.textContent = `Slide ${currentPageIndex + 1} / ${pages.length}`;
            prevPageBtn.disabled = currentPageIndex === 0;
            nextPageBtn.disabled = currentPageIndex >= pages.length - 1;
            deletePageBtn.disabled = pages.length <= 1;
            updateBlocksList();
        }

        function addNewPage() {
            saveCurrentPageState();
            const newPage = {
                blocks: [],
                arrows: [],
                viewport: { gridX: 0, gridY: 0, scale: 1 },
                styles: {
                    gridBg: document.body.style.background,
                    gridLines: grid.style.backgroundImage,
                }
            };
            pages.push(newPage);
            loadPage(pages.length - 1);
            recordState();
            showToast(currentLangStrings.toast_page_added.replace('{page}', pages.length));
        }

        function deleteCurrentPage() {
            if (pages.length <= 1) {
                showToast(currentLangStrings.toast_cant_delete_last);
                return;
            }
            const pageHasContent = pages[currentPageIndex] && pages[currentPageIndex].blocks.length > 0;
            let confirmed = true;
            if (pageHasContent) {
                confirmed = window.confirm("Este slide tem conteúdo. Tem certeza que deseja deletá-lo?");
            }

            if (confirmed) {
                const deletedPageIndex = currentPageIndex + 1;
                pages.splice(currentPageIndex, 1);
                const newIndex = Math.min(currentPageIndex, pages.length - 1);
                loadPage(newIndex, true); 
                recordState();
                showToast(currentLangStrings.toast_page_deleted.replace('{page}', deletedPageIndex));
            }
        }
        
        function goToNextPage() {
            if (currentPageIndex < pages.length - 1) loadPage(currentPageIndex + 1);
        }
        function goToPrevPage() {
            if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
        }

        function importPdfFromFile(file) {
            const fileReader = new FileReader();
            fileReader.onload = function() {
                processPdfData(this.result, file.name);
            };
            fileReader.readAsArrayBuffer(file);
        }

        async function processPdfData(pdfData, sourceName) {
            showToast(currentLangStrings.toast_pdf_importing.replace('{name}', sourceName), 10000);
            try {
                let familyName = sourceName.replace(/\.pdf$/i, '') || "PDF Importado";
                let originalFamilyName = familyName;
                let counter = 1;
                while (families.some(f => f.name === familyName)) {
                    familyName = `${originalFamilyName} (${counter++})`;
                }

                const newFamily = {
                    id: `family-${Date.now()}`,
                    name: familyName
                };
                families.push(newFamily);

                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;

                const wasEmpty = pages.length === 1 && pages[0].blocks.length === 0;
                if (wasEmpty) {
                    pages.shift();
                } else {
                    saveCurrentPageState();
                }

                const importStartIndex = pages.length;

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const renderScale = 2.0;
                    const viewport = page.getViewport({ scale: renderScale });
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = { canvasContext: context, viewport: viewport };
                    await page.render(renderContext).promise;

                    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    
                    const maxWidth = 1200;
                    const blockWidth = viewport.width / renderScale > maxWidth ? maxWidth : viewport.width / renderScale;
                    const blockHeight = blockWidth * (viewport.height / viewport.width);

                    const gridCenter = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);
                    const blockX = Math.max(0, gridCenter.x - blockWidth / 2);
                    const blockY = Math.max(0, gridCenter.y - blockHeight / 2);
                    
                    const imageHtml = `<img src="${imageDataUrl}" style="width:100%; height:100%;" alt="PDF Page ${i}">`;
                    
                    const newPage = {
                        blocks: [{
                            x: blockX,
                            y: blockY,
                            width: `${blockWidth}px`,
                            height: `${blockHeight}px`,
                            name: `Slide ${i} - ${familyName}`,
                            contentModel: [{ text: imageHtml, style: {}, isHTML: true }],
                            id: `block-slide-${importStartIndex + i - 1}-${blockCounter++}`,
                            familyId: newFamily.id
                        }],
                        arrows: [],
                        viewport: { gridX: 0, gridY: 0, scale: 1 },
                        styles: {
                            gridBg: document.body.style.background,
                            gridLines: grid.style.backgroundImage,
                        }
                    };
                    pages.push(newPage);
                }

                loadPage(importStartIndex, true);
                renderFamiliesList();
                updateFamilySelectDropdown();
                recordState();
                showToast(currentLangStrings.toast_pdf_success.replace('{numPages}', pdf.numPages), 3000);
            } catch (error) {
                console.error('Error importing PDF:', error);
                showToast(currentLangStrings.toast_pdf_error, 3000);
            }
        }

        function saveAllPages() {
            saveCurrentPageState();
            const state = {
                formatVersion: "3.2", // Updated version for block names
                pages: pages,
                families: families,
                blockCounter: blockCounter
            };
            download('mentmap-presentation.json', JSON.stringify(state, null, 2));
        }

        function loadAllPages(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (loadedData.pages && Array.isArray(loadedData.pages)) {
                        pages = loadedData.pages;
                        families = loadedData.families || [];
                        blockCounter = loadedData.blockCounter || 1;
                    } else {
                        // Legacy format
                        pages = [loadedData];
                        families = [];
                        blockCounter = 1;
                    }
                    // Ensure blocks have names for backward compatibility
                    pages.forEach(page => {
                        page.blocks.forEach(block => {
                            if (!block.name) {
                                block.name = `Bloco ${block.id.split('-')[1]}`;
                            }
                        })
                    });
                    loadPage(0, true);
                    renderFamiliesList();
                    history = [];
                    historyIndex = -1;
                    recordState();
                    showToast(currentLangStrings.toast_file_loaded);
                } catch (err) {
                    console.error('Error parsing JSON:', err);
                    showToast(currentLangStrings.toast_file_error);
                }
            };
            reader.readAsText(file);
            fileLoader.value = '';
        }

        function duplicateSelection() {
            const idMap = new Map();
            const newSelection = [];
            const offset = 30;
            const selectedBlocks = selection.filter(item => item.classList.contains('block'));
            const selectedArrows = selection.filter(item => item.classList.contains('arrow-group'));
            const newZIndex = findHighestZIndex() + 1;

            selectedBlocks.forEach(block => {
                const config = {
                    x: parseInt(block.style.left) + offset,
                    y: parseInt(block.style.top) + offset,
                    width: block.style.width,
                    height: block.style.height,
                    contentModel: JSON.parse(JSON.stringify(block.contentModel)),
                    name: `${block.dataset.name} (cópia)`,
                    bgColor: block.style.backgroundColor,
                    borderColor: block.style.borderColor,
                    zIndex: newZIndex,
                    handleColor: block.style.getPropertyValue('--handle-color'),
                    handleDisplay: block.style.getPropertyValue('--handle-display'),
                    familyId: block.dataset.familyId
                };
                const newBlock = createBlock(config);
                idMap.set(block.id, newBlock.id);
                newSelection.push(newBlock);
            });

            selectedArrows.forEach(arrow => {
                const startId = arrow.dataset.startBlock;
                const endId = arrow.dataset.endBlock;
                if (idMap.has(startId) && idMap.has(endId)) {
                    const arrowLine = arrow.querySelector('.arrow-line');
                    const newArrowData = {
                        startBlock: idMap.get(startId),
                        endBlock: idMap.get(endId),
                        color: arrowLine.getAttribute('stroke'),
                        width: arrowLine.getAttribute('stroke-width'),
                        bidirectional: arrow.dataset.bidirectional === 'true',
                    };
                    const newArrowGroup = createArrow(newArrowData);
                    newSelection.push(newArrowGroup);
                }
            });

            deselectAll();
            newSelection.forEach(item => updateSelection(item, true));
            recordState();
        }

        function createArrow(arrowData) {
            const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            arrowGroup.classList.add('arrow-group');
            arrowGroup.dataset.startBlock = arrowData.startBlock;
            arrowGroup.dataset.endBlock = arrowData.endBlock;
            
            const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            arrowLine.classList.add('arrow-line');
            arrowLine.setAttribute('stroke', arrowData.color);
            arrowLine.setAttribute('stroke-width', arrowData.width);

            const strokeWidth = parseFloat(arrowData.width) || 3;
            const headSize = strokeWidth * 3 + 5;

            const endMarkerId = `arrowhead-end-${arrowData.startBlock}-${arrowData.endBlock}`;
            let marker = createOrUpdateMarker(endMarkerId, arrowData.color, headSize);
            marker.setAttribute('orient', 'auto');
            arrowLine.setAttribute('marker-end', `url(#${endMarkerId})`);

            if (arrowData.bidirectional) {
                arrowGroup.dataset.bidirectional = 'true';
                const startMarkerId = `arrowhead-start-${arrowData.startBlock}-${arrowData.endBlock}`;
                marker = createOrUpdateMarker(startMarkerId, arrowData.color, headSize);
                marker.setAttribute('orient', 'auto-start-reverse');
                arrowLine.setAttribute('marker-start', `url(#${startMarkerId})`);
            }
            
            const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hitbox.classList.add('arrow-hitbox');
            arrowGroup.appendChild(arrowLine);
            arrowGroup.appendChild(hitbox);
            svgCanvas.appendChild(arrowGroup);
            updateSingleArrow(arrowGroup);
            return arrowGroup;
        }

        function getBlockCenter(block) {
            const x = parseInt(block.style.left);
            const y = parseInt(block.style.top);
            return { x: x + block.offsetWidth / 2, y: y + block.offsetHeight / 2 };
        }
        
        function getClosestConnectionPoint(from, to) {
            const fromRect = { x: parseInt(from.style.left), y: parseInt(from.style.top), width: from.offsetWidth, height: from.offsetHeight };
            const toRect = { x: parseInt(to.style.left), y: parseInt(to.style.top), width: to.offsetWidth, height: to.offsetHeight };
            const fromCx = fromRect.x + fromRect.width / 2;
            const fromCy = fromRect.y + fromRect.height / 2;
            const toCx = toRect.x + toRect.width / 2;
            const toCy = toRect.y + toRect.height / 2;
            const dx = toCx - fromCx;
            const dy = toCy - fromCy;
            if (dx === 0 && dy === 0) return {x: fromCx, y: fromCy};
            const angle = Math.atan2(dy, dx);
            const fromHalfWidth = fromRect.width / 2;
            const fromHalfHeight = fromRect.height / 2;
            const fromAngle = Math.atan2(fromHalfHeight, fromHalfWidth);
            let pointX, pointY;
            const absAngle = Math.abs(angle);
            if (absAngle > Math.PI - fromAngle || absAngle < fromAngle) {
                let tan = Math.tan(angle);
                pointX = dx > 0 ? fromCx + fromHalfWidth : fromCx - fromHalfWidth;
                pointY = fromCy + (pointX - fromCx) * tan;
            } else {
                let cot = 1 / Math.tan(angle);
                pointY = dy > 0 ? fromCy + fromHalfHeight : fromCy - fromHalfHeight;
                pointX = fromCx + (pointY - fromCy) * cot;
            }
            return { x: pointX, y: pointY };
        }
        
        function download(filename, text) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        function createColorPicker() {
            const picker = document.getElementById('custom-color-picker');
            const header = picker.querySelector('.color-picker-header');
            const spectrum = document.getElementById('color-spectrum');
            const cursor = document.getElementById('spectrum-cursor');
            const hueSlider = document.getElementById('hue-slider');
            const opacitySlider = document.getElementById('opacity-slider');
            const hexInput = document.getElementById('hex-input');
            const rInput = document.getElementById('rgba-input-r');
            const gInput = document.getElementById('rgba-input-g');
            const bInput = document.getElementById('rgba-input-b');
            const aInput = document.getElementById('rgba-input-a');
            const confirmBtn = document.getElementById('color-picker-confirm');
            const cancelBtn = document.getElementById('color-picker-cancel');

            let state = { h: 0, s: 1, v: 1, a: 1 };
            let onConfirmCallback = null;

            function updateUI() {
                const { r, g, b } = hsvToRgb(state.h, state.s, state.v);
                
                spectrum.style.background = `linear-gradient(to top, black, transparent), linear-gradient(to right, white, hsl(${state.h}, 100%, 50%))`;
                opacitySlider.style.background = `linear-gradient(to right, transparent, rgb(${r},${g},${b}))`;
                
                cursor.style.left = `${state.s * 100}%`;
                cursor.style.top = `${(1 - state.v) * 100}%`;
                cursor.style.borderColor = state.v > 0.5 ? 'black' : 'white';

                hexInput.value = rgbToHex(r, g, b);
                rInput.value = r;
                gInput.value = g;
                bInput.value = b;
                aInput.value = state.a.toFixed(2);
            }

            function updateFromInputs() {
                const r = parseInt(rInput.value);
                const g = parseInt(gInput.value);
                const b = parseInt(bInput.value);
                const a = parseFloat(aInput.value);
                const { h, s, v } = rgbToHsv(r, g, b);
                state = { h, s, v, a };
                hueSlider.value = h;
                opacitySlider.value = a;
                updateUI();
            }

            function handleSpectrumMove(e) {
                const rect = spectrum.getBoundingClientRect();
                state.s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                state.v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
                updateUI();
            }
            
            spectrum.addEventListener('mousedown', e => {
                handleSpectrumMove(e);
                const onMouseMove = (moveE) => handleSpectrumMove(moveE);
                const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp, { once: true });
            });

            hueSlider.addEventListener('input', () => { state.h = parseInt(hueSlider.value); updateUI(); });
            opacitySlider.addEventListener('input', () => { state.a = parseFloat(opacitySlider.value); updateUI(); });
            
            [rInput,gInput,bInput,aInput].forEach(input => input.addEventListener('change', updateFromInputs));
            hexInput.addEventListener('change', () => {
                const { r, g, b } = hexToRgb(hexInput.value);
                const { h, s, v } = rgbToHsv(r, g, b);
                state.h = h; state.s = s; state.v = v;
                updateUI();
            });

            confirmBtn.addEventListener('click', () => {
                const { r, g, b } = hsvToRgb(state.h, state.s, state.v);
                if (onConfirmCallback) onConfirmCallback(`rgba(${r}, ${g}, ${b}, ${state.a})`);
                picker.classList.add('hidden');
            });
            cancelBtn.addEventListener('click', () => picker.classList.add('hidden'));

            header.addEventListener('mousedown', e => {
                let offsetX = e.clientX - picker.offsetLeft;
                let offsetY = e.clientY - picker.offsetTop;
                const onMouseMove = (moveE) => {
                    picker.style.left = `${moveE.clientX - offsetX}px`;
                    picker.style.top = `${moveE.clientY - offsetY}px`;
                };
                const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp, { once: true });
            });

            function hsvToRgb(h, s, v) {
                let r, g, b, i, f, p, q, t;
                i = Math.floor(h / 60); f = h / 60 - i; p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);
                switch (i % 6) { case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break; }
                return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
            }
            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, v = max, d = max - min; s = max === 0 ? 0 : d / max;
                if (max === min) h = 0; else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; }
                return { h: h * 360, s: s, v: v };
            }
            function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
            function hexToRgb(hex) {
                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0};
            }
            function parseRgba(rgba) {
                if (!rgba) return {r:0,g:0,b:0,a:1};
                const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                return match ? {r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]), a: match[4] !== undefined ? parseFloat(match[4]) : 1} : {r:255, g:255, b:255, a:1};
            }

            return {
                show(initialColor, onConfirm) {
                    onConfirmCallback = onConfirm;
                    const {r, g, b, a} = parseRgba(initialColor);
                    const {h, s, v} = rgbToHsv(r, g, b);
                    state = {h, s, v, a};
                    hueSlider.value = h;
                    opacitySlider.value = a;
                    updateUI();
                    picker.classList.remove('hidden');
                },
                hide() { picker.classList.add('hidden'); },
                isHidden() { return picker.classList.contains('hidden'); },
                setPosition(x, y) {
                    picker.style.left = `${Math.max(0, Math.min(x, window.innerWidth - picker.offsetWidth))}px`;
                    picker.style.top = `${Math.max(0, Math.min(y, window.innerHeight - picker.offsetHeight))}px`;
                }
            };
        }

        // --- Mecanismo de Edição de Texto ---

        function renderContent(model, element) {
            element.innerHTML = '';
            if (!model || model.length === 0) {
                element.innerHTML = '<br>';
                return;
            }
            model.forEach(span => {
                if (span.isHTML) {
                    element.insertAdjacentHTML('beforeend', span.text);
                    return;
                }
                const spanEl = document.createElement('span');
                spanEl.textContent = span.text;
                
                Object.entries(span.style).forEach(([key, value]) => {
                    if (value) {
                         spanEl.style[key] = value;
                    }
                });
                element.appendChild(spanEl);
            });
        }

        function parseContent(element, initialHTML = null) {
            const model = [];
            const source = initialHTML ? document.createElement('div') : element;
            if (initialHTML) source.innerHTML = initialHTML;

            source.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    if (node.textContent) model.push({ text: node.textContent, style: {} });
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const style = {};
                    const computedStyle = window.getComputedStyle(node);
                    if (computedStyle.fontWeight === '700' || computedStyle.fontWeight === 'bold') style.fontWeight = 'bold';
                    if (computedStyle.fontStyle === 'italic') style.fontStyle = 'italic';
                    if (computedStyle.textDecorationLine === 'underline') style.textDecoration = 'underline';
                    if (computedStyle.fontSize) style.fontSize = computedStyle.fontSize;
                    if (computedStyle.fontFamily) style.fontFamily = computedStyle.fontFamily;
                    if (computedStyle.color) style.color = computedStyle.color;

                    model.push({ text: node.textContent, style });
                }
            });
            return mergeModel(model);
        }

        function getSelectionIndices(parentElement) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return { start: 0, end: 0 };
            const range = selection.getRangeAt(0);
            
            let start = 0, end = 0;
            const preSelectionRange = document.createRange();
            preSelectionRange.selectNodeContents(parentElement);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            start = preSelectionRange.toString().length;
            end = start + range.toString().length;
            
            return { start, end };
        }

        function restoreSelection(indices) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            const range = document.createRange();
            
            let charIndex = 0;
            let startNode = null, startOffset = 0;
            let endNode = null, endOffset = 0;
            
            function findNodeAndOffset(targetIndex) {
                if (!activeEditingElement) return { node: null, offset: 0 };
                for (const node of activeEditingElement.childNodes) {
                    const nodeLength = node.textContent.length;
                    if (charIndex + nodeLength >= targetIndex) {
                        return { node: node.firstChild || node, offset: targetIndex - charIndex };
                    }
                    charIndex += nodeLength;
                }
                const lastChild = activeEditingElement.lastChild;
                if (!lastChild) return { node: activeEditingElement, offset: 0 };
                return { node: lastChild.firstChild || lastChild, offset: lastChild.textContent.length };
            }
            
            const start = findNodeAndOffset(indices.start);
            startNode = start.node;
            startOffset = start.offset;

            charIndex = 0; 
            const end = findNodeAndOffset(indices.end);
            endNode = end.node;
            endOffset = end.offset;
            
            try {
                if (startNode && endNode) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    selection.addRange(range);
                }
            } catch (e) {
                console.error("Falha ao restaurar a seleção.", e);
            }
        }

        function applyStyleToSelection(styleToApply) {
            if (!isEditing) return;

            const selectionIndices = getSelectionIndices(activeEditingElement);
            const { start, end } = selectionIndices;
            
            let newModel = [];
            let currentIndex = 0;

            activeContentModel.forEach(span => {
                const spanStart = currentIndex;
                const spanEnd = spanStart + span.text.length;
                
                if (spanEnd <= start || spanStart >= end) {
                    newModel.push(span);
                } else {
                    const beforeText = span.text.substring(0, start - spanStart);
                    const selectedText = span.text.substring(Math.max(0, start - spanStart), end - spanStart);
                    const afterText = span.text.substring(end - spanStart);
                    
                    if (beforeText) newModel.push({ text: beforeText, style: { ...span.style } });

                    if (selectedText) {
                        const newStyle = { ...span.style };
                        for (const key in styleToApply) {
                            if (['fontWeight', 'fontStyle', 'textDecoration'].includes(key)) {
                                if (newStyle[key] === styleToApply[key]) {
                                    delete newStyle[key]; 
                                } else {
                                    newStyle[key] = styleToApply[key];
                                }
                            } else {
                                newStyle[key] = styleToApply[key]; 
                            }
                             if (key === 'fontSize' && styleToApply[key] === '15px') {
                                delete newStyle[key];
                            }
                        }
                        newModel.push({ text: selectedText, style: newStyle });
                    }
                    
                    if (afterText) newModel.push({ text: afterText, style: { ...span.style } });
                }
                currentIndex = spanEnd;
            });
            
            activeContentModel = mergeModel(newModel);
            renderContent(activeContentModel, activeEditingElement);
            restoreSelection(selectionIndices);
        }
        
        function mergeModel(model) {
            if (model.length < 2) return model;
            const merged = [model[0]];
            for (let i = 1; i < model.length; i++) {
                const prev = merged[merged.length - 1];
                const current = model[i];
                if (JSON.stringify(prev.style) === JSON.stringify(current.style) && !prev.isHTML && !current.isHTML) {
                    prev.text += current.text;
                } else {
                    merged.push(current);
                }
            }
            return merged.filter(span => span.text.length > 0);
        }
        
        function getCommonStyleInSelection() {
            if (!isEditing) return null;
            const { start, end } = getSelectionIndices(activeEditingElement);
            if (start === end) return getStyleAtCharacterIndex(start > 0 ? start - 1 : 0);

            let commonStyle = null;
            let currentIndex = 0;
            for (const span of activeContentModel) {
                const spanStart = currentIndex;
                const spanEnd = spanStart + span.text.length;
                if (spanEnd > start && spanStart < end) { 
                    if (commonStyle === null) {
                        commonStyle = { ...span.style };
                    } else {
                        for (const key in commonStyle) {
                            if (commonStyle[key] !== span.style[key]) {
                                delete commonStyle[key];
                            }
                        }
                    }
                }
                currentIndex = spanEnd;
            }
            return commonStyle || {};
        }

        function getStyleAtCharacterIndex(index) {
            let currentIndex = 0;
            for (const span of activeContentModel) {
                if (index < currentIndex + span.text.length) {
                    return span.style;
                }
                currentIndex += span.text.length;
            }
            return activeContentModel[activeContentModel.length - 1]?.style || {};
        }

        function getStyleOfFirstCharacter(model) {
            return model && model.length > 0 ? model[0].style : {};
        }

        // --- Block Naming and Sidebar List ---
        let draggedListItem = null;

        function updateBlocksList() {
            blocksList.innerHTML = '';
            const currentPage = pages[currentPageIndex];
            if (!currentPage || !currentPage.blocks) return;

            const blocksToRender = currentPage.blocks;

            blocksToRender.forEach(blockData => {
                const li = document.createElement('li');
                li.textContent = blockData.name;
                li.dataset.blockId = blockData.id;
                li.setAttribute('draggable', 'true');

                if (selection.some(sel => sel.id === blockData.id)) {
                    li.classList.add('selected');
                }
                li.addEventListener('click', (e) => {
                    const blockEl = document.getElementById(blockData.id);
                    if (blockEl) {
                        updateSelection(blockEl, e.shiftKey, true);
                        const blockRect = blockEl.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        const targetScale = 1;
                        
                        scale = targetScale;
                        gridX = -blockEl.offsetLeft + (containerRect.width / 2) - (blockRect.width / scale / 2);
                        gridY = -blockEl.offsetTop + (containerRect.height / 2) - (blockRect.height / scale / 2);

                        updateGridTransform();
                    }
                });

                li.addEventListener('dragstart', (e) => {
                    draggedListItem = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                });
                li.addEventListener('dragend', (e) => {
                    draggedListItem.classList.remove('dragging');
                    draggedListItem = null;
                });
                blocksList.appendChild(li);
            });
        }
        
        blocksList.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(blocksList, e.clientY);
            if (draggedListItem) {
                 if (afterElement == null) {
                    blocksList.appendChild(draggedListItem);
                } else {
                    blocksList.insertBefore(draggedListItem, afterElement);
                }
            }
        });

        blocksList.addEventListener('drop', e => {
            e.preventDefault();
            if(!draggedListItem) return;

            const newOrderIds = [...blocksList.querySelectorAll('li')].map(li => li.dataset.blockId);
            const currentPageData = pages[currentPageIndex];
            
            currentPageData.blocks.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
            
            const totalBlocks = currentPageData.blocks.length;
            currentPageData.blocks.forEach((blockData, index) => {
                blockData.zIndex = totalBlocks - index;
                const blockEl = document.getElementById(blockData.id);
                if (blockEl) {
                    blockEl.style.zIndex = blockData.zIndex;
                }
            });
            
            recordState();
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        function findHighestZIndex() {
            const blocks = document.querySelectorAll('.block');
            let maxZ = 0;
            blocks.forEach(block => {
                const z = parseInt(block.style.zIndex);
                if (!isNaN(z) && z > maxZ) {
                    maxZ = z;
                }
            });
            return maxZ;
        }


        function updateBlockNameDisplay(block) {
            const nameEl = block.querySelector('.block-name');
            const blockName = block.dataset.name;

            const isDefaultName = blockName.startsWith('Bloco ') && !isNaN(parseInt(blockName.split(' ')[1]));

            if (isDefaultName) {
                nameEl.style.display = 'none';
            } else {
                nameEl.style.display = '';
                nameEl.textContent = blockName;
                const bgColor = getComputedStyle(block).backgroundColor;
                const rgb = bgColor.match(/\d+/g);
                if (rgb) {
                    const brightness = (parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000;
                    nameEl.style.color = brightness < 128 ? 'rgba(255, 255, 255, 0.9)' : 'rgba(0, 0, 0, 0.7)';
                }
            }
        }
        
        function startRenamingBlock() {
            if (selection.length !== 1 || !lastSelectedItem?.classList.contains('block')) return;
            renameBlockForm.classList.remove('hidden');
            renameBlockInput.value = lastSelectedItem.dataset.name;
            renameBlockInput.focus();
            renameBlockInput.select();
        }

        function confirmRenameBlock() {
            if (selection.length !== 1 || !lastSelectedItem?.classList.contains('block')) return;
            const newName = renameBlockInput.value.trim();
            if (newName) {
                lastSelectedItem.dataset.name = newName;
                updateBlockNameDisplay(lastSelectedItem);
                recordState();
                updateBlocksList();
                showToast(currentLangStrings.toast_block_renamed.replace('{name}', newName));
            }
            renameBlockForm.classList.add('hidden');
        }

        // --- Move Blocks Functionality ---

        function moveSelectionToPage(targetPageNumber) {
            const targetIndex = targetPageNumber - 1;
            if (targetIndex < 0 || targetIndex >= pages.length || targetIndex === currentPageIndex) {
                 if (targetIndex !== currentPageIndex) showToast(currentLangStrings.toast_invalid_slide);
                return;
            }

            saveCurrentPageState();
            
            const blocksToMove = selection.filter(item => item.classList.contains('block'));
            const blockIdsToMove = new Set(blocksToMove.map(b => b.id));
            if (blockIdsToMove.size === 0) return;

            const blockDataToMove = pages[currentPageIndex].blocks.filter(b => blockIdsToMove.has(b.id));

            pages[currentPageIndex].blocks = pages[currentPageIndex].blocks.filter(b => !blockIdsToMove.has(b.id));
            pages[currentPageIndex].arrows = pages[currentPageIndex].arrows.filter(a => !blockIdsToMove.has(a.startBlock) && !blockIdsToMove.has(a.endBlock));

            if (!pages[targetIndex].blocks) pages[targetIndex].blocks = [];
            pages[targetIndex].blocks.push(...blockDataToMove);
            
            showToast(currentLangStrings.toast_blocks_moved.replace('{count}', blockIdsToMove.size).replace('{slide}', targetPageNumber));
            
            loadPage(currentPageIndex);
            recordState();
        }

        
        // --- Family System ---
        
        function toggleParentMove() {
            isParentMoveEnabled = !isParentMoveEnabled;
            toggleParentMoveBtn.classList.toggle('active', isParentMoveEnabled);
            showToast(isParentMoveEnabled ? currentLangStrings.toast_parent_move_on : currentLangStrings.toast_parent_move_off);
        }

        function addNewFamily() {
            const name = newFamilyNameInput.value.trim();
            if (name && !families.some(f => f.name === name)) {
                const newFamily = {
                    id: `family-${Date.now()}`,
                    name: name
                };
                families.push(newFamily);
                newFamilyNameInput.value = '';
                renderFamiliesList();
                updateFamilySelectDropdown();
                recordState();
            }
        }

        function renderFamiliesList() {
            familiesList.innerHTML = '';
            families.forEach(family => {
                const li = document.createElement('li');
                li.dataset.familyId = family.id;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = family.name;
                nameSpan.onclick = () => {
                    const newName = prompt(`Editar nome da família "${family.name}":`, family.name);
                    if (newName && newName.trim()) {
                        family.name = newName.trim();
                        renderFamiliesList();
                        updateFamilySelectDropdown();
                        recordState();
                    }
                };

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'family-actions';

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '🗑️';
                deleteBtn.title = 'Deletar Família';
                deleteBtn.onclick = () => {
                    if (confirm(`Tem certeza que deseja deletar a família "${family.name}"? Os blocos não serão deletados.`)) {
                        // Unset family from blocks
                        pages.forEach(page => {
                            page.blocks.forEach(block => {
                                if (block.familyId === family.id) {
                                    delete block.familyId;
                                    const blockEl = document.getElementById(block.id);
                                    if(blockEl) delete blockEl.dataset.familyId;
                                }
                            });
                        });
                        families = families.filter(f => f.id !== family.id);
                        renderFamiliesList();
                        updateFamilySelectDropdown();
                        recordState();
                    }
                };
                
                actionsDiv.appendChild(deleteBtn);
                li.appendChild(nameSpan);
                li.appendChild(actionsDiv);
                familiesList.appendChild(li);
            });
        }
        
        function updateFamilySelectDropdown() {
            const currentVal = familySelect.value;
            familySelect.innerHTML = '<option value="none">Nenhuma</option>';
            families.forEach(family => {
                const option = document.createElement('option');
                option.value = family.id;
                option.textContent = family.name;
                familySelect.appendChild(option);
            });
            familySelect.value = currentVal;
        }
        
        function assignFamilyToSelection() {
            const familyId = familySelect.value;
            const selectedBlocks = selection.filter(item => item.classList.contains('block'));

            selectedBlocks.forEach(block => {
                if (familyId === 'none') {
                    delete block.dataset.familyId;
                } else {
                    block.dataset.familyId = familyId;
                }
            });
            recordState();
        }


        initialize();
    });
</script>
</body>
</html>

