<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Interactive Canvas - MentMap</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"><style>        :root {            --glow-color: #0d82e8;            --background-start: #111827;            --background-end: #0c0d24;            --text-light: #f9fafb;            --text-muted: #9ca3af;            --panel-bg: rgba(23, 25, 43, 0.7);            --border-color: rgba(255, 255, 255, 0.1);        }        * {            margin: 0;            padding: 0;            box-sizing: border-box;        }        @keyframes backgroundPan {            0% { background-position: 0% 50%; }            50% { background-position: 100% 50%; }            100% { background-position: 0% 50%; }        }        body {            overflow: hidden;            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;            background: linear-gradient(90deg, var(--background-start), var(--background-end), var(--background-start));            background-size: 200% 200%;            animation: backgroundPan 30s ease infinite;            height: 100vh;            width: 100vw;            display: flex;            color: var(--text-light);            cursor: default;            user-select: none;            -webkit-user-select: none;        }                body.arrow-mode .block {            cursor: crosshair;        }        .container {            position: relative;            flex: 1;            overflow: hidden;        }        .grid {            position: absolute;            width: 500vw;            height: 500vh;            left: 0;            top: 0;            background-image:                 radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);            background-size: 30px 30px;            background-position: top left;            transform-origin: top left;            will-change: transform;            transition: background-image 0.5s;        }                #arrow-svg {            position: absolute;            top: 0;            left: 0;            width: 100%;            height: 100%;            pointer-events: none;            z-index: 5;        }                #arrow-svg .arrow-group {            pointer-events: all;            cursor: pointer;            transition: filter 0.3s ease;        }                #arrow-svg .arrow-line {             transition: stroke 0.3s ease, stroke-width 0.3s ease;        }        #arrow-svg .arrow-hitbox {            stroke: transparent;            stroke-width: 20;        }        #arrow-svg .arrow-group.selected {            filter: url(#selection-glow);        }        #arrow-svg .arrow-group:hover .arrow-line {            stroke: var(--glow-color);        }        .block {            position: absolute;            width: 250px;            height: auto;            min-height: 100px;            background: var(--panel-bg);            border: 1px solid var(--border-color);            border-radius: 12px;            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;            backdrop-filter: blur(16px) saturate(180%);            -webkit-backdrop-filter: blur(16px) saturate(180%);            padding: 18px;            cursor: grab;            overflow: visible;            transition: border-color 0.3s, box-shadow 0.3s, transform 0.2s ease-out, background-color 0.3s;            z-index: 10;            display: flex;            flex-direction: column;            color: var(--text-light);        }        .block:hover {            transform: translateY(-4px) scale(1.02);            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), 0 0 20px rgba(13, 130, 232, 0.3);        }                .block.selected {            border-color: var(--glow-color);            box-shadow: 0 0 25px rgba(13, 130, 232, 0.7);        }                .block.pre-selected {            outline: 2px dashed rgba(13, 130, 232, 0.6);        }        .block-content {            outline: none;            padding: 5px;            line-height: 1.5;            width: 100%;            min-height: 30px;            overflow-wrap: break-word;            white-space: pre-wrap;            flex-grow: 1;            cursor: text;            font-size: 15px;        }        .block-content[contenteditable="true"] {            border: 1px dashed var(--glow-color);            padding: 4px;            user-select: text;            -webkit-user-select: text;        }                /* Correção para redimensionamento de iframe */        .block-content.has-iframe {            padding: 0;            overflow: hidden; /* Garante que o iframe não ultrapasse a borda arredondada */            height: 100%;        }                .block-content.has-iframe iframe {             border-radius: 0 !important; /* Remove o radius do iframe para que o do pai funcione */        }        .block-content iframe,        .block-content img,        .block-content video {            width: 100%;            height: 100%; /* Alterado de 'auto' para 100% para iframes */            display: block;            border: none;            border-radius: 8px;            cursor: default;        }        .block.dragging iframe,        .block.dragging video {            pointer-events: none;        }                .resize-handle {            position: absolute;            width: 12px;            height: 12px;            background: var(--handle-color, rgba(255, 255, 255, 0.2));            display: var(--handle-display, block);            border: 2px solid var(--background-start);            border-radius: 50%;            z-index: 20;            opacity: 0;            transition: all 0.2s;        }        .block:hover .resize-handle {            opacity: 1;            background-color: var(--handle-color, var(--glow-color));        }        .handle-n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }        .handle-ne { top: -6px; right: -6px; cursor: nesw-resize; }        .handle-e { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }        .handle-se { bottom: -6px; right: -6px; cursor: nwse-resize; }        .handle-s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }        .handle-sw { bottom: -6px; left: -6px; cursor: nesw-resize; }        .handle-w { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }        .handle-nw { top: -6px; left: -6px; cursor: nwse-resize; }                .coordinates {            position: fixed;             top: 10px;             left: 10px;            background: rgba(23, 25, 43, 0.6);            backdrop-filter: blur(12px);            -webkit-backdrop-filter: blur(12px);            color: var(--text-light);             padding: 8px 12px;            border-radius: 8px;             font-size: 0.8rem;             z-index: 2001;             cursor: pointer;            box-shadow: 0 5px 15px rgba(0,0,0,0.3);            border: 1px solid var(--border-color);            transition: all 0.3s;        }        .coordinates.hidden {            opacity: 0;            transform: translateY(-10px);            pointer-events: none;        }        .coordinates input {            width: 60px;             background: rgba(0,0,0,0.3);             color: white;             border: 1px solid #555;            border-radius: 5px;             padding: 2px 5px;             text-align: center;        }        .shortcut-hint {            position: fixed;            top: 10px;            right: 265px;            left: auto;            background: rgba(23, 25, 43, 0.6);            backdrop-filter: blur(12px);            -webkit-backdrop-filter: blur(12px);            color: var(--text-light);            padding: 10px 15px;            border-radius: 8px;            font-size: 0.8rem;            z-index: 1000;            opacity: 0.95;            box-shadow: 0 5px 15px rgba(0,0,0,0.3);            border: 1px solid var(--border-color);        }        .shortcut-hint kbd {            background: rgba(255,255,255,0.15);            padding: 2px 6px;            border-radius: 4px;            font-family: monospace;            font-size: 0.9em;            border-bottom: 2px solid rgba(255,255,255,0.2);        }        .shortcut-hint hr {            border-color: var(--border-color);            margin: 8px 0;        }        .shortcut-hint .hint-line {            margin-bottom: 6px;        }        .shortcut-hint .hint-category {            font-weight: bold;            margin-top: 8px;            margin-bottom: 4px;        }        #context-menu {            display: none;            position: fixed;            z-index: 3000;            background: rgba(30, 32, 55, 0.85);            backdrop-filter: blur(16px);            border-radius: 8px;            padding: 6px;            box-shadow: 0 5px 20px rgba(0,0,0,0.4);            border: 1px solid var(--border-color);        }        #context-menu ul { list-style: none; padding: 0; margin: 0; }        #context-menu li { padding: 9px 16px; color: var(--text-light); cursor: pointer; border-radius: 5px; font-size: 14px; transition: background-color 0.2s; }        #context-menu li:hover { background: var(--glow-color); }        #context-menu .menu-header {            color: var(--text-muted);            font-size: 11px;            padding: 8px 15px 4px;            cursor: default;            font-weight: 600;            text-transform: uppercase;        }        #context-menu li.menu-header:hover { background: transparent; }        #context-menu .has-submenu { position: relative; }        #context-menu .has-submenu .submenu {            display: none;            position: absolute;            left: 100%;            top: -6px;            background: rgba(30, 32, 55, 0.85);            backdrop-filter: blur(16px);            border-radius: 8px;            padding: 6px;            box-shadow: 5px 5px 20px rgba(0,0,0,0.4);            list-style: none;            min-width: 160px;            z-index: 3001;            border: 1px solid var(--border-color);        }        #context-menu .has-submenu:hover > .submenu { display: block; }        .marquee-box {            position: fixed;            border: 1px dashed var(--glow-color);            background: rgba(13, 130, 232, 0.2);            pointer-events: none;            z-index: 9999;        }        .toast-notification {            position: fixed;            bottom: -100px;            left: 50%;            transform: translateX(-50%);            background: linear-gradient(45deg, #2c3e50, #34495e);            color: white;            padding: 12px 24px;            border-radius: 50px;            z-index: 10000;            font-size: 15px;            font-weight: 500;            opacity: 0;            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);            pointer-events: none;            box-shadow: 0 5px 20px rgba(0,0,0,0.3);        }        .toast-notification.show { opacity: 1; bottom: 100px; }        .sidebar {            position: fixed;            top: 0;            right: 0;            width: 250px;            height: 100vh;            background: rgba(23, 25, 43, 0.6);            backdrop-filter: blur(12px);            -webkit-backdrop-filter: blur(12px);            color: var(--text-light);            box-shadow: -5px 0 25px rgba(0,0,0,0.5);            border-left: 1px solid var(--border-color);            z-index: 2000;            display: flex;            flex-direction: column;            font-size: 13px;            overflow-y: auto;            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);        }        .sidebar.hidden {            transform: translateX(100%);        }        .sidebar-section { padding: 15px; border-bottom: 1px solid var(--border-color); }        .sidebar-section:last-child { border-bottom: none; }        .sidebar-section h4 {            font-size: 11px;            text-transform: uppercase;            color: var(--text-muted);            margin-bottom: 15px;            padding-bottom: 5px;            border-bottom: 1px solid var(--border-color);        }        .page-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; }        .page-btn {            background: rgba(255, 255, 255, 0.1);            color: var(--text-light);            border: 1px solid var(--border-color);            width: 38px;            height: 38px;            border-radius: 50%;            cursor: pointer;            font-size: 18px;            font-weight: bold;            display: flex;            align-items: center;            justify-content: center;            transition: background-color 0.2s, transform 0.2s;        }        .page-btn:hover { background-color: var(--glow-color); transform: scale(1.1); }        .page-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; background-color: rgba(255, 255, 255, 0.1); }        #page-display {            font-weight: 600;            background: rgba(0,0,0,0.3);            padding: 5px 12px;            border-radius: 15px;            min-width: 80px;            text-align: center;            margin: 5px 0;        }        .actions-grid { display: flex; flex-direction: column; gap: 10px; }        .control-btn {            width: 100%;            background: rgba(255, 255, 255, 0.1);            color: var(--text-light);            border: 1px solid var(--border-color);            padding: 10px;            border-radius: 8px;            cursor: pointer;            font-weight: 600;            transition: all 0.2s;            display: flex;            align-items: center;            justify-content: center;            gap: 8px;            font-size: 13px;        }        .control-btn.active { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }        .control-btn:hover { background: var(--glow-color); }        .control-btn:disabled { background: #444; color: #888; cursor: not-allowed; }        .control-group { margin-bottom: 15px; }        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }        .color-picker-wrapper { width: 24px; height: 24px; border-radius: 50%; border: 2px solid var(--border-color); cursor: pointer; transition: transform 0.2s; }        .color-picker-wrapper:hover { transform: scale(1.15); }        .control-group input[type="range"], .control-group input[type="number"], .control-group input[type="text"], .control-group input[type="checkbox"] {            width: 120px;            background: rgba(0,0,0,0.3); color: white; border: 1px solid #666; border-radius: 4px; padding: 3px;        }        .control-group input[type="checkbox"] { width: auto; }        .text-format-buttons { display: flex; gap: 10px; margin-bottom: 12px; }        .format-btn { flex: 1; background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); color: white; padding: 5px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }        .format-btn:hover { background: rgba(255,255,255,0.2); }        .format-btn.active { background-color: var(--glow-color); }        .hidden { display: none !important; }        select {            -webkit-appearance: none; -moz-appearance: none; appearance: none;            background-color: rgba(0,0,0,0.3); color: white; border: 1px solid #666; border-radius: 4px; padding: 4px 8px; padding-right: 25px;            width: 120px; cursor: pointer;            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');            background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto;        }        .sidebar::-webkit-scrollbar { width: 10px; }        .sidebar::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }        .sidebar::-webkit-scrollbar-thumb { background: #555; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }        .sidebar::-webkit-scrollbar-thumb:hover { background: var(--glow-color); }                #custom-color-picker {            position: fixed;            width: 240px;            background: rgba(30, 32, 55, 0.9);            backdrop-filter: blur(10px);            border: 1px solid var(--border-color);            border-radius: 8px;            box-shadow: 0 10px 30px rgba(0,0,0,0.5);            z-index: 4000;            padding: 10px;            font-size: 13px;            color: #eee;        }        .color-picker-header {            padding: 8px; text-align: center; font-weight: bold; cursor: move;            background: rgba(255,255,255,0.1); margin: -10px -10px 10px -10px;            border-top-left-radius: 8px; border-top-right-radius: 8px;            border-bottom: 1px solid var(--border-color);        }        .color-picker-body { display: flex; flex-direction: column; gap: 10px; }        .color-spectrum { width: 100%; height: 120px; position: relative; cursor: crosshair; background: linear-gradient(to top, black, transparent), linear-gradient(to right, white, hsl(0, 100%, 50%)); }        .spectrum-cursor {            position: absolute; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white;            box-shadow: 0 0 5px rgba(0,0,0,0.7), 0 0 0 2px black inset; pointer-events: none; transform: translate(-50%, -50%);        }        .color-slider { width: 100%; -webkit-appearance: none; appearance: none; height: 10px; border-radius: 5px; background: #555; outline: none; }        .hue-slider { background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }        .opacity-slider { background: linear-gradient(to right, transparent, white); }        .color-slider::-webkit-slider-thumb {            -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%;            background: #fff; cursor: pointer; border: 2px solid #333;        }        .color-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 10px; align-items: center; }        .color-inputs label { font-size: 12px; color: var(--text-muted); }        .color-inputs input {            width: 100%; background: #333; border: 1px solid #666; color: #fff;            border-radius: 4px; padding: 4px; text-align: center;        }        .color-inputs input[type="number"] { -moz-appearance: textfield; }        .color-inputs input[type="number"]::-webkit-inner-spin-button, .color-inputs input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }        .color-picker-footer { margin-top: 10px; display: flex; gap: 10px; }        .color-picker-footer button {            flex: 1; background: rgba(255,255,255,0.1); color: var(--text-light); border: 1px solid var(--border-color);            padding: 8px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;        }        .color-picker-footer button:hover { background: rgba(255,255,255,0.2); }        .color-picker-footer button.confirm-btn:hover { background: var(--glow-color); }    </style></head><body><div class="container" id="container"><div class="grid" id="grid"><svg id="arrow-svg"><defs><filter id="selection-glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur in="SourceAlpha" stdDeviation="5" result="blur"></feGaussianBlur><feFlood flood-color="var(--glow-color)" result="color"></feFlood><feComposite in="color" in2="blur" operator="in" result="glow"></feComposite><feMerge><feMergeNode in="glow"></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge></filter></defs></svg></div></div><div class="coordinates" id="coordinates" data-translate-key="coords_nothing">Nada selecionado</div><div class="shortcut-hint" id="shortcut-hint" style="display: none;"><div class="hint-line"><span data-translate-key="hint_toggle">Pressione <kbd>H</kbd> para mostrar/esconder os atalhos</span></div><hr><div class="hint-category" data-translate-key="hint_nav_title">Navegação e Visualização:</div><div class="hint-line"><span data-translate-key="hint_pan">Segure <kbd>Shift</kbd> ou <kbd>Clique Meio</kbd> para mover o mapa</span></div><div class="hint-line"><span data-translate-key="hint_zoom">Use o <kbd>Scroll</kbd> para dar zoom</span></div><div class="hint-line"><span data-translate-key="hint_slides">Use <kbd>←</kbd> / <kbd>→</kbd> para mudar de slide</span></div><div class="hint-line"><span data-translate-key="hint_sidebar">Use <kbd>G</kbd> Esconder/Mostrar Painel Lateral</span></div><div class="hint-line"><span data-translate-key="hint_coords"><kbd>N</kbd> Esconder/Mostrar Coordenadas</span></div><hr><div class="hint-category" data-translate-key="hint_actions_title">Ações e Atalhos:</div><div class="hint-line"><span data-translate-key="hint_add"><kbd>Shift</kbd> + <kbd>A</kbd> Adicionar conteúdo</span></div><div class="hint-line"><span data-translate-key="hint_duplicate"><kbd>Shift</kbd> + <kbd>D</kbd> Duplicar/Adicionar</span></div><div class="hint-line"><span data-translate-key="hint_add_slide"><kbd>Shift</kbd> + <kbd>+</kbd> Adicionar Slide</span></div><div class="hint-line"><span data-translate-key="hint_delete_slide"><kbd>Shift</kbd> + <kbd>-</kbd> Deletar Slide</span></div><div class="hint-line"><span data-translate-key="hint_smart_color"><kbd>B</kbd> Paleta de Cores Inteligente</span></div><div class="hint-line"><span data-translate-key="hint_delete"><kbd>Delete</kbd> Apagar itens</span></div><div class="hint-line"><span data-translate-key="hint_undo"><kbd>Ctrl</kbd> + <kbd>Z</kbd> Desfazer</span></div><div class="hint-line"><span data-translate-key="hint_redo"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> Refazer</span></div><div class="hint-line"><span data-translate-key="hint_save"><kbd>Ctrl</kbd> + <kbd>S</kbd> para salvar</span></div><div class="hint-line"><span data-translate-key="hint_load"><kbd>Ctrl</kbd> + <kbd>L</kbd> para carregar</span></div></div><div class="sidebar"><div class="sidebar-section"><h4 data-translate-key="sidebar_customize">Customizar</h4><div id="customize-content"><div id="block-controls" class="control-group hidden"><h5 data-translate-key="sidebar_block">Bloco</h5><label><span data-translate-key="sidebar_background">Fundo</span><div class="color-picker-wrapper" data-color-target="blockBg"></div></label><label><span data-translate-key="sidebar_border">Borda</span><div class="color-picker-wrapper" data-color-target="blockBorder"></div></label></div><div id="handle-controls" class="control-group hidden"><h5 data-translate-key="sidebar_handles">Alças</h5><label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="handle"></div></label><label><span data-translate-key="sidebar_visible">Visível</span><input type="checkbox" id="handle-visible" checked></label></div><div id="text-controls" class="control-group hidden"><h5 data-translate-key="sidebar_text">Texto</h5><div class="text-format-buttons"><button id="bold-btn" class="format-btn"><b>B</b></button><button id="italic-btn" class="format-btn"><i>I</i></button><button id="underline-btn" class="format-btn"><u>U</u></button></div><label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="text"></div></label><label><span data-translate-key="sidebar_size">Tamanho (px)</span><select id="text-size"></select></label><label><span data-translate-key="sidebar_font">Fonte</span><select id="text-font"><option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" data-translate-key="font_default">Padrão</option><option value="Arial, sans-serif">Arial</option><option value="Georgia, serif">Georgia</option><option value="Courier New, monospace">Courier New</option><option value="Verdana, sans-serif">Verdana</option><option value="Times New Roman, serif">Times New Roman</option></select></label></div><div id="link-controls" class="control-group hidden"><h5 data-translate-key="sidebar_embed">Link Incorporado</h5><label><span>URL</span><input type="text" id="link-src"></label></div><div id="arrow-controls" class="control-group hidden"><h5 data-translate-key="sidebar_arrow">Seta</h5><label><span data-translate-key="sidebar_color">Cor</span><div class="color-picker-wrapper" data-color-target="arrow"></div></label><label><span data-translate-key="sidebar_size">Tamanho</span><input type="range" id="arrow-width" min="1" max="10" step="1"></label></div><div id="grid-controls" class="control-group"><h5 data-translate-key="sidebar_grid">Grade</h5><label><span data-translate-key="sidebar_background">Fundo</span><div class="color-picker-wrapper" data-color-target="gridBg"></div></label><label><span data-translate-key="sidebar_lines">Linhas</span><div class="color-picker-wrapper" data-color-target="gridLines"></div></label></div></div></div><div class="sidebar-section"><h4 data-translate-key="sidebar_slides">Slides</h4><div class="page-controls"><button class="page-btn" id="prev-page-btn" title="Slide Anterior (←)">▲</button><span id="page-display">Slide 1 / 1</span><button class="page-btn" id="next-page-btn" title="Próximo Slide (→)">▼</button><button class="page-btn" id="add-page-btn" title="Adicionar Novo Slide (Shift +)">+</button><button class="page-btn" id="delete-page-btn" title="Deletar Slide Atual (Shift -)">🗑️</button></div></div><div class="sidebar-section"><h4 data-translate-key="sidebar_actions">Ações</h4><div class="actions-grid"><button class="control-btn" id="add-content-btn"><span class="btn-icon">+</span><span data-translate-key="btn_add_content">Adicionar</span></button><button class="control-btn" id="toggle-arrow-mode-btn"><span class="btn-icon">→</span><span data-translate-key="btn_arrow_mode">Modo Seta</span></button><button class="control-btn" id="save-btn"><span class="btn-icon">💾</span><span data-translate-key="btn_save">Salvar</span></button><button class="control-btn" id="load-btn"><span class="btn-icon">📂</span><span data-translate-key="btn_load">Carregar</span></button><button class="control-btn active" id="toggle-snap-btn"><span class="btn-icon">🧲</span><span data-translate-key="btn_snap">Encaixe</span></button></div></div></div><div id="context-menu"><ul><li class="menu-header" data-translate-key="menu_add">Adicionar</li><li data-action="add-text" data-translate-key="menu_add_text">Bloco de Texto</li><li class="has-submenu"><span data-translate-key="menu_from_file">Do Arquivo ></span><ul class="submenu"><li data-action="add-media-file" data-translate-key="menu_add_media">Imagem / Vídeo</li><li data-action="import-pdf-file" data-translate-key="menu_add_pdf">PDF como Slides</li></ul></li><li class="has-submenu"><span data-translate-key="menu_from_link">Do Link ></span><ul class="submenu"><li data-action="add-media-link" data-translate-key="menu_add_media">Imagem / Vídeo</li><li data-action="add-pdf-link" data-translate-key="menu_add_pdf">PDF como Slides</li><li data-action="add-desmos-link">Desmos</li><li data-action="add-geogebra-link">GeoGebra</li><li data-action="add-phet-link" data-translate-key="menu_add_phet">PhET Colorado</li></ul></li></ul></div><input type="file" id="file-loader" accept=".json" style="display: none;"><div id="custom-color-picker" class="hidden"><div class="color-picker-header" data-translate-key="color_picker_title">Seletor de Cores</div><div class="color-picker-body"><div class="color-spectrum" id="color-spectrum"><div class="spectrum-cursor" id="spectrum-cursor"></div></div><input type="range" min="0" max="360" value="0" class="color-slider hue-slider" id="hue-slider"><input type="range" min="0" max="1" value="1" step="0.01" class="color-slider opacity-slider" id="opacity-slider"><div class="color-inputs"><label for="hex-input">HEX</label><input type="text" id="hex-input"><label for="rgba-input-r">RGBA</label><div style="display: flex; gap: 2px;"><input type="number" id="rgba-input-r" min="0" max="255"><input type="number" id="rgba-input-g" min="0" max="255"><input type="number" id="rgba-input-b" min="0" max="255"><input type="number" id="rgba-input-a" min="0" max="1" step="0.1"></div></div></div><div class="color-picker-footer"><button id="color-picker-cancel" data-translate-key="btn_cancel">Cancelar</button><button id="color-picker-confirm" class="confirm-btn" data-translate-key="btn_confirm">Confirmar</button></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script><script>    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;    document.addEventListener('DOMContentLoaded', function() {        // --- Sistema de Internacionalização (i18n) ---        const translations = {            'pt': {                page_title: "Canvas Interativo - MentMap",                coords_nothing: "Nada selecionado",                coords_items: "itens selecionados",                coords_arrow: "Seta selecionada",                hint_toggle: "Pressione <kbd>H</kbd> para mostrar/esconder os atalhos",                hint_nav_title: "Navegação e Visualização:",                hint_pan: "Segure <kbd>Shift</kbd> ou <kbd>Clique Meio</kbd> para mover o mapa",                hint_zoom: "Use o <kbd>Scroll</kbd> para dar zoom",                hint_slides: "Use <kbd>←</kbd> / <kbd>→</kbd> para mudar de slide",                hint_sidebar: "Use <kbd>G</kbd> para Esconder/Mostrar Painel Lateral",                hint_coords: "<kbd>N</kbd> para Esconder/Mostrar Coordenadas",                hint_actions_title: "Ações e Atalhos:",                hint_add: "<kbd>Shift</kbd> + <kbd>A</kbd> para Adicionar conteúdo",                hint_duplicate: "<kbd>Shift</kbd> + <kbd>D</kbd> para Duplicar/Adicionar",                hint_add_slide: "<kbd>Shift</kbd> + <kbd>+</kbd> para Adicionar Slide",                hint_delete_slide: "<kbd>Shift</kbd> + <kbd>-</kbd> para Deletar Slide",                hint_smart_color: "<kbd>B</kbd> para Paleta de Cores Inteligente",                hint_delete: "<kbd>Delete</kbd> para Apagar itens",                hint_undo: "<kbd>Ctrl</kbd> + <kbd>Z</kbd> para Desfazer",                hint_redo: "<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> para Refazer",                hint_save: "<kbd>Ctrl</kbd> + <kbd>S</kbd> para salvar",                hint_load: "<kbd>Ctrl</kbd> + <kbd>L</kbd> para carregar",                sidebar_customize: "Customizar",                sidebar_block: "Bloco",                sidebar_background: "Fundo",                sidebar_border: "Borda",                sidebar_handles: "Alças",                sidebar_color: "Cor",                sidebar_visible: "Visível",                sidebar_text: "Texto",                sidebar_size: "Tamanho (px)",                sidebar_font: "Fonte",                font_default: "Padrão",                sidebar_embed: "Link Incorporado",                sidebar_arrow: "Seta",                sidebar_grid: "Grade",                sidebar_lines: "Linhas",                sidebar_slides: "Slides",                sidebar_actions: "Ações",                btn_add_content: "Adicionar",                btn_arrow_mode: "Modo Seta",                btn_save: "Salvar",                btn_load: "Carregar",                btn_snap: "Encaixe",                menu_add: "Adicionar",                menu_add_text: "Bloco de Texto",                menu_from_file: "Do Arquivo >",                menu_add_media: "Imagem / Vídeo",                menu_add_pdf: "PDF como Slides",                menu_add_phet: "PhET Colorado",                menu_from_link: "Do Link >",                color_picker_title: "Seletor de Cores",                btn_cancel: "Cancelar",                btn_confirm: "Confirmar",                toast_snap_on: "Encaixe na Grade Ativado",                toast_snap_off: "Encaixe na Grade Desativado",                toast_page_added: "Slide {page} adicionado",                toast_page_deleted: "Slide {page} deletado",                toast_cant_delete_last: "Não é possível deletar o último slide.",                toast_pdf_importing: "Importando {name}... Isso pode levar um momento.",                toast_pdf_success: "Importado com sucesso {numPages} slides.",                toast_pdf_error: "Falha ao importar PDF. Veja o console para detalhes.",                toast_file_loaded: "Arquivo carregado com sucesso!",                toast_file_error: "Falha ao carregar arquivo. Pode estar corrompido.",                toast_media_error: "Não foi possível carregar a imagem ou vídeo da URL.",                prompt_media_url: "Insira a URL da Imagem ou Vídeo (YouTube, Vimeo, etc.):",                prompt_pdf_url: "Insira a URL do PDF para importar como slides:",                prompt_desmos_url: "Insira a URL do gráfico Desmos:",                prompt_geogebra_url: "Insira a URL do applet GeoGebra (ex: de compartilhar > incorporar):",                prompt_phet_url: "Insira a URL da simulação PhET Colorado:",                initial_block_0: "Bem-vindo ao MentMap! 👋\nEste é o seu canvas infinito. Dê um duplo clique para editar.",                initial_block_1: "NAVEGAÇÃO\nUse a Roda do Mouse para dar zoom. Segure SHIFT e arraste para mover o mapa.",                initial_block_2: "ADICIONAR CONTEÚDO\nClique com o botão direito para adicionar blocos, imagens, vídeos e links incorporados (PDFs, Desmos).",                initial_block_3: "CONECTAR IDEIAS\nAtive o 'Modo Seta' ou segure CTRL e arraste de um bloco para outro para criar uma conexão.",                initial_block_4: "CUSTOMIZAÇÃO\nAbra o painel com 'G'. Selecione um item para ver suas opções. Dica: Pressione 'B' para uma paleta de cores inteligente!",                initial_block_5: "EDIÇÃO RÁPIDA\nDuplique com Shift+D, apague com Delete, e desfaça/refaça com Ctrl+Z.",                initial_block_6: "APRESENTAÇÕES E ARQUIVOS\nUse os controles de 'Slides' para criar uma apresentação. Salve (Ctrl+S) e Carregue (Ctrl+L) seu trabalho.",            },            'en': {                page_title: "Interactive Canvas - MentMap",                coords_nothing: "Nothing selected",                coords_items: "items selected",                coords_arrow: "Arrow selected",                hint_toggle: "Press <kbd>H</kbd> to toggle shortcuts hint",                hint_nav_title: "Navigation & View:",                hint_pan: "Hold <kbd>Shift</kbd> or <kbd>Middle Click</kbd> to pan the map",                hint_zoom: "Use <kbd>Scroll</kbd> to zoom",                hint_slides: "Use <kbd>←</kbd> / <kbd>→</kbd> to change slides",                hint_sidebar: "Use <kbd>G</kbd> to Hide/Show Side Panel",                hint_coords: "<kbd>N</kbd> to Hide/Show Coordinates",                hint_actions_title: "Actions & Shortcuts:",                hint_add: "<kbd>Shift</kbd> + <kbd>A</kbd> to Add content",                hint_duplicate: "<kbd>Shift</kbd> + <kbd>D</kbd> to Duplicate/Add",                hint_add_slide: "<kbd>Shift</kbd> + <kbd>+</kbd> to Add Slide",                hint_delete_slide: "<kbd>Shift</kbd> + <kbd>-</kbd> to Delete Slide",                hint_smart_color: "<kbd>B</kbd> for Smart Color Palette",                hint_delete: "<kbd>Delete</kbd> to delete items",                hint_undo: "<kbd>Ctrl</kbd> + <kbd>Z</kbd> to Undo",                hint_redo: "<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> to Redo",                hint_save: "<kbd>Ctrl</kbd> + <kbd>S</kbd> to save",                hint_load: "<kbd>Ctrl</kbd> + <kbd>L</kbd> to load",                sidebar_customize: "Customize",                sidebar_block: "Block",                sidebar_background: "Background",                sidebar_border: "Border",                sidebar_handles: "Handles",                sidebar_color: "Color",                sidebar_visible: "Visible",                sidebar_text: "Text",                sidebar_size: "Size (px)",                sidebar_font: "Font",                font_default: "Default",                sidebar_embed: "Embed Link",                sidebar_arrow: "Arrow",                sidebar_grid: "Grid",                sidebar_lines: "Lines",                sidebar_slides: "Slides",                sidebar_actions: "Actions",                btn_add_content: "Add Content",                btn_arrow_mode: "Arrow Mode",                btn_save: "Save",                btn_load: "Load",                btn_snap: "Snap",                menu_add: "Add",                menu_add_text: "Text Block",                menu_from_file: "From File >",                menu_add_media: "Image / Video",                menu_add_pdf: "PDF as Slides",                menu_add_phet: "PhET Colorado",                menu_from_link: "From Link >",                color_picker_title: "Color Picker",                btn_cancel: "Cancel",                btn_confirm: "Confirm",                toast_snap_on: "Grid Snap Enabled",                toast_snap_off: "Grid Snap Disabled",                toast_page_added: "Slide {page} added",                toast_page_deleted: "Slide {page} deleted",                toast_cant_delete_last: "Cannot delete the last slide.",                toast_pdf_importing: "Importing {name}... This may take a moment.",                toast_pdf_success: "Successfully imported {numPages} slides.",                toast_pdf_error: "Failed to import PDF. See console for details.",                toast_file_loaded: "File loaded successfully!",                toast_file_error: "Failed to load file. It may be corrupted.",                toast_media_error: "Could not load image or video from the URL.",                prompt_media_url: "Enter Image or Video URL (YouTube, Vimeo, etc.):",                prompt_pdf_url: "Enter PDF URL to import as slides:",                prompt_desmos_url: "Enter the Desmos graph URL:",                prompt_geogebra_url: "Enter the GeoGebra applet URL (e.g., from share > embed):",                prompt_phet_url: "Enter the PhET Colorado simulation URL:",                initial_block_0: "Welcome to MentMap! 👋\nThis is your infinite canvas. Double-click to edit.",                initial_block_1: "NAVIGATION\nUse the Mouse Wheel to zoom. Hold SHIFT and drag to pan the map.",                initial_block_2: "ADD CONTENT\nRight-click to add blocks, images, videos, and embedded links (PDFs, Desmos).",                initial_block_3: "CONNECT IDEAS\nEnable 'Arrow Mode' or hold CTRL and drag from one block to another to create a connection.",                initial_block_4: "CUSTOMIZATION\nOpen the panel with 'G'. Select an item to see its options. Tip: Press 'B' for a smart color palette!",                initial_block_5: "QUICK EDITING\nDuplicate with Shift+D, delete with Delete, and undo/redo with Ctrl+Z.",                initial_block_6: "PRESENTATIONS & FILES\nUse the 'Slides' controls to create a presentation. Save (Ctrl+S) and Load (Ctrl+L) your work.",            },            'ja': {                page_title: "インタラクティブキャンバス - MentMap",                coords_nothing: "何も選択されていません",                coords_items: "個のアイテムを選択中",                coords_arrow: "矢印を選択中",                hint_toggle: "<kbd>H</kbd>キーでショートカットのヒントを切り替え",                hint_nav_title: "ナビゲーションと表示:",                hint_pan: "<kbd>Shift</kbd>キーまたは<kbd>中央クリック</kbd>でマップをパン",                hint_zoom: "<kbd>スクロール</kbd>でズーム",                hint_slides: "<kbd>←</kbd> / <kbd>→</kbd>でスライドを切り替え",                hint_sidebar: "<kbd>G</kbd>キーでサイドパネルの表示/非表示",                hint_coords: "<kbd>N</kbd>キーで座標の表示/非表示",                hint_actions_title: "アクションとショートカット:",                hint_add: "<kbd>Shift</kbd> + <kbd>A</kbd>でコンテンツを追加",                hint_duplicate: "<kbd>Shift</kbd> + <kbd>D</kbd>で複製/追加",                hint_add_slide: "<kbd>Shift</kbd> + <kbd>+</kbd>でスライドを追加",                hint_delete_slide: "<kbd>Shift</kbd> + <kbd>-</kbd>でスライドを削除",                hint_smart_color: "<kbd>B</kbd>キーでスマートカラーパレット",                hint_delete: "<kbd>Delete</kbd>キーでアイテムを削除",                hint_undo: "<kbd>Ctrl</kbd> + <kbd>Z</kbd>で元に戻す",                hint_redo: "<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd>でやり直し",                hint_save: "<kbd>Ctrl</kbd> + <kbd>S</kbd>で保存",                hint_load: "<kbd>Ctrl</kbd> + <kbd>L</kbd>で読み込み",                sidebar_customize: "カスタマイズ",                sidebar_block: "ブロック",                sidebar_background: "背景",                sidebar_border: "枠線",                sidebar_handles: "ハンドル",                sidebar_color: "色",                sidebar_visible: "表示",                sidebar_text: "テキスト",                sidebar_size: "サイズ (px)",                sidebar_font: "フォント",                font_default: "デフォルト",                sidebar_embed: "埋め込みリンク",                sidebar_arrow: "矢印",                sidebar_grid: "グリッド",                sidebar_lines: "線",                sidebar_slides: "スライド",                sidebar_actions: "アクション",                btn_add_content: "追加",                btn_arrow_mode: "矢印モード",                btn_save: "保存",                btn_load: "読み込み",                btn_snap: "スナップ",                menu_add: "追加",                menu_add_text: "テキストブロック",                menu_from_file: "ファイルから >",                menu_add_media: "画像 / 動画",                menu_add_pdf: "PDFをスライドとして",                menu_add_phet: "PhETコロラド",                menu_from_link: "リンクから >",                color_picker_title: "カラーピッカー",                btn_cancel: "キャンセル",                btn_confirm: "確認",                toast_snap_on: "グリッドスナップが有効になりました",                toast_snap_off: "グリッドスナップが無効になりました",                toast_page_added: "スライド {page} を追加しました",                toast_page_deleted: "スライド {page} を削除しました",                toast_cant_delete_last: "最後のスライドは削除できません。",                toast_pdf_importing: "{name} をインポートしています… しばらくお待ちください。",                toast_pdf_success: "{numPages}枚のスライドのインポートに成功しました。",                toast_pdf_error: "PDFのインポートに失敗しました。詳細はコンソールを確認してください。",                toast_file_loaded: "ファイルの読み込みに成功しました！",                toast_file_error: "ファイルの読み込みに失敗しました。破損している可能性があります。",                toast_media_error: "URLから画像または動画を読み込めませんでした。",                prompt_media_url: "画像または動画のURLを入力してください (YouTube, Vimeoなど):",                prompt_pdf_url: "スライドとしてインポートするPDFのURLを入力してください:",                prompt_desmos_url: "DesmosグラフのURLを入力してください:",                prompt_geogebra_url: "GeoGebraアプレットのURLを入力してください (例: 共有 > 埋め込みから):",                prompt_phet_url: "PhET ColoradoシミュレーションのURLを入力してください:",                initial_block_0: "MentMapへようこそ！👋\nこれはあなたの無限のキャンバスです。ダブルクリックで編集できます。",                initial_block_1: "ナビゲーション\nマウスホイールでズームします。SHIFTキーを押しながらドラッグしてマップを移動します。",                initial_block_2: "コンテンツの追加\n右クリックでブロック、画像、動画、埋め込みリンク（PDF、Desmos）を追加します。",                initial_block_3: "アイデアをつなぐ\n「矢印モード」を有効にするか、CTRLキーを押しながらブロック間をドラッグして接続を作成します。",                initial_block_4: "カスタマイズ\n「G」キーでパネルを開きます。アイテムを選択してオプションを表示します。ヒント：「B」キーでスマートカラーパレット！",                initial_block_5: "クイック編集\nShift+Dで複製、Deleteで削除、Ctrl+Zで元に戻す/やり直します。",                initial_block_6: "プレゼンテーションとファイル\n「スライド」コントロールを使用してプレゼンテーションを作成します。作業内容を保存（Ctrl+S）し、読み込み（Ctrl+L）ます。",            },            'zh': {                page_title: "交互式画布 - MentMap",                coords_nothing: "未选择任何内容",                coords_items: "个项目已选择",                coords_arrow: "箭头已选择",                hint_toggle: "按 <kbd>H</kbd> 切换快捷键提示",                hint_nav_title: "导航和视图:",                hint_pan: "按住 <kbd>Shift</kbd> 或 <kbd>中键单击</kbd> 来平移地图",                hint_zoom: "使用<kbd>滚轮</kbd>进行缩放",                hint_slides: "使用 <kbd>←</kbd> / <kbd>→</kbd> 切换幻灯片",                hint_sidebar: "使用 <kbd>G</kbd> 隐藏/显示侧边栏",                hint_coords: "使用 <kbd>N</kbd> 隐藏/显示坐标",                hint_actions_title: "操作和快捷键:",                hint_add: "使用 <kbd>Shift</kbd> + <kbd>A</kbd> 添加内容",                hint_duplicate: "使用 <kbd>Shift</kbd> + <kbd>D</kbd> 复制/添加",                hint_add_slide: "使用 <kbd>Shift</kbd> + <kbd>+</kbd> 添加幻灯片",                hint_delete_slide: "使用 <kbd>Shift</kbd> + <kbd>-</kbd> 删除幻灯片",                hint_smart_color: "使用 <kbd>B</kbd> 打开智能调色板",                hint_delete: "使用 <kbd>Delete</kbd> 删除项目",                hint_undo: "使用 <kbd>Ctrl</kbd> + <kbd>Z</kbd> 撤销",                hint_redo: "使用 <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> 重做",                hint_save: "使用 <kbd>Ctrl</kbd> + <kbd>S</kbd> 保存",                hint_load: "使用 <kbd>Ctrl</kbd> + <kbd>L</kbd> 加载",                sidebar_customize: "自定义",                sidebar_block: "块",                sidebar_background: "背景",                sidebar_border: "边框",                sidebar_handles: "句柄",                sidebar_color: "颜色",                sidebar_visible: "可见",                sidebar_text: "文本",                sidebar_size: "大小 (px)",                sidebar_font: "字体",                font_default: "默认",                sidebar_embed: "嵌入链接",                sidebar_arrow: "箭头",                sidebar_grid: "网格",                sidebar_lines: "线条",                sidebar_slides: "幻灯片",                sidebar_actions: "操作",                btn_add_content: "添加内容",                btn_arrow_mode: "箭头模式",                btn_save: "保存",                btn_load: "加载",                btn_snap: "吸附",                menu_add: "添加",                menu_add_text: "文本块",                menu_from_file: "从文件 >",                menu_add_media: "图像 / 视频",                menu_add_pdf: "PDF转幻灯片",                menu_add_phet: "PhET 科罗拉多",                menu_from_link: "从链接 >",                color_picker_title: "颜色选择器",                btn_cancel: "取消",                btn_confirm: "确认",                toast_snap_on: "网格吸附已启用",                toast_snap_off: "网格吸附已禁用",                toast_page_added: "已添加幻灯片 {page}",                toast_page_deleted: "已删除幻灯片 {page}",                toast_cant_delete_last: "无法删除最后一张幻灯片。",                toast_pdf_importing: "正在导入 {name}… 这可能需要一些时间。",                toast_pdf_success: "成功导入 {numPages} 张幻灯片。",                toast_pdf_error: "导入PDF失败。请查看控制台了解详情。",                toast_file_loaded: "文件加载成功！",                toast_file_error: "文件加载失败。文件可能已损坏。",                toast_media_error: "无法从URL加载图像或视频。",                prompt_media_url: "输入图像或视频URL（YouTube, Vimeo等）:",                prompt_pdf_url: "输入要作为幻灯片导入的PDF URL:",                prompt_desmos_url: "输入Desmos图表URL:",                prompt_geogebra_url: "输入GeoGebra小程序URL（例如，从分享 > 嵌入）:",                prompt_phet_url: "输入PhET Colorado模拟的URL:",                initial_block_0: "欢迎来到 MentMap！👋\n这是您的无限画布。双击进行编辑。",                initial_block_1: "导航\n使用鼠标滚轮进行缩放。按住SHIFT并拖动以平移地图。",                initial_block_2: "添加内容\n右键单击以添加块、图像、视频和嵌入式链接（PDF、Desmos）。",                initial_block_3: "连接想法\n启用“箭头模式”或按住CTRL并从一个块拖动到另一个块以创建连接。",                initial_block_4: "自定义\n按“G”打开面板。选择一个项目以查看其选项。提示：按“B”可使用智能调色板！",                initial_block_5: "快速编辑\n使用Shift+D复制，使用Delete删除，并使用Ctrl+Z撤销/重做。",                initial_block_6: "演示文稿和文件\n使用“幻灯片”控件创建演示文稿。保存（Ctrl+S）和加载（Ctrl+L）您的工作。",            }        };        let currentLangStrings = translations['en'];        function setLanguage(lang) {            const langCode = lang.split('-')[0];            const supportedLangs = ['pt', 'en', 'ja', 'zh'];            const finalLang = supportedLangs.includes(langCode) ? langCode : 'en';            currentLangStrings = translations[finalLang];            document.documentElement.lang = finalLang;            document.querySelectorAll('[data-translate-key]').forEach(el => {                const key = el.dataset.translateKey;                if (currentLangStrings[key]) {                    // Salva os KBDs para não serem sobrescritos                    const kbdElements = el.querySelectorAll('kbd');                    // Substitui o texto, usando uma expressão regular para placeholders                    let text = currentLangStrings[key];                    // Para os hints, o HTML já está no objeto de tradução                    if (key.startsWith('hint_')) {                        el.innerHTML = text;                    } else {                        el.textContent = text;                    }                }            });             document.title = currentLangStrings.page_title;        }        const container = document.getElementById('container');        const grid = document.getElementById('grid');        const svgCanvas = document.getElementById('arrow-svg');        const svgDefs = svgCanvas.querySelector('defs');        const coordsDisplay = document.getElementById('coordinates');        const addContentBtn = document.getElementById('add-content-btn');        const toggleArrowModeBtn = document.getElementById('toggle-arrow-mode-btn');        const saveBtn = document.getElementById('save-btn');        const loadBtn = document.getElementById('load-btn');        const fileLoader = document.getElementById('file-loader');        const shortcutHint = document.getElementById('shortcut-hint');        const contextMenu = document.getElementById('context-menu');        const prevPageBtn = document.getElementById('prev-page-btn');        const nextPageBtn = document.getElementById('next-page-btn');        const addPageBtn = document.getElementById('add-page-btn');        const deletePageBtn = document.getElementById('delete-page-btn');        const pageDisplay = document.getElementById('page-display');        const sidebar = document.querySelector('.sidebar');        const toggleSnapBtn = document.getElementById('toggle-snap-btn');            let isDragging = false, isPanning = false, isEditing = false, isArrowMode = false, isDrawingArrow = false;        let isResizing = false;        let isMarqueeSelecting = false;        let isSnapEnabled = true;        let isEditingCoords = false; // State to fix coordinates editing bug        let resizeDirection = '';        let resizeInitialRect = null;         let currentBlock = null, arrowStartBlock = null;        let selection = [];         let lastSelectedItem = null;         let startX, startY, mouseMoved = false, lastMouseX = 0, lastMouseY = 0;        let dragInitialPositions = [];        let contextMenuX, contextMenuY;        let gridX = 0, gridY = 0, blockCounter = 1;        let scale = 1;        let tempArrow = null;        let ctrlPressed = false;        let lastBlockCreationAction = () => addNewBlock('Novo bloco.');        let activeEditingElement = null;         let marqueeBox = null, marqueeStartX = 0, marqueeStartY = 0;                let activeContentModel = [];                let pages = [];        let currentPageIndex = 0;        let history = [];        let historyIndex = -1;        const MAX_HISTORY_STATES = 32;        setLanguage(navigator.language);        shortcutHint.style.display = 'block';        setTimeout(() => {            shortcutHint.style.display = 'none';        }, 30000);        function initialize() {            populateFontSizeSelector();            const initialPage = {                blocks: [                    { x: 830, y: 450, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_0, style: {} }], id: 'block-0' },                    { x: 830, y: 200, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_1, style: {} }], id: 'block-1' },                    { x: 1230, y: 450, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_2, style: {} }], id: 'block-2' },                    { x: 1230, y: 700, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_3, style: {} }], id: 'block-3' },                    { x: 430, y: 200, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_4, style: {} }], id: 'block-4' },                    { x: 430, y: 450, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_5, style: {} }], id: 'block-5' },                    { x: 430, y: 700, width: '280px', contentModel: [{ text: currentLangStrings.initial_block_6, style: {} }], id: 'block-6' }                ],                arrows: [                    { startBlock: 'block-0', endBlock: 'block-1', color: '#0d82e8', width: '3' },                    { startBlock: 'block-0', endBlock: 'block-2', color: '#0d82e8', width: '3' },                    { startBlock: 'block-0', endBlock: 'block-3', color: '#0d82e8', width: '3' },                    { startBlock: 'block-0', endBlock: 'block-4', color: '#0d82e8', width: '3' },                    { startBlock: 'block-0', endBlock: 'block-5', color: '#0d82e8', width: '3' },                    { startBlock: 'block-0', endBlock: 'block-6', color: '#0d82e8', width: '3' }                ],                viewport: { gridX: 0, gridY: 0, scale: 0.7 }, // Zoom inicial ajustado para 70%                styles: {}            };            blockCounter = 7;            pages = [initialPage];            currentPageIndex = 0;            loadPage(0, true);            initializeColorPickers();            recordState();         }                function populateFontSizeSelector() {            const fontSizes = [8, 9, 10, 11, 12, 14, 15, 16, 18, 20, 24, 30, 36, 48, 64, 72];            const sizeSelect = document.getElementById('text-size');            sizeSelect.innerHTML = '';            fontSizes.forEach(size => {                const option = document.createElement('option');                option.value = size;                option.textContent = size;                sizeSelect.appendChild(option);            });        }        // --- Listeners de Eventos Principais ---        addContentBtn.addEventListener('click', (e) => {            e.stopPropagation();             contextMenuX = null;            contextMenuY = null;            const rect = addContentBtn.getBoundingClientRect();            contextMenu.style.left = `${rect.left - contextMenu.offsetWidth - 10}px`;            contextMenu.style.top = `${rect.top}px`;            contextMenu.style.display = 'block';        });        toggleArrowModeBtn.addEventListener('click', toggleArrowMode);        toggleSnapBtn.addEventListener('click', () => {            isSnapEnabled = !isSnapEnabled;            toggleSnapBtn.classList.toggle('active', isSnapEnabled);            showToast(isSnapEnabled ? currentLangStrings.toast_snap_on : currentLangStrings.toast_snap_off);        });        saveBtn.addEventListener('click', saveAllPages);        loadBtn.addEventListener('click', () => fileLoader.click());        fileLoader.addEventListener('change', (e) => { loadAllPages(e); });        document.addEventListener('mousemove', handleMouseMove);        document.addEventListener('mouseup', handleMouseUp);        document.addEventListener('keydown', handleKeyDown, true);        document.addEventListener('keyup', handleKeyUp);        document.addEventListener('mousedown', handleGlobalMouseDown, true);        container.addEventListener('mousedown', handleGridMouseDown);        container.addEventListener('contextmenu', handleGridContextMenu);        container.addEventListener('wheel', handleZoom, { passive: false });        container.addEventListener('mousemove', (e) => {            if (!isDragging && !isResizing && !isPanning) {                updateCoordinates(e);            }        });        document.addEventListener('click', () => contextMenu.style.display = 'none');        contextMenu.addEventListener('click', handleContextMenuClick);        svgCanvas.addEventListener('click', handleArrowClick);        coordsDisplay.addEventListener('click', editCoordinates);        prevPageBtn.addEventListener('click', goToPrevPage);        nextPageBtn.addEventListener('click', goToNextPage);        addPageBtn.addEventListener('click', addNewPage);        deletePageBtn.addEventListener('click', deleteCurrentPage);        document.addEventListener('selectionchange', () => {            if (isEditing) {                updateTextControlsOnSelectionChange();            }        });                function showToast(message, duration = 3000) {            const toast = document.createElement('div');            toast.className = 'toast-notification';            toast.textContent = message;            document.body.appendChild(toast);            setTimeout(() => toast.classList.add('show'), 10);            setTimeout(() => {                toast.classList.remove('show');                toast.addEventListener('transitionend', () => toast.remove());            }, duration);        }        function screenToGridCoords(screenX, screenY) {            const gridRect = grid.getBoundingClientRect();            return {                x: (screenX - gridRect.left) / scale,                y: (screenY - gridRect.top) / scale,            };        }                function updateGridTransform() {            grid.style.transform = `translate(${gridX}px, ${gridY}px) scale(${scale})`;        }        function updateSelection(item, shiftKey) {            if (!shiftKey) {                deselectAll();            }            const index = selection.indexOf(item);            if (index > -1) {                if (shiftKey) {                    item.classList.remove('selected');                    selection.splice(index, 1);                    if (lastSelectedItem === item) {                        lastSelectedItem = selection.length > 0 ? selection[selection.length - 1] : null;                    }                }            } else {                item.classList.add('selected');                selection.push(item);                lastSelectedItem = item;            }            updateUIState();        }        function deselectAll() {            selection.forEach(item => item.classList.remove('selected'));            selection = [];            lastSelectedItem = null;            updateUIState();        }        function updateUIState() {            const selectedBlockIds = new Set(selection.filter(item => item.classList.contains('block')).map(block => block.id));            if (selectedBlockIds.size >= 2) {                svgCanvas.querySelectorAll('.arrow-group').forEach(arrow => {                    const startId = arrow.dataset.startBlock;                    const endId = arrow.dataset.endBlock;                    if (selectedBlockIds.has(startId) && selectedBlockIds.has(endId)) {                        if (!selection.includes(arrow)) {                            selection.push(arrow);                            arrow.classList.add('selected');                        }                    }                });            }            updateCoordinates();            updateCustomizePanel();        }        function createBlock(config) {            const block = document.createElement('div');            block.id = config.id || `block-${blockCounter++}`;            block.className = 'block';            block.style.left = `${config.x}px`;            block.style.top = `${config.y}px`;            block.style.width = config.width || '250px';            if (config.height) {                 block.style.height = config.height;            }            if (config.bgColor) block.style.backgroundColor = config.bgColor;            if (config.borderColor) block.style.borderColor = config.borderColor;            if (config.handleColor) block.style.setProperty('--handle-color', config.handleColor);            if (config.handleDisplay) block.style.setProperty('--handle-display', config.handleDisplay);                        block.contentModel = config.contentModel || [];            const contentEl = document.createElement('div');            contentEl.className = 'block-content';            block.appendChild(contentEl);            if (config.htmlContent) {                 block.contentModel = parseContent(contentEl, config.htmlContent);            }                        renderContent(block.contentModel, contentEl);            // Adiciona a classe 'has-iframe' se necessário            if (contentEl.querySelector('iframe')) {                contentEl.classList.add('has-iframe');            }            const handles = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];            handles.forEach(handle => {                const handleEl = document.createElement('div');                handleEl.className = `resize-handle handle-${handle}`;                block.appendChild(handleEl);            });                        grid.appendChild(block);            block.addEventListener('mousedown', (e) => handleBlockMouseDown(e, block));            block.addEventListener('dblclick', (e) => handleBlockDblClick(e, block));                        contentEl.addEventListener('keydown', (e) => {                if (isEditing && (e.key === 'Enter' && !e.shiftKey)) {                    e.preventDefault();                    finishEditing();                }            });                        new ResizeObserver(() => updateArrowsForBlock(block)).observe(block);            return block;        }        function addNewBlock(text, options = {}) {            let coords;            if(contextMenuX && contextMenuY) {                coords = screenToGridCoords(contextMenuX, contextMenuY);            } else {                coords = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);            }                        const isEmbed = text.includes('<iframe') || text.includes('<video') || text.includes('<img');            const contentModel = isEmbed ? [{ text: text, style: {}, isHTML: true }] : [{ text: text, style: {} }];            let config = { x: coords.x, y: coords.y, contentModel: contentModel };            Object.assign(config, options);            const newBlock = createBlock(config);            updateSelection(newBlock, false);                        if (!contentModel[0].isHTML) {                startEditing(newBlock);                const contentEl = newBlock.querySelector('.block-content');                const range = document.createRange();                range.selectNodeContents(contentEl);                const sel = window.getSelection();                sel.removeAllRanges();                sel.addRange(range);            }            recordState();        }        function handleBlockDblClick(e, block) {            if (e.target.closest('a, button, input, iframe, video')) {                return;            }            startEditing(block);        }        function handleBlockMouseDown(e, block) {            e.stopPropagation();            startX = e.clientX;            startY = e.clientY;            mouseMoved = false;            const contentEl = block.querySelector('.block-content');            if (isEditing && contentEl.contains(e.target)) {                return;            }                        const handle = e.target.closest('.resize-handle');            if (handle) {                isResizing = true;                resizeDirection = handle.className.match(/handle-([a-z]{1,2})/)[1];                currentBlock = block;                                resizeInitialRect = {                    width: block.offsetWidth,                    height: block.offsetHeight,                    left: block.offsetLeft,                    top: block.offsetTop,                };                                document.body.style.cursor = getComputedStyle(handle).cursor;                return;            }            if (isArrowMode || ctrlPressed) {                isDrawingArrow = true;                arrowStartBlock = block;                startArrow(e, block);                return;            }                        currentBlock = block;            if (e.shiftKey) {                updateSelection(block, true);            } else if (!selection.includes(block)) {                updateSelection(block, false);            }        }        function handleMouseMove(e) {            lastMouseX = e.clientX;            lastMouseY = e.clientY;            if (!mouseMoved && (isDrawingArrow || currentBlock)) {                const dist = Math.hypot(e.clientX - startX, e.clientY - startY);                if (dist > 3) mouseMoved = true;            }            if (currentBlock && !isDragging && !isResizing && !isPanning && !isDrawingArrow && mouseMoved) {                isDragging = true;                document.body.style.cursor = 'grabbing';                dragInitialPositions = selection.filter(item => item.classList.contains('block')).map(item => ({                    el: item,                    x: item.offsetLeft,                    y: item.offsetTop                }));                dragInitialPositions.forEach(pos => {                    pos.el.style.transition = 'none';                    pos.el.classList.add('dragging');                });            }            if (isResizing) resizeBlock(e);            else if (isDragging) dragBlock(e);            else if (isPanning) panGrid(e);            else if (isDrawingArrow) drawArrow(e);            else if (isMarqueeSelecting) updateMarquee(e);        }        function handleMouseUp(e) {            const wasDraggingOrResizing = isDragging || isResizing;            if (isDrawingArrow) endArrow(e);                        if (isDragging) {                document.body.style.cursor = 'default';                dragInitialPositions.forEach(pos => {                    pos.el.style.transition = '';                    pos.el.classList.remove('dragging');                });                dragInitialPositions = [];            }            if (isResizing) {                document.body.style.cursor = 'default';                resizeInitialRect = null;            }            if (isPanning) {                document.body.style.cursor = 'default';            }                        if (isMarqueeSelecting) {                finalizeMarqueeSelection();                isMarqueeSelecting = false;                if(marqueeBox) marqueeBox.remove();                marqueeBox = null;            }            isDragging = false;            isResizing = false;            isPanning = false;            isDrawingArrow = false;            arrowStartBlock = null;            currentBlock = null;            if(wasDraggingOrResizing) {                recordState();            }        }        function handleGlobalMouseDown(e) {            if (document.getElementById('custom-color-picker') && !document.getElementById('custom-color-picker').classList.contains('hidden')) {                if (!e.target.closest('#custom-color-picker') && !e.target.closest('.color-picker-wrapper')) {                    colorPicker.hide();                }            }            if (isEditing && activeEditingElement) {                const currentBlockEl = activeEditingElement.closest('.block');                if (!currentBlockEl.contains(e.target) && !e.target.closest('.sidebar') && !e.target.closest('#custom-color-picker')) {                    finishEditing();                    e.stopPropagation();                    e.preventDefault();                }            }        }        function handleGridMouseDown(e) {            const isGridElement = e.target === grid || e.target === svgCanvas || e.target === container;            if (isGridElement) {                if (e.shiftKey || e.button === 1) {                    isPanning = true;                    document.body.style.cursor = 'grabbing';                    e.preventDefault();                 } else if (e.button === 0) {                    deselectAll();                    isMarqueeSelecting = true;                    marqueeBox = document.createElement('div');                    marqueeBox.className = 'marquee-box';                    document.body.appendChild(marqueeBox);                    marqueeStartX = e.clientX;                    marqueeStartY = e.clientY;                    marqueeBox.style.left = `${e.clientX}px`;                    marqueeBox.style.top = `${e.clientY}px`;                }            }        }        function handleGridContextMenu(e) {            e.preventDefault();            contextMenuX = e.clientX;            contextMenuY = e.clientY;            contextMenu.style.left = `${e.clientX}px`;            contextMenu.style.top = `${e.clientY}px`;            contextMenu.style.display = 'block';        }        function handleContextMenuClick(e) {            const action = e.target.dataset.action;            if (!action) return;                        const actionMap = {                'add-text': () => {                     lastBlockCreationAction = () => addNewBlock(currentLangStrings.menu_add_text);                    lastBlockCreationAction();                },                'add-media-file': () => {                    const fileInput = document.createElement('input');                    fileInput.type = 'file';                    fileInput.accept = 'image/*,video/*';                    lastBlockCreationAction = () => fileInput.click();                    fileInput.onchange = e => {                        const file = e.target.files[0];                        if (file) {                            const reader = new FileReader();                            reader.onload = res => {                                const dataUrl = res.target.result;                                if (file.type.startsWith('image/')) {                                    const img = new Image();                                    img.onload = () => {                                        const aspectRatio = img.height / img.width;                                        const maxWidth = 800;                                        const newWidth = Math.min(img.width, maxWidth);                                        const newHeight = newWidth * aspectRatio;                                        const html = `<img src="${dataUrl}" alt="User content">`;                                        addNewBlock(html, { width: `${newWidth}px`, height: `${newHeight}px` });                                    };                                    img.src = dataUrl;                                } else if (file.type.startsWith('video/')) {                                    const video = document.createElement('video');                                    video.onloadedmetadata = () => {                                        const aspectRatio = video.videoHeight / video.videoWidth;                                        const maxWidth = 800;                                        const newWidth = Math.min(video.videoWidth, maxWidth);                                        const newHeight = newWidth * aspectRatio;                                        const html = `<video src="${dataUrl}" controls></video>`;                                        addNewBlock(html, { width: `${newWidth}px`, height: `${newHeight}px` });                                    };                                    video.src = dataUrl;                                }                            };                            reader.readAsDataURL(file);                        }                    };                    lastBlockCreationAction();                },                 'import-pdf-file': () => {                    const fileInput = document.createElement('input');                    fileInput.type = 'file';                    fileInput.accept = '.pdf';                    fileInput.onchange = e => {                        const file = e.target.files[0];                        if (file) {                            importPdfFromFile(file);                        }                    };                    fileInput.click();                },                'add-media-link': () => {                    const createMediaLinkBlock = () => {                        const url = prompt(currentLangStrings.prompt_media_url);                        if (!url) return;                        let embedUrl;                        if (url.includes('youtube.com/watch?v=')) embedUrl = `https://www.youtube.com/embed/${new URL(url).searchParams.get('v')}`;                        else if (url.includes('youtu.be/')) embedUrl = `https://www.youtube.com/embed/${new URL(url).pathname.slice(1)}`;                        else if (url.includes('vimeo.com/')) embedUrl = `https://player.vimeo.com/video/${new URL(url).pathname.slice(1)}`;                        else if (url.includes('drive.google.com/file/d/')) {                            const match = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);                            if (match && match[1]) embedUrl = `https://drive.google.com/file/d/${match[1]}/preview`;                        }                        if (embedUrl) {                            addNewBlock(`<iframe src="${embedUrl}" allow="autoplay; fullscreen"></iframe>`, { width: '560px', height: '315px' });                        } else {                            const img = new Image();                            img.onload = () => {                                const aspectRatio = img.height / img.width;                                const maxWidth = 800;                                const newWidth = Math.min(img.width, maxWidth);                                const newHeight = newWidth * aspectRatio;                                const html = `<img src="${url}" alt="User content">`;                                addNewBlock(html, { width: `${newWidth}px`, height: `${newHeight}px` });                            };                            img.onerror = () => {                                showToast(currentLangStrings.toast_media_error);                            };                            img.src = url;                        }                    };                    lastBlockCreationAction = createMediaLinkBlock;                    lastBlockCreationAction();                },                'add-pdf-link': () => {                    const createPdfLinkBlock = () => {                        const url = prompt(currentLangStrings.prompt_pdf_url);                        if (url) {                            showToast(currentLangStrings.toast_pdf_importing.replace('{name}', 'URL'), 5000);                            fetch(url)                                .then(response => {                                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);                                    return response.arrayBuffer();                                })                                .then(arrayBuffer => processPdfData(arrayBuffer, url))                                .catch(e => {                                    console.error("Error fetching PDF from URL:", e);                                    showToast(currentLangStrings.toast_pdf_error);                                });                        }                    };                    lastBlockCreationAction = createPdfLinkBlock;                    lastBlockCreationAction();                },                'add-desmos-link': () => {                    const createDesmosBlock = () => {                        const desmosUrl = prompt(currentLangStrings.prompt_desmos_url);                        if (desmosUrl && desmosUrl.includes('desmos.com/calculator')) addNewBlock(`<iframe src="${desmosUrl}"></iframe>`, { width: '600px', height: '400px' });                        else if (desmosUrl) showToast('Invalid Desmos URL.');                    };                    lastBlockCreationAction = createDesmosBlock;                    lastBlockCreationAction();                },                'add-geogebra-link': () => {                    const createGeoGebraBlock = () => {                        const geoGebraUrl = prompt(currentLangStrings.prompt_geogebra_url);                        if (geoGebraUrl && geoGebraUrl.includes('geogebra.org')) {                            addNewBlock(`<iframe src="${geoGebraUrl}" style="border:0px;width:100%;height:100%;" allowfullscreen></iframe>`, { width: '600px', height: '450px' });                        } else if (geoGebraUrl) {                            showToast('Invalid GeoGebra URL.');                        }                    };                    lastBlockCreationAction = createGeoGebraBlock;                    lastBlockCreationAction();                },                'add-phet-link': () => {                    const createPhetBlock = () => {                        const phetUrl = prompt(currentLangStrings.prompt_phet_url);                        if (phetUrl && phetUrl.includes('phet.colorado.edu')) {                            addNewBlock(`<iframe src="${phetUrl}" style="border:0px;width:100%;height:100%;" allowfullscreen scrolling="no"></iframe>`, { width: '800px', height: '600px' });                        } else if (phetUrl) {                            showToast('Invalid PhET Colorado URL.');                        }                    };                    lastBlockCreationAction = createPhetBlock;                    lastBlockCreationAction();                }            };            if(actionMap[action]) actionMap[action]();            contextMenu.style.display = 'none';        }                function handleArrowClick(e) {            const group = e.target.closest('.arrow-group');            if (group) {                e.stopPropagation();                updateSelection(group, e.shiftKey);            }        }        function handleKeyDown(e) {            if (colorPicker && !colorPicker.isHidden() && e.key === 'Enter') {                e.preventDefault();                document.getElementById('color-picker-confirm').click();                return;            }            if (colorPicker && !colorPicker.isHidden() && e.key === 'Escape') {                e.preventDefault();                document.getElementById('color-picker-cancel').click();                return;            }            if (isEditing) return;                        if (e.ctrlKey && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {                e.preventDefault();                undo();            }            if (e.ctrlKey && e.shiftKey && (e.key === 'z' || e.key === 'Z')) {                e.preventDefault();                redo();            }            if (e.key === 'ArrowRight' || e.key === 'PageDown') {                e.preventDefault();                goToNextPage();            }            if (e.key === 'ArrowLeft' || e.key === 'PageUp') {                e.preventDefault();                goToPrevPage();            }            if (e.key === 'Control') {                ctrlPressed = true;                if (!isArrowMode) {                    document.body.classList.add('arrow-mode');                }            }            if (e.key === 'Delete') {                selection.forEach(item => {                    if (item.classList.contains('block')) {                        const blockId = item.id;                        svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(a => {                            const arrowLine = a.querySelector('.arrow-line');                            if (arrowLine) {                                const endMarkerUrl = arrowLine.getAttribute('marker-end');                                if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();                                const startMarkerUrl = arrowLine.getAttribute('marker-start');                                if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();                            }                            a.remove();                        });                        item.remove();                    } else if (item.classList.contains('arrow-group')) {                        const arrowLine = item.querySelector('.arrow-line');                        if (arrowLine) {                            const endMarkerUrl = arrowLine.getAttribute('marker-end');                            if (endMarkerUrl) document.getElementById(endMarkerUrl.slice(5, -1))?.remove();                            const startMarkerUrl = arrowLine.getAttribute('marker-start');                            if (startMarkerUrl) document.getElementById(startMarkerUrl.slice(5, -1))?.remove();                        }                        item.remove();                    }                });                deselectAll();                recordState();            }            if (e.key === 'b' || e.key === 'B') {                e.preventDefault();                showSmartColorPicker();            }            if(e.key === 'g' || e.key === 'G') {                e.preventDefault();                sidebar.classList.toggle('hidden');            }            if(e.key === 'n' || e.key === 'N') {                e.preventDefault();                coordsDisplay.classList.toggle('hidden');            }            if (e.shiftKey && e.key === '+') {                e.preventDefault();                addNewPage();            }            if(e.shiftKey && e.key === '-') {                e.preventDefault();                deleteCurrentPage();            }            if (e.shiftKey && (e.key === 'd' || e.key === 'D')) {                e.preventDefault();                if (selection.length > 0) duplicateSelection();                else lastBlockCreationAction();            }            if (e.shiftKey && (e.key === 'a' || e.key === 'A')) {                e.preventDefault();                contextMenuX = lastMouseX;                contextMenuY = lastMouseY;                contextMenu.style.left = `${lastMouseX}px`;                contextMenu.style.top = `${lastMouseY}px`;                contextMenu.style.display = 'block';            }            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); saveAllPages(); }            if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) { e.preventDefault(); fileLoader.click(); }            if (e.key === 'h' || e.key === 'H') { e.preventDefault(); shortcutHint.style.display = shortcutHint.style.display === 'none' ? 'block' : 'none'; }        }        function handleKeyUp(e) {            if (e.key === 'Control') {                ctrlPressed = false;                if (!toggleArrowModeBtn.classList.contains('active')) {                     document.body.classList.remove('arrow-mode');                }            }        }                function handleDynamicTextUpdate() {            if (!isEditing || !activeEditingElement) return;            const block = activeEditingElement.closest('.block');            block.contentModel = parseContent(activeEditingElement);            activeContentModel = JSON.parse(JSON.stringify(block.contentModel));        }        function startEditing(block) {            const contentEl = block.querySelector('.block-content');            if (contentEl.querySelector('iframe, video, img')) return;            sidebar.classList.remove('hidden');            isEditing = true;            activeEditingElement = contentEl;            activeContentModel = JSON.parse(JSON.stringify(block.contentModel));             contentEl.contentEditable = true;            contentEl.addEventListener('input', handleDynamicTextUpdate);             contentEl.focus();            updateCustomizePanel();        }        function finishEditing() {            if (!isEditing || !activeEditingElement) return;            const block = activeEditingElement.closest('.block');                        activeEditingElement.removeEventListener('input', handleDynamicTextUpdate);                         block.contentModel = parseContent(activeEditingElement);            isEditing = false;            activeEditingElement.contentEditable = false;            activeEditingElement = null;            activeContentModel = [];            updateArrowsForBlock(block);            recordState();        }                function resizeBlock(e) {            if (!isResizing || !currentBlock || !resizeInitialRect) return;            const dx = (e.clientX - startX) / scale;            const dy = (e.clientY - startY) / scale;                        let newWidth = resizeInitialRect.width;            let newHeight = resizeInitialRect.height;            let newLeft = resizeInitialRect.left;            let newTop = resizeInitialRect.top;                        const gridSize = 30;            if (resizeDirection.includes('e')) {                let tempWidth = resizeInitialRect.width + dx;                if (isSnapEnabled) {                    const newRight = resizeInitialRect.left + tempWidth;                    const snappedRight = Math.round(newRight / gridSize) * gridSize;                    newWidth = snappedRight - resizeInitialRect.left;                } else {                    newWidth = tempWidth;                }            }            if (resizeDirection.includes('w')) {                let tempLeft = resizeInitialRect.left + dx;                if (isSnapEnabled) {                    newLeft = Math.round(tempLeft / gridSize) * gridSize;                } else {                    newLeft = tempLeft;                }                newWidth = resizeInitialRect.width + (resizeInitialRect.left - newLeft);            }            if (resizeDirection.includes('s')) {                let tempHeight = resizeInitialRect.height + dy;                if (isSnapEnabled) {                    const newBottom = resizeInitialRect.top + tempHeight;                    const snappedBottom = Math.round(newBottom / gridSize) * gridSize;                    newHeight = snappedBottom - resizeInitialRect.top;                } else {                    newHeight = tempHeight;                }            }            if (resizeDirection.includes('n')) {                let tempTop = resizeInitialRect.top + dy;                if (isSnapEnabled) {                    newTop = Math.round(tempTop / gridSize) * gridSize;                } else {                    newTop = tempTop;                }                newHeight = resizeInitialRect.height + (resizeInitialRect.top - newTop);            }                        const minSize = 50;            if (newWidth >= minSize) {                currentBlock.style.width = `${newWidth}px`;                currentBlock.style.left = `${newLeft}px`;            }            if (newHeight >= minSize) {                currentBlock.style.height = `${newHeight}px`;                currentBlock.style.top = `${newTop}px`;            }                        updateArrowsForBlock(currentBlock);        }        function dragBlock(e) {            const dx = (e.clientX - startX) / scale;            const dy = (e.clientY - startY) / scale;            const gridSize = 30;            dragInitialPositions.forEach(pos => {                const newX = pos.x + dx;                const newY = pos.y + dy;                if (isSnapEnabled) {                    pos.el.style.left = `${Math.max(0, Math.round(newX / gridSize) * gridSize)}px`;                    pos.el.style.top = `${Math.max(0, Math.round(newY / gridSize) * gridSize)}px`;                } else {                    pos.el.style.left = `${Math.max(0, newX)}px`;                    pos.el.style.top = `${Math.max(0, newY)}px`;                }                                const finalX = parseFloat(pos.el.style.left);                const finalY = parseFloat(pos.el.style.top);                const blockRight = finalX + pos.el.offsetWidth;                const blockBottom = finalY + pos.el.offsetHeight;                const expansionBuffer = 200;                const expansionAmount = 1000;                if (blockRight > grid.offsetWidth - expansionBuffer) {                    grid.style.width = `${grid.offsetWidth + expansionAmount}px`;                }                if (blockBottom > grid.offsetHeight - expansionBuffer) {                    grid.style.height = `${grid.offsetHeight + expansionAmount}px`;                }                updateArrowsForBlock(pos.el);            });            updateCoordinates();        }                function panGrid(e) {            gridX = Math.min(0, gridX + e.movementX);            gridY = Math.min(0, gridY + e.movementY);            updateGridTransform();        }        function handleZoom(e) {            e.preventDefault();            const scaleAmount = 0.05;            let mousePoint = screenToGridCoords(e.clientX, e.clientY);                        if (gridX === 0) mousePoint.x = 0;            if (gridY === 0) mousePoint.y = 0;                        const oldScale = scale;            if (e.deltaY < 0) scale += scaleAmount;            else scale -= scaleAmount;                        scale = Math.max(0.1, Math.min(scale, 3));            gridX += mousePoint.x * (oldScale - scale);            gridY += mousePoint.y * (oldScale - scale);                        gridX = Math.min(0, gridX);            gridY = Math.min(0, gridY);            updateGridTransform();            updateCoordinates(e);        }        function toggleArrowMode() {            isArrowMode = !isArrowMode;            document.body.classList.toggle('arrow-mode', isArrowMode);            toggleArrowModeBtn.classList.toggle('active', isArrowMode);        }        function startArrow(e, block) {            const startPoint = getBlockCenter(block);            const tempGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');            tempArrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');            tempArrow.setAttribute('x1', startPoint.x);             tempArrow.setAttribute('y1', startPoint.y);            tempArrow.setAttribute('x2', startPoint.x);             tempArrow.setAttribute('y2', startPoint.y);            tempArrow.setAttribute('stroke', '#3498db');             tempArrow.setAttribute('stroke-width', '3');            const marker = createOrUpdateMarker('temp-arrowhead', '#3498db', 10);            marker.setAttribute('orient', 'auto');            tempArrow.setAttribute('marker-end', 'url(#temp-arrowhead)');            tempGroup.appendChild(tempArrow);            svgCanvas.appendChild(tempGroup);        }        function drawArrow(e) {            if (!tempArrow) return;            const coords = screenToGridCoords(e.clientX, e.clientY);            tempArrow.setAttribute('x2', coords.x);            tempArrow.setAttribute('y2', coords.y);        }                let cr='<i class="fa fa-copyright" aria-hidden="true"></i> Bernardo Teixeira Mendonça - 09/072024';        function endArrow(e) {            const tempGroup = tempArrow.parentElement;            if (!mouseMoved) {                tempGroup?.remove();                document.getElementById('temp-arrowhead')?.remove();                tempArrow = null;                return;            }            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);            const endBlock = elementUnderCursor ? elementUnderCursor.closest('.block') : null;            const reverseArrow = endBlock ? svgCanvas.querySelector(`.arrow-group[data-start-block="${endBlock.id}"][data-end-block="${arrowStartBlock.id}"]`) : null;            if (reverseArrow) {                const reverseLine = reverseArrow.querySelector('.arrow-line');                const color = reverseLine.getAttribute('stroke');                const strokeWidth = parseFloat(reverseLine.getAttribute('stroke-width')) || 3;                const headSize = strokeWidth * 3 + 5;                                const startMarkerId = `arrowhead-start-${endBlock.id}-${arrowStartBlock.id}`;                const marker = createOrUpdateMarker(startMarkerId, color, headSize);                marker.setAttribute('orient', 'auto-start-reverse');                                reverseLine.setAttribute('marker-start', `url(#${startMarkerId})`);                reverseArrow.dataset.bidirectional = 'true';                                tempGroup?.remove();                recordState();            } else if (endBlock && endBlock !== arrowStartBlock) {                const arrowExists = svgCanvas.querySelector(`.arrow-group[data-start-block="${arrowStartBlock.id}"][data-end-block="${endBlock.id}"]`);                if (arrowExists) {                    tempGroup?.remove();                } else {                    const arrowLine = tempArrow;                    const color = arrowLine.getAttribute('stroke');                    const strokeWidth = parseFloat(arrowLine.getAttribute('stroke-width')) || 3;                    const headSize = strokeWidth * 3 + 5;                                        const markerId = `arrowhead-end-${arrowStartBlock.id}-${endBlock.id}`;                    const marker = createOrUpdateMarker(markerId, color, headSize);                    marker.setAttribute('orient', 'auto');                    arrowLine.setAttribute('marker-end', `url(#${markerId})`);                    tempGroup.classList.add('arrow-group');                    tempGroup.dataset.startBlock = arrowStartBlock.id;                    tempGroup.dataset.endBlock = endBlock.id;                                        arrowLine.classList.add('arrow-line');                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');                    hitbox.classList.add('arrow-hitbox');                    tempGroup.appendChild(hitbox);                    updateSingleArrow(tempGroup);                    if (selection.includes(arrowStartBlock) && selection.includes(endBlock)) {                        updateSelection(tempGroup, true);                    }                    recordState();                }            } else {                 tempGroup?.remove();             }                        document.getElementById('temp-arrowhead')?.remove();            tempArrow = null;        }                function updateMarquee(e) {            if (!marqueeBox) return;            const x = Math.min(e.clientX, marqueeStartX);            const y = Math.min(e.clientY, marqueeStartY);            const width = Math.abs(e.clientX - marqueeStartX);            const height = Math.abs(e.clientY - marqueeStartY);            marqueeBox.style.left = `${x}px`;            marqueeBox.style.top = `${y}px`;            marqueeBox.style.width = `${width}px`;            marqueeBox.style.height = `${height}px`;            const marqueeRect = marqueeBox.getBoundingClientRect();            document.querySelectorAll('.block').forEach(block => {                const blockRect = block.getBoundingClientRect();                const isIntersecting = !(marqueeRect.right < blockRect.left ||                                        marqueeRect.left > blockRect.right ||                                        marqueeRect.bottom < blockRect.top ||                                        marqueeRect.top > blockRect.bottom);                block.classList.toggle('pre-selected', isIntersecting);            });        }        function finalizeMarqueeSelection() {            deselectAll();            const newlySelected = [];            document.querySelectorAll('.block.pre-selected').forEach(block => {                block.classList.remove('pre-selected');                block.classList.add('selected');                newlySelected.push(block);            });            selection = newlySelected;            if (selection.length > 0) {                lastSelectedItem = selection[selection.length - 1];            }            updateUIState();        }        function createOrUpdateMarker(id, color, size = 10) {            let marker = document.getElementById(id);            if (!marker) {                marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');                marker.setAttribute('id', id);                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');                marker.appendChild(polygon);                svgDefs.appendChild(marker);            }            const width = Number(size);            const height = width * 0.7;                        marker.setAttribute('markerWidth', width);            marker.setAttribute('markerHeight', height);            marker.setAttribute('refX', width * 0.9);            marker.setAttribute('refY', height / 2);                        const polygon = marker.querySelector('polygon');            polygon.setAttribute('points', `0 0, ${width} ${height / 2}, 0 ${height}`);            polygon.setAttribute('fill', color);            return marker;        }        function updateSingleArrow(arrowGroup) {            const startBlock = document.getElementById(arrowGroup.dataset.startBlock);            const endBlock = document.getElementById(arrowGroup.dataset.endBlock);            if (!startBlock || !endBlock) return;            const arrowLine = arrowGroup.querySelector('.arrow-line');            const hitbox = arrowGroup.querySelector('.arrow-hitbox');            if (!arrowLine || !hitbox) return;                        const startPoint = getClosestConnectionPoint(startBlock, endBlock);            const endPoint = getClosestConnectionPoint(endBlock, startBlock);            [arrowLine, hitbox].forEach(el => {                el.setAttribute('x1', startPoint.x);                 el.setAttribute('y1', startPoint.y);                el.setAttribute('x2', endPoint.x);                 el.setAttribute('y2', endPoint.y);            });                        const color = arrowLine.getAttribute('stroke') || '#3498db';            const strokeWidth = parseFloat(arrowLine.getAttribute('stroke-width')) || 3;            const headSize = strokeWidth * 3 + 5;                         const endMarkerUrl = arrowLine.getAttribute('marker-end');            if (endMarkerUrl) {                createOrUpdateMarker(endMarkerUrl.slice(5, -1), color, headSize);            }            const startMarkerUrl = arrowLine.getAttribute('marker-start');            if (startMarkerUrl) {                createOrUpdateMarker(startMarkerUrl.slice(5, -1), color, headSize);            }        }        function updateArrowsForBlock(block) {            const blockId = block.id;            svgCanvas.querySelectorAll(`[data-start-block="${blockId}"], [data-end-block="${blockId}"]`).forEach(updateSingleArrow);        }        function updateCoordinates(e = null) {            if (isEditingCoords) return;            if (selection.length > 1) {                coordsDisplay.innerHTML = `${selection.length} ${currentLangStrings.coords_items} | Z: ${Math.round(scale * 100)}%`;            } else if (selection.length === 1) {                const item = selection[0];                if (item.classList.contains('block')) {                    const x = parseInt(item.style.left);                    const y = parseInt(item.style.top);                    coordsDisplay.innerHTML = `X: ${x}, Y: ${y} | Z: ${Math.round(scale * 100)}%`;                } else if (item.classList.contains('arrow-group')) {                    coordsDisplay.innerHTML = `${currentLangStrings.coords_arrow} | Z: ${Math.round(scale * 100)}%`;                }            } else if (e) {                const mouseCoords = screenToGridCoords(e.clientX, e.clientY);                coordsDisplay.innerHTML = `X: ${Math.round(mouseCoords.x)}, Y: ${Math.round(mouseCoords.y)} | Z: ${Math.round(scale * 100)}%`;            } else {                coordsDisplay.innerHTML = `${currentLangStrings.coords_nothing} | Z: ${Math.round(scale * 100)}%`;            }        }                function editCoordinates(e) {            if (e.target.tagName === 'INPUT' || isEditingCoords) return;            e.stopPropagation();            const blockToEdit = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : null;            if (!blockToEdit) return;            isEditingCoords = true;            const x = parseInt(blockToEdit.style.left);             const y = parseInt(blockToEdit.style.top);            coordsDisplay.innerHTML = `X: <input type="number" value="${x}" id="coord-x"> Y: <input type="number" value="${y}" id="coord-y">`;                        const inputX = document.getElementById('coord-x');             const inputY = document.getElementById('coord-y');            inputX.focus();             inputX.select();            const applyAndClose = () => {                const newX = parseInt(inputX.value || 0);                const newY = parseInt(inputY.value || 0);                const gridSize = 30;                blockToEdit.style.left = `${Math.max(0, Math.round(newX / gridSize) * gridSize)}px`;                blockToEdit.style.top = `${Math.max(0, Math.round(newY / gridSize) * gridSize)}px`;                                isEditingCoords = false;                updateArrowsForBlock(blockToEdit);                 updateCoordinates();                document.removeEventListener('click', handleClickOutside, true);                document.removeEventListener('keydown', handleInputKeyDown, true);                recordState();            };            const handleInputKeyDown = (e) => {                if (e.key === 'Enter') {                    e.preventDefault();                    applyAndClose();                } else if (e.key === 'Escape') {                    e.preventDefault();                    isEditingCoords = false;                    updateCoordinates();                     document.removeEventListener('click', handleClickOutside, true);                    document.removeEventListener('keydown', handleInputKeyDown, true);                }            };            const handleClickOutside = (e) => {                if (!coordsDisplay.contains(e.target)) {                    applyAndClose();                }            };                        setTimeout(() => {                document.addEventListener('click', handleClickOutside, true);                document.addEventListener('keydown', handleInputKeyDown, true);            }, 0);        }        const nonColorInputs = {            handleVisible: document.getElementById('handle-visible'),            textSize: document.getElementById('text-size'),            textFont: document.getElementById('text-font'),            linkSrc: document.getElementById('link-src'),            arrowWidth: document.getElementById('arrow-width'),            boldBtn: document.getElementById('bold-btn'),            italicBtn: document.getElementById('italic-btn'),            underlineBtn: document.getElementById('underline-btn'),        };        const controlGroups = {            block: document.getElementById('block-controls'),             handle: document.getElementById('handle-controls'),            text: document.getElementById('text-controls'),             link: document.getElementById('link-controls'),            arrow: document.getElementById('arrow-controls'),            grid: document.getElementById('grid-controls')        }        function updateCustomizePanel() {            const hasBlock = selection.some(item => item.classList.contains('block'));            const hasArrow = selection.some(item => item.classList.contains('arrow-group'));            const lastSelectedBlock = lastSelectedItem?.classList.contains('block') ? lastSelectedItem : selection.find(i => i.classList.contains('block'));            const hasIframe = lastSelectedBlock?.querySelector('iframe');                        controlGroups.block.classList.toggle('hidden', !hasBlock);            controlGroups.handle.classList.toggle('hidden', !hasBlock);            controlGroups.arrow.classList.toggle('hidden', !hasArrow);            controlGroups.grid.classList.toggle('hidden', hasBlock || hasArrow);                        controlGroups.text.classList.toggle('hidden', !hasBlock || hasIframe);            controlGroups.link.classList.toggle('hidden', !hasIframe);            if (hasBlock && lastSelectedBlock) {                const computed = getComputedStyle(lastSelectedBlock);                document.querySelector('[data-color-target="blockBg"]').style.background = computed.backgroundColor;                document.querySelector('[data-color-target="blockBorder"]').style.background = computed.borderColor;                document.querySelector('[data-color-target="handle"]').style.background = computed.getPropertyValue('--handle-color').trim() || '#808080';                                nonColorInputs.handleVisible.checked = computed.getPropertyValue('--handle-display').trim() !== 'none';                if (hasIframe) {                    nonColorInputs.linkSrc.value = hasIframe.src;                } else {                    if (isEditing) updateTextControlsOnSelectionChange();                    else {                         const styles = getStyleOfFirstCharacter(lastSelectedBlock.contentModel);                        document.querySelector('[data-color-target="text"]').style.background = styles.color || '#f9fafb';                    }                }            }            if (hasArrow) {                const arrowToSample = lastSelectedItem?.classList.contains('arrow-group') ? lastSelectedItem : selection.find(i => i.classList.contains('arrow-group'));                if (arrowToSample) {                    const arrowLine = arrowToSample.querySelector('.arrow-line');                    const color = arrowLine.getAttribute('stroke') || '#f9fafb';                    document.querySelector('[data-color-target="arrow"]').style.background = color;                    nonColorInputs.arrowWidth.value = arrowLine.getAttribute('stroke-width');                }            }                        const bodyStyle = getComputedStyle(document.body);            const gridStyle = getComputedStyle(grid);            document.querySelector('[data-color-target="gridBg"]').style.background = bodyStyle.backgroundImage;            const gridLineColorMatch = gridStyle.backgroundImage.match(/rgba?\((\d+,\s*\d+,\s*\d+,\s*[\d.]+)\)/);            document.querySelector('[data-color-target="gridLines"]').style.background = gridLineColorMatch ? `rgb(${gridLineColorMatch[1]})` : 'rgba(255,255,255,0.1)';        }        nonColorInputs.boldBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ fontWeight: 'bold' }); });        nonColorInputs.italicBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ fontStyle: 'italic' }); });        nonColorInputs.underlineBtn.addEventListener('mousedown', e => { e.preventDefault(); applyStyleToSelection({ textDecoration: 'underline' }); });        nonColorInputs.textSize.addEventListener('change', e => applyStyleToSelection({ fontSize: `${e.target.value}px` }));        nonColorInputs.textFont.addEventListener('change', e => applyStyleToSelection({ fontFamily: e.target.value }));                nonColorInputs.handleVisible.addEventListener('change', e => {            const value = e.target.checked ? 'block' : 'none';            selection.forEach(i => i.classList.contains('block') && i.style.setProperty('--handle-display', value));            recordState();        });                nonColorInputs.linkSrc.addEventListener('change', recordState);        const updateSelectedArrows = (widthValue) => {            selection.forEach(item => {                if (item.classList.contains('arrow-group')) {                    const arrowLine = item.querySelector('.arrow-line');                    arrowLine.setAttribute('stroke-width', widthValue);                    updateSingleArrow(item);                }            });        };        nonColorInputs.arrowWidth.addEventListener('input', e => updateSelectedArrows(e.target.value));        nonColorInputs.arrowWidth.addEventListener('change', recordState);        function updateTextControlsOnSelectionChange() {            if (!isEditing || !activeEditingElement) return;            const selection = window.getSelection();            if (selection.rangeCount === 0 || selection.isCollapsed) {                const { index } = getSelectionIndices(activeEditingElement);                const styles = getStyleAtCharacterIndex(index > 0 ? index - 1 : 0);                updateToolbarUI(styles);                return;            };            const styles = getCommonStyleInSelection();            updateToolbarUI(styles);        }        function updateToolbarUI(styles) {            if (!styles) return;            nonColorInputs.boldBtn.classList.toggle('active', styles.fontWeight === 'bold');            nonColorInputs.italicBtn.classList.toggle('active', styles.fontStyle === 'italic');            nonColorInputs.underlineBtn.classList.toggle('active', styles.textDecoration === 'underline');            const currentSize = Math.round(parseFloat(styles.fontSize)) || 15;            let closestOption = nonColorInputs.textSize.options[0];            for (const option of nonColorInputs.textSize.options) {                if (Math.abs(option.value - currentSize) <= Math.abs(closestOption.value - currentSize)) {                    closestOption = option;                }            }            nonColorInputs.textSize.value = closestOption.value;            const fontOption = Array.from(nonColorInputs.textFont.options).find(opt => (styles.fontFamily || "").includes(opt.value));            nonColorInputs.textFont.value = fontOption ? fontOption.value : nonColorInputs.textFont.options[0].value;                        document.querySelector('[data-color-target="text"]').style.background = styles.color || '#f9fafb';        }        let colorPicker = null;        function initializeColorPickers() {            colorPicker = createColorPicker();            document.querySelectorAll('.color-picker-wrapper').forEach(wrapper => {                wrapper.addEventListener('mousedown', (e) => {                    e.preventDefault();                    e.stopPropagation();                                        const targetType = wrapper.dataset.colorTarget;                    let initialColor = wrapper.style.backgroundColor || 'rgba(255, 255, 255, 1)';                    colorPicker.show(initialColor, (newColor) => {                        handleColorConfirm(targetType, newColor);                        recordState();                    });                                        const rect = wrapper.getBoundingClientRect();                    colorPicker.setPosition(rect.left - 250, rect.top);                });            });        }                function handleColorConfirm(targetType, color) {            const actions = {                'blockBg': () => selection.forEach(item => item.classList.contains('block') && (item.style.backgroundColor = color)),                'blockBorder': () => selection.forEach(item => item.classList.contains('block') && (item.style.borderColor = color)),                'handle': () => selection.forEach(item => item.classList.contains('block') && item.style.setProperty('--handle-color', color)),                'text': () => applyStyleToSelection({ color: color }),                'arrow': () => selection.forEach(item => { if (item.classList.contains('arrow-group')) { item.querySelector('.arrow-line').setAttribute('stroke', color); updateSingleArrow(item); }}),                'gridBg': () => document.body.style.background = color,                'gridLines': () => grid.style.backgroundImage = `radial-gradient(${color} 1px, transparent 1px)`            };            if (actions[targetType]) {                actions[targetType]();                updateCustomizePanel();            }        }        function showSmartColorPicker() {            let targetType = 'gridBg';            let initialColor = document.body.style.background;            if (isEditing && activeEditingElement) {                targetType = 'text';                initialColor = getCommonStyleInSelection()?.color || '#f9fafb';            } else if (lastSelectedItem?.classList.contains('block')) {                targetType = 'blockBg';                initialColor = getComputedStyle(lastSelectedItem).backgroundColor;            } else if (lastSelectedItem?.classList.contains('arrow-group')) {                targetType = 'arrow';                initialColor = lastSelectedItem.querySelector('.arrow-line').getAttribute('stroke');            }                        colorPicker.show(initialColor, (newColor) => {                handleColorConfirm(targetType, newColor);                recordState();            });            colorPicker.setPosition(lastMouseX, lastMouseY);        }        function recordState() {            saveCurrentPageState();             if (historyIndex < history.length - 1) {                history = history.slice(0, historyIndex + 1);            }            const state = {                pages: JSON.parse(JSON.stringify(pages)),                currentPageIndex: currentPageIndex            };            history.push(state);            if (history.length > MAX_HISTORY_STATES) {                history.shift();            }            historyIndex = history.length - 1;        }        function loadState(state) {            if (!state) return;            pages = JSON.parse(JSON.stringify(state.pages));            currentPageIndex = state.currentPageIndex;            loadPage(currentPageIndex, true);        }        function undo() {            if (historyIndex > 0) {                historyIndex--;                loadState(history[historyIndex]);            }        }        function redo() {            if (historyIndex < history.length - 1) {                historyIndex++;                loadState(history[historyIndex]);            }        }        function saveCurrentPageState() {            if (isEditing) finishEditing();            if (pages.length === 0 || currentPageIndex < 0) return;            pages[currentPageIndex] = {                blocks: Array.from(document.querySelectorAll('.block')).map(block => ({                    id: block.id,                    contentModel: block.contentModel,                    x: parseInt(block.style.left),                    y: parseInt(block.style.top),                    width: block.style.width,                    height: block.style.height,                    bgColor: block.style.backgroundColor,                    borderColor: block.style.borderColor,                    handleColor: block.style.getPropertyValue('--handle-color'),                    handleDisplay: block.style.getPropertyValue('--handle-display'),                })),                arrows: Array.from(svgCanvas.querySelectorAll('.arrow-group')).map(arrowGroup => {                    const arrowLine = arrowGroup.querySelector('.arrow-line');                    return {                        startBlock: arrowGroup.dataset.startBlock,                        endBlock: arrowGroup.dataset.endBlock,                        color: arrowLine.getAttribute('stroke'),                        width: arrowLine.getAttribute('stroke-width'),                        bidirectional: arrowGroup.dataset.bidirectional === 'true',                    };                }),                styles: {                    gridBg: document.body.style.background,                    gridLines: grid.style.backgroundImage,                },                viewport: { gridX, gridY, scale }            };        }        function loadPage(index, isFirstLoad = false) {            if (!isFirstLoad && currentPageIndex >= 0) {                saveCurrentPageState();            }            if (index < 0 || index >= pages.length) return;            currentPageIndex = index;            const pageState = pages[currentPageIndex];            applyPageState(pageState, isFirstLoad);            updatePageUI();        }        function applyPageState(state, isFirstLoad = false) {            document.querySelectorAll('.block').forEach(b => b.remove());            svgCanvas.querySelectorAll('.arrow-group').forEach(ag => ag.remove());                        const glowFilter = svgDefs.querySelector('#selection-glow');            svgDefs.innerHTML = '';            if (glowFilter) svgDefs.appendChild(glowFilter);            deselectAll();                        // Corrige o problema do posicionamento inicial            if (isFirstLoad) {                gridX = 0;                gridY = 0;                scale = state.viewport?.scale || 0.9;            } else {                gridX = state.viewport?.gridX || 0;                gridY = state.viewport?.gridY || 0;                scale = state.viewport?.scale || 1;            }            updateGridTransform();            document.body.style.background = state.styles?.gridBg || 'linear-gradient(90deg, var(--background-start), var(--background-end), var(--background-start))';            grid.style.backgroundImage = state.styles?.gridLines || `radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px)`;                        let maxId = 0;            if (state.blocks && Array.isArray(state.blocks)) {                state.blocks.forEach(b => {                    if (b && b.id) {                        const idNum = parseInt(b.id.split('-')[1]);                        if (!isNaN(idNum) && idNum > maxId) maxId = idNum;                    }                });            }            blockCounter = maxId + 1;            if (state.blocks && Array.isArray(state.blocks)) {                state.blocks.forEach(blockConfig => {                    if(blockConfig) createBlock(blockConfig);                });            }            if (state.arrows && Array.isArray(state.arrows)) {                state.arrows.forEach(arrowData => {                    if(arrowData) {                        const startBlock = document.getElementById(arrowData.startBlock);                        const endBlock = document.getElementById(arrowData.endBlock);                        if (startBlock && endBlock) createArrow(arrowData);                    }                });            }        }                function updatePageUI() {            pageDisplay.textContent = `${currentLangStrings.sidebar_slides} ${currentPageIndex + 1} / ${pages.length}`;            prevPageBtn.disabled = currentPageIndex === 0;            nextPageBtn.disabled = currentPageIndex >= pages.length - 1;            deletePageBtn.disabled = pages.length <= 1;        }        function addNewPage() {            saveCurrentPageState();            const newPage = {                blocks: [],                arrows: [],                viewport: { gridX: 0, gridY: 0, scale: 1 },                styles: {                    gridBg: document.body.style.background,                    gridLines: grid.style.backgroundImage,                }            };            pages.push(newPage);            loadPage(pages.length - 1);            recordState();            showToast(currentLangStrings.toast_page_added.replace('{page}', pages.length));        }        function deleteCurrentPage() {            if (pages.length <= 1) {                showToast(currentLangStrings.toast_cant_delete_last);                return;            }            const pageHasContent = pages[currentPageIndex] && pages[currentPageIndex].blocks.length > 0;            let confirmed = true;            if (pageHasContent) {                confirmed = window.confirm("Este slide tem conteúdo. Tem certeza que deseja deletá-lo?");            }            if (confirmed) {                const deletedPageIndex = currentPageIndex + 1;                pages.splice(currentPageIndex, 1);                const newIndex = Math.min(currentPageIndex, pages.length - 1);                loadPage(newIndex, true);                 recordState();                showToast(currentLangStrings.toast_page_deleted.replace('{page}', deletedPageIndex));            }        }                function goToNextPage() {            if (currentPageIndex < pages.length - 1) loadPage(currentPageIndex + 1);        }        function goToPrevPage() {            if (currentPageIndex > 0) loadPage(currentPageIndex - 1);        }        function importPdfFromFile(file) {            const fileReader = new FileReader();            fileReader.onload = function() {                processPdfData(this.result, file.name);            };            fileReader.readAsArrayBuffer(file);        }        async function processPdfData(pdfData, sourceName) {            showToast(currentLangStrings.toast_pdf_importing.replace('{name}', sourceName), 10000);            try {                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;                const wasEmpty = pages.length === 1 && pages[0].blocks.length === 0;                if (wasEmpty) {                    pages.shift();                } else {                    saveCurrentPageState();                }                const importStartIndex = pages.length;                for (let i = 1; i <= pdf.numPages; i++) {                    const page = await pdf.getPage(i);                    const renderScale = 2.0;                    const viewport = page.getViewport({ scale: renderScale });                                        const canvas = document.createElement('canvas');                    const context = canvas.getContext('2d');                    canvas.height = viewport.height;                    canvas.width = viewport.width;                    const renderContext = { canvasContext: context, viewport: viewport };                    await page.render(renderContext).promise;                    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);                                        const maxWidth = 1200;                    const blockWidth = viewport.width / renderScale > maxWidth ? maxWidth : viewport.width / renderScale;                    const blockHeight = blockWidth * (viewport.height / viewport.width);                    const gridCenter = screenToGridCoords((window.innerWidth - 300) / 2, window.innerHeight / 2);                    const blockX = Math.max(0, gridCenter.x - blockWidth / 2);                    const blockY = Math.max(0, gridCenter.y - blockHeight / 2);                                        const imageHtml = `<img src="${imageDataUrl}" style="width:100%; height:100%;" alt="PDF Page ${i}">`;                                        const newPage = {                        blocks: [{                            x: blockX,                            y: blockY,                            width: `${blockWidth}px`,                            height: `${blockHeight}px`,                            contentModel: [{ text: imageHtml, style: {}, isHTML: true }],                            id: `block-slide-${importStartIndex + i - 1}-${blockCounter++}`                        }],                        arrows: [],                        viewport: { gridX: 0, gridY: 0, scale: 1 },                        styles: {                            gridBg: document.body.style.background,                            gridLines: grid.style.backgroundImage,                        }                    };                    pages.push(newPage);                }                loadPage(importStartIndex, true);                recordState();                showToast(currentLangStrings.toast_pdf_success.replace('{numPages}', pdf.numPages), 3000);            } catch (error) {                console.error('Error importing PDF:', error);                showToast(currentLangStrings.toast_pdf_error, 3000);            }        }        function saveAllPages() {            saveCurrentPageState();            const state = {                formatVersion: "3.0",                pages: pages            };            download('mentmap-presentation.json', JSON.stringify(state, null, 2));        }        function loadAllPages(event) {            const file = event.target.files[0];            if (!file) return;            const reader = new FileReader();            reader.onload = (e) => {                try {                    const loadedData = JSON.parse(e.target.result);                    if (loadedData.pages && Array.isArray(loadedData.pages)) {                        pages = loadedData.pages;                    } else {                        pages = [loadedData];                    }                    loadPage(0, true);                    history = [];                    historyIndex = -1;                    recordState();                    showToast(currentLangStrings.toast_file_loaded);                } catch (err) {                    console.error('Error parsing JSON:', err);                    showToast(currentLangStrings.toast_file_error);                }            };            reader.readAsText(file);            fileLoader.value = '';        }        function duplicateSelection() {            const idMap = new Map();            const newSelection = [];            const offset = 30;            const selectedBlocks = selection.filter(item => item.classList.contains('block'));            const selectedArrows = selection.filter(item => item.classList.contains('arrow-group'));            selectedBlocks.forEach(block => {                const config = {                    x: parseInt(block.style.left) + offset,                    y: parseInt(block.style.top) + offset,                    width: block.style.width,                    height: block.style.height,                    contentModel: JSON.parse(JSON.stringify(block.contentModel)),                    bgColor: block.style.backgroundColor,                    borderColor: block.style.borderColor,                    handleColor: block.style.getPropertyValue('--handle-color'),                    handleDisplay: block.style.getPropertyValue('--handle-display'),                };                const newBlock = createBlock(config);                idMap.set(block.id, newBlock.id);                newSelection.push(newBlock);            });            selectedArrows.forEach(arrow => {                const startId = arrow.dataset.startBlock;                const endId = arrow.dataset.endBlock;                if (idMap.has(startId) && idMap.has(endId)) {                    const arrowLine = arrow.querySelector('.arrow-line');                    const newArrowData = {                        startBlock: idMap.get(startId),                        endBlock: idMap.get(endId),                        color: arrowLine.getAttribute('stroke'),                        width: arrowLine.getAttribute('stroke-width'),                        bidirectional: arrow.dataset.bidirectional === 'true',                    };                    const newArrowGroup = createArrow(newArrowData);                    newSelection.push(newArrowGroup);                }            });            deselectAll();            newSelection.forEach(item => updateSelection(item, true));            recordState();        }        function createArrow(arrowData) {            const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');            arrowGroup.classList.add('arrow-group');            arrowGroup.dataset.startBlock = arrowData.startBlock;            arrowGroup.dataset.endBlock = arrowData.endBlock;                        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');            arrowLine.classList.add('arrow-line');            arrowLine.setAttribute('stroke', arrowData.color);            arrowLine.setAttribute('stroke-width', arrowData.width);            const strokeWidth = parseFloat(arrowData.width) || 3;            const headSize = strokeWidth * 3 + 5;            const endMarkerId = `arrowhead-end-${arrowData.startBlock}-${arrowData.endBlock}`;            let marker = createOrUpdateMarker(endMarkerId, arrowData.color, headSize);            marker.setAttribute('orient', 'auto');            arrowLine.setAttribute('marker-end', `url(#${endMarkerId})`);            if (arrowData.bidirectional) {                arrowGroup.dataset.bidirectional = 'true';                const startMarkerId = `arrowhead-start-${arrowData.startBlock}-${arrowData.endBlock}`;                marker = createOrUpdateMarker(startMarkerId, arrowData.color, headSize);                marker.setAttribute('orient', 'auto-start-reverse');                arrowLine.setAttribute('marker-start', `url(#${startMarkerId})`);            }                        const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');            hitbox.classList.add('arrow-hitbox');            arrowGroup.appendChild(arrowLine);            arrowGroup.appendChild(hitbox);            svgCanvas.appendChild(arrowGroup);            updateSingleArrow(arrowGroup);            return arrowGroup;        }        function getBlockCenter(block) {            const x = parseInt(block.style.left);            const y = parseInt(block.style.top);            return { x: x + block.offsetWidth / 2, y: y + block.offsetHeight / 2 };        }                function getClosestConnectionPoint(from, to) {            const fromRect = { x: parseInt(from.style.left), y: parseInt(from.style.top), width: from.offsetWidth, height: from.offsetHeight };            const toRect = { x: parseInt(to.style.left), y: parseInt(to.style.top), width: to.offsetWidth, height: to.offsetHeight };            const fromCx = fromRect.x + fromRect.width / 2;            const fromCy = fromRect.y + fromRect.height / 2;            const toCx = toRect.x + toRect.width / 2;            const toCy = toRect.y + toRect.height / 2;            const dx = toCx - fromCx;            const dy = toCy - fromCy;            if (dx === 0 && dy === 0) return {x: fromCx, y: fromCy};            const angle = Math.atan2(dy, dx);            const fromHalfWidth = fromRect.width / 2;            const fromHalfHeight = fromRect.height / 2;            const fromAngle = Math.atan2(fromHalfHeight, fromHalfWidth);            let pointX, pointY;            const absAngle = Math.abs(angle);            if (absAngle > Math.PI - fromAngle || absAngle < fromAngle) {                let tan = Math.tan(angle);                pointX = dx > 0 ? fromCx + fromHalfWidth : fromCx - fromHalfWidth;                pointY = fromCy + (pointX - fromCx) * tan;            } else {                let cot = 1 / Math.tan(angle);                pointY = dy > 0 ? fromCy + fromHalfHeight : fromCy - fromHalfHeight;                pointX = fromCx + (pointY - fromCy) * cot;            }            return { x: pointX, y: pointY };        }                function download(filename, text) {            const element = document.createElement('a');            element.setAttribute('href', 'data:text/json;charset=utf-8,' + encodeURIComponent(text));            element.setAttribute('download', filename);            element.style.display = 'none';            document.body.appendChild(element);            element.click();            document.body.removeChild(element);        }        function createColorPicker() {            const picker = document.getElementById('custom-color-picker');            const header = picker.querySelector('.color-picker-header');            const spectrum = document.getElementById('color-spectrum');            const cursor = document.getElementById('spectrum-cursor');            const hueSlider = document.getElementById('hue-slider');            const opacitySlider = document.getElementById('opacity-slider');            const hexInput = document.getElementById('hex-input');            const rInput = document.getElementById('rgba-input-r');            const gInput = document.getElementById('rgba-input-g');            const bInput = document.getElementById('rgba-input-b');            const aInput = document.getElementById('rgba-input-a');            const confirmBtn = document.getElementById('color-picker-confirm');            const cancelBtn = document.getElementById('color-picker-cancel');            let state = { h: 0, s: 1, v: 1, a: 1 };            let onConfirmCallback = null;            function updateUI() {                const { r, g, b } = hsvToRgb(state.h, state.s, state.v);                                spectrum.style.background = `linear-gradient(to top, black, transparent), linear-gradient(to right, white, hsl(${state.h}, 100%, 50%))`;                opacitySlider.style.background = `linear-gradient(to right, transparent, rgb(${r},${g},${b}))`;                                cursor.style.left = `${state.s * 100}%`;                cursor.style.top = `${(1 - state.v) * 100}%`;                cursor.style.borderColor = state.v > 0.5 ? 'black' : 'white';                hexInput.value = rgbToHex(r, g, b);                rInput.value = r;                gInput.value = g;                bInput.value = b;                aInput.value = state.a.toFixed(2);            }            function updateFromInputs() {                const r = parseInt(rInput.value);                const g = parseInt(gInput.value);                const b = parseInt(bInput.value);                const a = parseFloat(aInput.value);                const { h, s, v } = rgbToHsv(r, g, b);                state = { h, s, v, a };                hueSlider.value = h;                opacitySlider.value = a;                updateUI();            }            function handleSpectrumMove(e) {                const rect = spectrum.getBoundingClientRect();                state.s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));                state.v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));                updateUI();            }                        spectrum.addEventListener('mousedown', e => {                handleSpectrumMove(e);                const onMouseMove = (moveE) => handleSpectrumMove(moveE);                const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove);                document.addEventListener('mousemove', onMouseMove);                document.addEventListener('mouseup', onMouseUp, { once: true });            });            hueSlider.addEventListener('input', () => { state.h = parseInt(hueSlider.value); updateUI(); });            opacitySlider.addEventListener('input', () => { state.a = parseFloat(opacitySlider.value); updateUI(); });                        [rInput,gInput,bInput,aInput].forEach(input => input.addEventListener('change', updateFromInputs));            hexInput.addEventListener('change', () => {                const { r, g, b } = hexToRgb(hexInput.value);                const { h, s, v } = rgbToHsv(r, g, b);                state.h = h; state.s = s; state.v = v;                updateUI();            });            confirmBtn.addEventListener('click', () => {                const { r, g, b } = hsvToRgb(state.h, state.s, state.v);                if (onConfirmCallback) onConfirmCallback(`rgba(${r}, ${g}, ${b}, ${state.a})`);                picker.classList.add('hidden');            });            cancelBtn.addEventListener('click', () => picker.classList.add('hidden'));            header.addEventListener('mousedown', e => {                let offsetX = e.clientX - picker.offsetLeft;                let offsetY = e.clientY - picker.offsetTop;                const onMouseMove = (moveE) => {                    picker.style.left = `${moveE.clientX - offsetX}px`;                    picker.style.top = `${moveE.clientY - offsetY}px`;                };                const onMouseUp = () => document.removeEventListener('mousemove', onMouseMove);                document.addEventListener('mousemove', onMouseMove);                document.addEventListener('mouseup', onMouseUp, { once: true });            });            function hsvToRgb(h, s, v) {                let r, g, b, i, f, p, q, t;                i = Math.floor(h / 60); f = h / 60 - i; p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);                switch (i % 6) { case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break; }                return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };            }            function rgbToHsv(r, g, b) {                r /= 255; g /= 255; b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, v = max, d = max - min; s = max === 0 ? 0 : d / max;                if (max === min) h = 0; else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; }                return { h: h * 360, s: s, v: v };            }            function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }            function hexToRgb(hex) {                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0};            }            function parseRgba(rgba) {                if (!rgba) return {r:0,g:0,b:0,a:1};                const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);                return match ? {r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]), a: match[4] !== undefined ? parseFloat(match[4]) : 1} : {r:255, g:255, b:255, a:1};            }            return {                show(initialColor, onConfirm) {                    onConfirmCallback = onConfirm;                    const {r, g, b, a} = parseRgba(initialColor);                    const {h, s, v} = rgbToHsv(r, g, b);                    state = {h, s, v, a};                    hueSlider.value = h;                    opacitySlider.value = a;                    updateUI();                    picker.classList.remove('hidden');                },                hide() { picker.classList.add('hidden'); },                isHidden() { return picker.classList.contains('hidden'); },                setPosition(x, y) {                    picker.style.left = `${Math.max(0, Math.min(x, window.innerWidth - picker.offsetWidth))}px`;                    picker.style.top = `${Math.max(0, Math.min(y, window.innerHeight - picker.offsetHeight))}px`;                }            };        }        // --- Mecanismo de Edição de Texto ---        function renderContent(model, element) {            element.innerHTML = '';            if (!model || model.length === 0) {                element.innerHTML = '<br>';                return;            }            model.forEach(span => {                if (span.isHTML) {                    element.insertAdjacentHTML('beforeend', span.text);                    return;                }                const spanEl = document.createElement('span');                spanEl.textContent = span.text;                                Object.entries(span.style).forEach(([key, value]) => {                    if (value) {                         spanEl.style[key] = value;                    }                });                element.appendChild(spanEl);            });        }        function parseContent(element, initialHTML = null) {            const model = [];            const source = initialHTML ? document.createElement('div') : element;            if (initialHTML) source.innerHTML = initialHTML;            source.childNodes.forEach(node => {                if (node.nodeType === Node.TEXT_NODE) {                    if (node.textContent) model.push({ text: node.textContent, style: {} });                } else if (node.nodeType === Node.ELEMENT_NODE) {                    const style = {};                    const computedStyle = window.getComputedStyle(node);                    if (computedStyle.fontWeight === '700' || computedStyle.fontWeight === 'bold') style.fontWeight = 'bold';                    if (computedStyle.fontStyle === 'italic') style.fontStyle = 'italic';                    if (computedStyle.textDecorationLine === 'underline') style.textDecoration = 'underline';                    if (computedStyle.fontSize) style.fontSize = computedStyle.fontSize;                    if (computedStyle.fontFamily) style.fontFamily = computedStyle.fontFamily;                    if (computedStyle.color) style.color = computedStyle.color;                    model.push({ text: node.textContent, style });                }            });            return mergeModel(model);        }        function getSelectionIndices(parentElement) {            const selection = window.getSelection();            if (selection.rangeCount === 0) return { start: 0, end: 0 };            const range = selection.getRangeAt(0);                        let start = 0, end = 0;            const preSelectionRange = document.createRange();            preSelectionRange.selectNodeContents(parentElement);            preSelectionRange.setEnd(range.startContainer, range.startOffset);            start = preSelectionRange.toString().length;            end = start + range.toString().length;                        return { start, end };        }        function restoreSelection(indices) {            const selection = window.getSelection();            selection.removeAllRanges();            const range = document.createRange();                        let charIndex = 0;            let startNode = null, startOffset = 0;            let endNode = null, endOffset = 0;                        function findNodeAndOffset(targetIndex) {                if (!activeEditingElement) return { node: null, offset: 0 };                for (const node of activeEditingElement.childNodes) {                    const nodeLength = node.textContent.length;                    if (charIndex + nodeLength >= targetIndex) {                        return { node: node.firstChild || node, offset: targetIndex - charIndex };                    }                    charIndex += nodeLength;                }                const lastChild = activeEditingElement.lastChild;                if (!lastChild) return { node: activeEditingElement, offset: 0 };                return { node: lastChild.firstChild || lastChild, offset: lastChild.textContent.length };            }                        const start = findNodeAndOffset(indices.start);            startNode = start.node;            startOffset = start.offset;            charIndex = 0;             const end = findNodeAndOffset(indices.end);            endNode = end.node;            endOffset = end.offset;                        try {                if (startNode && endNode) {                    range.setStart(startNode, startOffset);                    range.setEnd(endNode, endOffset);                    selection.addRange(range);                }            } catch (e) {                console.error("Falha ao restaurar a seleção.", e);            }        }        function applyStyleToSelection(styleToApply) {            if (!isEditing) return;            const selectionIndices = getSelectionIndices(activeEditingElement);            const { start, end } = selectionIndices;                        let newModel = [];            let currentIndex = 0;            activeContentModel.forEach(span => {                const spanStart = currentIndex;                const spanEnd = spanStart + span.text.length;                                if (spanEnd <= start || spanStart >= end) {                    newModel.push(span);                } else {                    const beforeText = span.text.substring(0, start - spanStart);                    const selectedText = span.text.substring(Math.max(0, start - spanStart), end - spanStart);                    const afterText = span.text.substring(end - spanStart);                                        if (beforeText) newModel.push({ text: beforeText, style: { ...span.style } });                    if (selectedText) {                        const newStyle = { ...span.style };                        for (const key in styleToApply) {                            if (['fontWeight', 'fontStyle', 'textDecoration'].includes(key)) {                                if (newStyle[key] === styleToApply[key]) {                                    delete newStyle[key];                                 } else {                                    newStyle[key] = styleToApply[key];                                }                            } else {                                newStyle[key] = styleToApply[key];                             }                             if (key === 'fontSize' && styleToApply[key] === '15px') {                                delete newStyle[key];                            }                        }                        newModel.push({ text: selectedText, style: newStyle });                    }                                        if (afterText) newModel.push({ text: afterText, style: { ...span.style } });                }                currentIndex = spanEnd;            });                        activeContentModel = mergeModel(newModel);            renderContent(activeContentModel, activeEditingElement);            restoreSelection(selectionIndices);        }                function mergeModel(model) {            if (model.length < 2) return model;            const merged = [model[0]];            for (let i = 1; i < model.length; i++) {                const prev = merged[merged.length - 1];                const current = model[i];                if (JSON.stringify(prev.style) === JSON.stringify(current.style) && !prev.isHTML && !current.isHTML) {                    prev.text += current.text;                } else {                    merged.push(current);                }            }            return merged.filter(span => span.text.length > 0);        }                function getCommonStyleInSelection() {            if (!isEditing) return null;            const { start, end } = getSelectionIndices(activeEditingElement);            if (start === end) return getStyleAtCharacterIndex(start > 0 ? start - 1 : 0);            let commonStyle = null;            let currentIndex = 0;            for (const span of activeContentModel) {                const spanStart = currentIndex;                const spanEnd = spanStart + span.text.length;                if (spanEnd > start && spanStart < end) {                     if (commonStyle === null) {                        commonStyle = { ...span.style };                    } else {                        for (const key in commonStyle) {                            if (commonStyle[key] !== span.style[key]) {                                delete commonStyle[key];                            }                        }                    }                }                currentIndex = spanEnd;            }            return commonStyle || {};        }        function getStyleAtCharacterIndex(index) {            let currentIndex = 0;            for (const span of activeContentModel) {                if (index < currentIndex + span.text.length) {                    return span.style;                }                currentIndex += span.text.length;            }            return activeContentModel[activeContentModel.length - 1]?.style || {};        }        function getStyleOfFirstCharacter(model) {            return model && model.length > 0 ? model[0].style : {};        }        initialize();    });</script></body></html>